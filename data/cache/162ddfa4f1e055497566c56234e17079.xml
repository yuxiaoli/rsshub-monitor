<?xml version="1.0" encoding="UTF-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>掘金 - 收藏集</title><link>https://juejin.im/user/1697301682482439/collections</link><atom:link href="http://rss.datuan.dev/juejin/collections/1697301682482439" rel="self" type="application/rss+xml"></atom:link><description>掘金，指定用户整个收藏集 - Powered by RSSHub</description><generator>RSSHub</generator><webMaster>contact@rsshub.app (RSSHub)</webMaster><language>en</language><lastBuildDate>Tue, 25 Mar 2025 00:37:40 GMT</lastBuildDate><ttl>5</ttl><item><title>敲了几万行源码后，我给Mybatis画了张“全地图”</title><description>&lt;p&gt;作者：小傅哥
&lt;br&gt;博客：&lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fbugstack.cn&quot; target=&quot;_blank&quot; title=&quot;https://bugstack.cn&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;bugstack.cn&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 data-id=&quot;heading-0&quot;&gt;一、说说：“产”后感受&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;🤔有人跟我说，手写Spring难，手写Mybatis易？&lt;/code&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
    &lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aba17e46195f45bfad47d019a1aad500~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp&quot; width=&quot;180px&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;一股神奇的力量&lt;/strong&gt;，让我在&lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fbugstack.cn%2Fmd%2Fspring%2Fdevelop-spring%2F2021-05-16-%25E7%25AC%25AC1%25E7%25AB%25A0%25EF%25BC%259A%25E5%25BC%2580%25E7%25AF%2587%25E4%25BB%258B%25E7%25BB%258D%25EF%25BC%258C%25E6%2589%258B%25E5%2586%2599Spring%25E8%2583%25BD%25E7%25BB%2599%25E4%25BD%25A0%25E5%25B8%25A6%25E6%259D%25A5%25E4%25BB%2580%25E4%25B9%2588%25EF%25BC%259F.html&quot; target=&quot;_blank&quot; title=&quot;https://bugstack.cn/md/spring/develop-spring/2021-05-16-%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E5%BC%80%E7%AF%87%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%89%8B%E5%86%99Spring%E8%83%BD%E7%BB%99%E4%BD%A0%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%EF%BC%9F.html&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;手写完 Spring 后&lt;/a&gt;，开始对 &lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fbugstack.cn%2Fmd%2Fspring%2Fdevelop-mybatis%2F2022-03-20-%25E7%25AC%25AC1%25E7%25AB%25A0%25EF%25BC%259A%25E5%25BC%2580%25E7%25AF%2587%25E4%25BB%258B%25E7%25BB%258D%25EF%25BC%258C%25E6%2589%258B%25E5%2586%2599Mybatis%25E8%2583%25BD%25E7%25BB%2599%25E4%25BD%25A0%25E5%25B8%25A6%25E6%259D%25A5%25E4%25BB%2580%25E4%25B9%2588%25EF%25BC%259F.html&quot; target=&quot;_blank&quot; title=&quot;https://bugstack.cn/md/spring/develop-mybatis/2022-03-20-%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E5%BC%80%E7%AF%87%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%89%8B%E5%86%99Mybatis%E8%83%BD%E7%BB%99%E4%BD%A0%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%EF%BC%9F.html&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;Mybatis 下手&lt;/a&gt;。最开始我也觉得 Spring 那么大都写下来了，Mybatis 能有多难？但随着我开始梳理、拆解、细化，Mybatis 框架源码的架构模型后发现，&lt;code&gt;事情没那么简单&lt;/code&gt;！&lt;/p&gt;
&lt;p&gt;为什么事情没那么简单？因为如果说只是为了体现出一个 ORM 框架的核心结构和功能，&lt;strong&gt;7/8&lt;/strong&gt; 个类就能实现出来。但假如是实现一个完整的串联出重要核心脉络流程的 ORM 框架，至少要在 &lt;strong&gt;100&lt;/strong&gt;个类以上，才能把 Mybatis 这些功能全部串联出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a4f68ab22e74ad4a9b250b80c6c3da9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp&quot; alt=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那为什么&lt;/strong&gt;几个类就能搞定的事要，写把开整个 Mybatis 手写一堆的代码来实现呢？&lt;/p&gt;
&lt;p&gt;其实这里有一个非常重要的点，就是你学习源码的目的是什么，&lt;em&gt;是为了面试？&lt;/em&gt; &lt;em&gt;为了熟悉流程？&lt;/em&gt; &lt;em&gt;为了跟风？&lt;/em&gt; 其实在小傅哥看来，这些都不是学习源码的核心目的和期待的结果。我们学习源码更多的是为了学习这些源码在&lt;strong&gt;面对复杂系统问题时候&lt;/strong&gt;，如何设计工程架构，运用了什么设计原则和哪些设计模式，而这些运用到的思想在代码中又是如何落地的。&lt;/p&gt;
&lt;p&gt;这样的东西，才是学习源码应该重视的内容，而且这也是能真的帮助研发人员&lt;strong&gt;提高编码思维高度&lt;/strong&gt;的东西。所以你会看到小傅哥逐步拆解 Mybatis 核心功能模块，通过渐进式的逐步开发实现，层层展开 Mybatis 的设计和实现的神秘面纱（&lt;code&gt;PS：写过以后也不太神秘&lt;/code&gt;）。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-1&quot;&gt;二、源码：全貌地图&lt;/h2&gt;
&lt;p&gt;在小傅哥手写完 Mybatis 框架以后，梳理了一张全貌地图，预览整个 Mybatis 框架的执行脉络体系。有了这张打开了战争迷雾地图的指引，再学习起来 Mybatis 的技术，也就变得非常清晰了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cf1787c9b4045509f17630409ad16b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp&quot; alt=&quot;小傅哥 Mybatis 框架源码技术全貌地图&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是整个&lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fbugstack.cn%2Fmd%2Fspring%2Fdevelop-mybatis%2F2022-03-20-%25E7%25AC%25AC1%25E7%25AB%25A0%25EF%25BC%259A%25E5%25BC%2580%25E7%25AF%2587%25E4%25BB%258B%25E7%25BB%258D%25EF%25BC%258C%25E6%2589%258B%25E5%2586%2599Mybatis%25E8%2583%25BD%25E7%25BB%2599%25E4%25BD%25A0%25E5%25B8%25A6%25E6%259D%25A5%25E4%25BB%2580%25E4%25B9%2588%25EF%25BC%259F.html&quot; target=&quot;_blank&quot; title=&quot;https://bugstack.cn/md/spring/develop-mybatis/2022-03-20-%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E5%BC%80%E7%AF%87%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%89%8B%E5%86%99Mybatis%E8%83%BD%E7%BB%99%E4%BD%A0%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%EF%BC%9F.html&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;《手写 Mybatis》&lt;/a&gt;的全貌地图，小傅哥会带着大家逐步实现这里面的功能模块，分章节细化各个模块的实现流程，最终让读者实现出一个丰富、全面、细致的 ORM 框架。在学习的过程中，大家也可以参考这张图来对照手写的代码以及 Mybatis 的源码，这样更加有利于对 Mybatis 框架的理解。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;通常如果你不是支离破碎的拼凑式学习，而是成体系的建设自己的知识栈，那么你在学习后，也一定能梳理出一套关于学习过内容的技术地图。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 data-id=&quot;heading-2&quot;&gt;三、查看：小册目录&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;🤔要吹牛了！&lt;/strong&gt; &lt;code&gt;傅哥，手写Mybatis 而已，你怎么把 Mybatis 都手写了！&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;哈哈哈，写的爽了，就顺便都给敲了，包括：解析、绑定、反射、缓存、事务，这还有注解、数据源、MetaObject 都给干了！&lt;/p&gt;
&lt;h3 data-id=&quot;heading-3&quot;&gt;1. 目录&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55cf8877b62541548d2f327d42fcc993~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp&quot; alt=&quot;《手写Mybatis》小册目录：4部分18章&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;博客：&lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fbugstack.cn%2F&quot; target=&quot;_blank&quot; title=&quot;https://bugstack.cn/&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;bugstack.cn&lt;/a&gt; - &lt;code&gt;博客菜单中 Spring 栏目下 -&amp;gt; 手撸 Mybatis&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;说明：在18章课程中，会逐步带着读者手写出一套 Mybatis 框架，并且是一套串联所有核心流程的 Mybatis 框架，阅读学习后会对 ORM 源码有透彻清晰的了解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 data-id=&quot;heading-4&quot;&gt;2. 源码&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e278a966b5ce4f7098bc201717bfc1d5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp&quot; alt=&quot;《手写Mybatis》源码内容：渐进式迭代开发&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源码：每一个章节的代码，都会在上一章节的基础上进行扩展和迭代，这样可以更加清晰的知晓，每一个章节都在添加什么功能，改动了哪些代码，新增了什么模块。这样的方式能让即使是小白读者，也可以逐步学习掌握。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 data-id=&quot;heading-5&quot;&gt;3. 视频(B站)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea98a7764fd041388b2ebf9576677543~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp&quot; alt=&quot;《手写Mybatis》视频课程：B站视频&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;视频：&lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1nY4y1B7eT&quot; target=&quot;_blank&quot; title=&quot;https://www.bilibili.com/video/BV1nY4y1B7eT&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;www.bilibili.com/video/BV1nY…&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;说明：整套源码编写内容，还会附带着视频讲解，帮助有意愿学习 Mybatis 源码的伙伴，可以快速上手并加深学习理解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 data-id=&quot;heading-6&quot;&gt;四、加入：手写源码&lt;/h2&gt;
&lt;p&gt;之所以开放一部分小册的文章和少量的代码，是为了告诉读者在跟随一个什么样的有技术热情的人在学习，能得到什么样的成长。&lt;/p&gt;
&lt;p&gt;也正因为我对技术的折腾，😄看似牛皮的能力，才能让读者放心的追求。一少部分的付费，也是为了把技术分享这条路走的更加坚定。&lt;em&gt;如果不是付费，那么大部分阅读的可能都是别人的潦草笔记，而不是深度的拆解分析，展示给读者来龙去脉。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;有需要校招、面试、晋升，想提高自己的技术深度，为自己的职业生涯续期，可以长稳发展，完善自己的技术体系，奔着高级开发和架构师路线的研发伙伴。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码地址&lt;/strong&gt;：&lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgitcode.net%2Fxiaofuge%2Fsmall-mybatis&quot; target=&quot;_blank&quot; title=&quot;https://gitcode.net/xiaofuge/small-mybatis&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;gitcode.net/xiaofuge/sm…&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7737bff5c81943698b6ad3616a91b548~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp&quot; alt=&quot;留言来自加入知识星球：码农会锁，伙伴的认可&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h2 data-id=&quot;heading-7&quot;&gt;五、总结：我的经验&lt;/h2&gt;
&lt;p&gt;其实我能知道大部分从事开发人员或者正在上学阶段的同学，其实对于源码的学习，都是非常好的提高技术的方式。但其实一大部分人都不知道对于一个源码框架该从哪下手，很多时候即使阅读源码也是感觉&lt;code&gt;拿绣花针搅拌一缸水&lt;/code&gt;，没啥收获还弄的挺疲惫😫。&lt;/p&gt;
&lt;p&gt;这是因为与平常的业务需求开发或者自己学习的案例代码相比，框架源码中运用了大量的&lt;strong&gt;设计原则&lt;/strong&gt;和&lt;strong&gt;设计模式&lt;/strong&gt;对系统功能进行&lt;code&gt;解耦&lt;/code&gt;和&lt;code&gt;实现&lt;/code&gt;，也使用了不少如&lt;code&gt;反射&lt;/code&gt;、&lt;code&gt;代理&lt;/code&gt;、&lt;code&gt;字节码&lt;/code&gt;等相关技术。&lt;/p&gt;
&lt;p&gt;所以如果没有大牛&lt;code&gt;带着你开路&lt;/code&gt;，而是自己硬摸索，其实很难里清一套源码的全部脉络。因为人在学习的过程中，总需要一份经验的借鉴、积累和使用，所以在学习源码的过程中也是要借鉴他人的经验，丰富的自己的羽翼，而后再用这些套路去学习其他的源码内容也就变得容易了。&lt;/p&gt;</description><link>https://juejin.cn/post/7111107709658726408</link><guid isPermaLink="false">https://juejin.cn/post/7111107709658726408</guid><pubDate>Mon, 20 Jun 2022 00:10:32 GMT</pubDate><author>小傅哥</author><category>后端</category><category>前端</category><category>面试</category></item><item><title>如何使用 Golang 实现一个高性能的分布式 IM</title><description>&lt;p&gt;这个项目自 2021 年中旬开始, 三端均开发由我一个人独自不间断开发直到现在, 也是我第一个耗费最多精力去开发及学习的项目. 由于我工作较多空闲时间, 基本上都在开发本项目, 从零基础零经验开始, 边学习边开发, 查阅了大量资料, 慢慢开发到现在. 第一版微服务架构在开发三个月的时候基本已经完成了, 后面则是做了微服务架构调整, 和进一步优化 IM 服务细节, 截至目前(2022年3月3日), 距离我预期的第二版, 只剩下一些收尾工作(后期补充: 收尾失败, 重新弄了).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端源码: &lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FGlide-IM%2FGlide-IM&quot; target=&quot;_blank&quot; title=&quot;https://github.com/Glide-IM/Glide-IM&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;GlideIM - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Web 端: &lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fglide-im%2Fglide_ts_sdk&quot; target=&quot;_blank&quot; title=&quot;https://github.com/glide-im/glide_ts_sdk&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;GlideIM - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在线体验 &lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Fim.dengzii.com&quot; target=&quot;_blank&quot; title=&quot;http://im.dengzii.com&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;GlideIM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 data-id=&quot;heading-0&quot;&gt;一. 功能&lt;/h2&gt;
&lt;h3 data-id=&quot;heading-1&quot;&gt;1.1 用户侧功能&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;无感掉线重连, 消息同步&lt;/li&gt;
&lt;li&gt;登录注册及保持登录&lt;/li&gt;
&lt;li&gt;一对一聊天, 群聊&lt;/li&gt;
&lt;li&gt;消息漫游, 历史记录&lt;/li&gt;
&lt;li&gt;离线消息&lt;/li&gt;
&lt;li&gt;多设备登录, 同设备互挤下线&lt;/li&gt;
&lt;li&gt;多种类型的消息 (图片, 语音等, 由客户端定义)&lt;/li&gt;
&lt;li&gt;消息撤回&lt;/li&gt;
&lt;li&gt;联系人管理, 群管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 data-id=&quot;heading-2&quot;&gt;1.2 开发侧功能&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;支持 WebSocket, TCP, 自定义连接协议&lt;/li&gt;
&lt;li&gt;支持 JSON 或 Protobuff 或自定义数据交换协议&lt;/li&gt;
&lt;li&gt;支持分布式部署, 水平扩展&lt;/li&gt;
&lt;li&gt;心跳保活, 超时断开, 清理死链接&lt;/li&gt;
&lt;li&gt;消息缓冲, 异步处理, 弱网优化&lt;/li&gt;
&lt;li&gt;消息送达机制, 消息重发, ACK&lt;/li&gt;
&lt;li&gt;消息去重, 顺序保障, 读扩散&lt;/li&gt;
&lt;li&gt;聊天机器人&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 data-id=&quot;heading-3&quot;&gt;二. 系统架构&lt;/h2&gt;
&lt;p&gt;为了提高可用性和整体的稳定性, 单机性能的限制, 必须使用分布式架构, 微服务的模式方便了维护. 我对 IM 业务部分拆分了六大核心主模块(服务), 每个服务可以水平任意数量扩展, 整个系统可以具有一定的伸缩性, 每个模块根据其业务特性划分, 逻辑和接口分离, 在保证接口简洁性的同时也有足够的扩展性.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12fae004310944e8b3e6706a20cd2105~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?&quot; alt=&quot;system_arch.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h3 data-id=&quot;heading-4&quot;&gt;2.1 聊天服务划分&lt;/h3&gt;
&lt;h4 data-id=&quot;heading-5&quot;&gt;Gateway&lt;/h4&gt;
&lt;p&gt;Gateway 模块为管理用户连接的聊天服务网关, 所有用户消息上下行都由这个模块处理. Gateway 管理用户连接, 消息的接收解析, 消息下发, 判断连接是否存活, 标识用户连接, 断开用户连接.&lt;/p&gt;
&lt;p&gt;Gateway 依赖 Messaging 服务, 接收到客户端消息将交由 Messaging 处理, Gateway 提供指定 uid 登录, 登出, 下发消息三个接口.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-6&quot;&gt;Messaging&lt;/h4&gt;
&lt;p&gt;Messaging 负责不同类型消息的路由, 例如群消息, API 消息, 也处理部分类型的消息, 例如 ACK 消息, 单聊消息, 心跳消息. 根据消息类型分别转发给 Dispatch (用户消息), API (API消息), Group(群消息).&lt;/p&gt;
&lt;p&gt;Messaging 依赖 API, GroupMessaging, Dispatch, 提供一个消息路由接口.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-7&quot;&gt;Group&lt;/h4&gt;
&lt;p&gt;(GroupMessaging), 群聊服务, 主要负责多人聊天消息的下发, 保存, 群消息确认, 成员管理. 用户上线后同步联系人时初始化群聊列表, 根据群聊所在服务通进入群聊天.&lt;/p&gt;
&lt;p&gt;Group 服务依赖 Dispatch 服务, 提供群更新, 成员更新, 发送消息到指定群三个接口.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-8&quot;&gt;API&lt;/h4&gt;
&lt;p&gt;目前暂时作为长连接的登录鉴权, HTTP API 接口都可以通过长连接消息访问, 这个可以根据具体情况灵活配置, 只需配置相关路由即可.&lt;/p&gt;
&lt;p&gt;API 依赖 Dispatch, Group 服务. 提供一个处理 API 类型消息的接口.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-9&quot;&gt;Dispatch&lt;/h4&gt;
&lt;p&gt;消息路由服务, 用于消息路由到用户所在网关, 在用户登录时通知 Dispatch 更新缓存用户对应的网关, 缓存信息通过一致性哈希保存在固定的一个服务上, 消息下发时查询缓存, 根据查询到的网关信息放入到 NSQ 队列, 每Gateway 订阅自己的消息. 这里的消息不一定是用户消息, 也可以是通知网关更新用户状态的控制消息, 例如登录登出, 由于使用消息队列进行通信, 所以叫做消息, 其实是调用 Gateway 的接口.&lt;/p&gt;
&lt;p&gt;Dispatch 不直接依赖任何服务, 消息通过 NSQ 发送到 Gateway, 提供更新路由和下发消息两个接口.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-10&quot;&gt;Broker&lt;/h4&gt;
&lt;p&gt;群聊与用户网关一样是属于带状态服务, 消息需要准确快速路由到群所在路径, Broker 和 Dispatch 功能大致相似.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-11&quot;&gt;NSQ&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fnsq.io%2F&quot; target=&quot;_blank&quot; title=&quot;https://nsq.io/&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;NSQ&lt;/a&gt; 是 Golang 实现的消息队列, 所有消息都通过 NSQ 路由. 相比其他 MQ 选择 NSQ 的理由: 去中心分布式(生产消费直连), 低延迟, 不需要顺序, 高性能, 简单二进制协议.&lt;/p&gt;
&lt;p&gt;在每一台生产者上都部署一个 nsqd.&lt;/p&gt;
&lt;h3 data-id=&quot;heading-12&quot;&gt;2.2 HTTP API 服务划分&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;认证&lt;/strong&gt;: 用户鉴权, 登录注册等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户&lt;/strong&gt;: 用户信息管理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息&lt;/strong&gt;: 消息同步, 拉取等接口, 消息ID&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;群管理&lt;/strong&gt;: 群增删改查&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上划分只是在项目中的模块划分, 并未独立成服务, 但拆分这些是轻而易举的事情, 上面这些接口既可以通过 HTTP 服务访问, 也可使用长连接访问, 长连接 与 HTTP 访问的差异在于: 1. 长连接访问需要添加 &lt;code&gt;公共请求体&lt;/code&gt;, 2. 公共响应体定义不同.&lt;/p&gt;
&lt;h3 data-id=&quot;heading-13&quot;&gt;2.3 消息路由&lt;/h3&gt;
&lt;h4 data-id=&quot;heading-14&quot;&gt;网关消息路由&lt;/h4&gt;
&lt;p&gt;在分布式部署环境下, 网关可能部署任意个实例, 用户可能连接到其中任意一个实例中, 当需要给某一个用户发送消息, 或者断开某个用户的连接时, 我们需要找到这个用户所在的网关, 这就需要记录所有在线用户所在网关. 可能快想到的是使用 Redis, 或者 Redis 加二级缓存, 但 IM 系统消息吞吐量非常大, 而且存在扩散等其他原因, Redis 很容易成为性能瓶颈.&lt;/p&gt;
&lt;p&gt;项目中使用一致性哈希算法, 将每个用户连接的网关信息按照 UID 分布在不同的 Dispatch 服务上, 从而达到分散缓存, 负载均衡, 及提高可用性的目的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d573a906d1b8466f981c3743769493dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?&quot; alt=&quot;msg_routing.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示, Dispatch 在整个环节中承当了消息分发的角色. 当某一个 Dispatch 服务宕机后, 该服务中所有缓存的网关信息都将丢失, 根据一致性哈希算法, 原来的请求都转向了下一个 Dispatch, 显然这个服务上是没有已宕机的那个服务缓存的信息的, 我们可以在用户登录后将登录信息缓存在 Redis 中 (查询登录设备列表等其他场景共用), Dispatch 内存中没查到再去 Redis 查找, 查找一次后缓存在内存中即可.新上线的用户则不影响, 只影响在线期间网关信息保存的 Dispatch 服务宕机的用户.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-15&quot;&gt;群消息的路由&lt;/h4&gt;
&lt;p&gt;群和用户一样 Group 服务也需要一样的路由, 不同群可能分布在不同的服务上, 但群并不会随意切换所在服务, 一般只有群所在的服务异常的时候重新加载群信息才可能重新分配, Broker 读多写少, 因此只需要在所有 Broker 中都缓存所有群所在服务即可, 群消息可以通过任意一台 Broker 转发, 当 Group 服务掉线和加载群时通知所有 Broker 更新即可.&lt;/p&gt;
&lt;h3 data-id=&quot;heading-16&quot;&gt;2.4 设计准则&lt;/h3&gt;
&lt;p&gt;在本项目中, 我一直在探索和追求项目整洁性与复杂系统架构之间矛盾的解决方案, 但由于我没有任何相关经验, 在项目中可能出现一些非主流的风格或错误冗余的设计, 若你对此有任何疑惑或指教, 请在 issues 中自由地发表你的想法.&lt;/p&gt;
&lt;p&gt;在面对一个庞大复杂的问题, 将问题拆分并抽象成对象, 划分为一个个小问题往往方便解决, OOP 在这方面一直是优势, 本项目使用了较多的 OOP 思想.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-17&quot;&gt;使用接口&lt;/h4&gt;
&lt;p&gt;对一些可能需要扩展的关键点, 项目中使用接口的方式实现的, 例如 Dao (数据访问对象)层实现均为接口, 出于时间原因(还有我本人对数据库方面知识匮乏), 项目中对数据库方面均是简单实现, 并未考虑例如性能等优化, 但接口不影响后期对这方面升级和替换.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-18&quot;&gt;按业务分包&lt;/h4&gt;
&lt;p&gt;包的划分方式一般有两种, 按层分包和按业务分包. 按层分包就是相同类型的模块放在同一个包, 例如将所有的 API 请求处理模块放一层, 将请求和响应的实体对象放在同一个包, 这这方法给模块的管理增加了不便, 我们更改一个接口需要在几个不同的包中修改代码, 这样分包一个包里的不同代码没有任何关联, 完全是类似于图书馆管理员根据书的出版社进行分类一样.&lt;/p&gt;
&lt;p&gt;而按功能分包则不会出现更新一个功能, 修改不同包的代码的情况, 一个功能相关的代码都在相同包内. 在本项目中每个包尽量都遵循单一职责原则, 多个包之间尽量降低耦合度.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-19&quot;&gt;模块接口依赖&lt;/h4&gt;
&lt;p&gt;项目包的划分基本和微服务的模块划分保持一致, 刚开始启动的本项目时就按照了按功能划分模块的方法, 并且每个模块只暴露提供给其他模块的接口, 模块之间的调用只通过特定的接口, 这样设计即方便维护也方便其他人查看代码, 不会使得模块之间的调用凌乱, 而且也为后期微服务化的提供了极大便利.&lt;/p&gt;
&lt;p&gt;例如 Gateway 模块的接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs language-go&quot; lang=&quot;go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 提供给其他模块的接口&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; Interface &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; {
    ClientSignIn(tempId &lt;span class=&quot;hljs-type&quot;&gt;int64&lt;/span&gt;, uid &lt;span class=&quot;hljs-type&quot;&gt;int64&lt;/span&gt;, device &lt;span class=&quot;hljs-type&quot;&gt;int64&lt;/span&gt;)
    ClientLogout(uid &lt;span class=&quot;hljs-type&quot;&gt;int64&lt;/span&gt;, device &lt;span class=&quot;hljs-type&quot;&gt;int64&lt;/span&gt;)
    EnqueueMessage(uid &lt;span class=&quot;hljs-type&quot;&gt;int64&lt;/span&gt;, device &lt;span class=&quot;hljs-type&quot;&gt;int64&lt;/span&gt;, message *message.Message)
}
&lt;span class=&quot;hljs-comment&quot;&gt;// Gateway 依赖的接口&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; MessageHandleFunc &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(from &lt;span class=&quot;hljs-type&quot;&gt;int64&lt;/span&gt;, device &lt;span class=&quot;hljs-type&quot;&gt;int64&lt;/span&gt;, message *message.Message)&lt;/span&gt;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他模块只需要知道 Gateway 模块提供客户端的登录登出和将消息加入到指定 ID 的客户端的队列即可, 其他模块不必知道 Gateway 的具体实现, 我们可以轻而易举的将这个模块替换为一个微服务服务.&lt;/p&gt;
&lt;h3 data-id=&quot;heading-20&quot;&gt;2.5 微服务&lt;/h3&gt;
&lt;p&gt;这里使用 &lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Frpcx.io%2F&quot; target=&quot;_blank&quot; title=&quot;https://rpcx.io/&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;RPCX&lt;/a&gt; 作为微服务的基础, 开箱即用的微服务方案让我选择了它, RPCX 功能丰富, 性能优越, 集成了服务发现, 多种路由方案, 以及失败模式, 服务发现使用 &lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Fwww.etcd.cn%2F&quot; target=&quot;_blank&quot; title=&quot;http://www.etcd.cn/&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;ETCD&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;服务间通讯均使用 Protobuff + RPC 方式, 在性能上这是最好的选择组合.&lt;/p&gt;
&lt;h3 data-id=&quot;heading-21&quot;&gt;2.6 项目介绍&lt;/h3&gt;
&lt;h4 data-id=&quot;heading-22&quot;&gt;项目目录&lt;/h4&gt;
&lt;p&gt;一下目录结构省略了部分不重要的目录&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs language-text&quot; lang=&quot;text&quot;&gt;├─cmd                   // 入口(从这里开始运行)
│  ├─performance_test   // 性能测试代码入口
│  ├─run                // 项目程序入口
│  │  ├─api_http        // API 接口的 HTTP 服务, 提供给客户端访问
│  │  ├─api_rpc         // API 接口的 RPC 服务, 提供给其他服务使用
│  │  ├─broker          // 群路由服务
│  │  ├─dispatch        // 网关路由服务
│  │  ├─getaway         // 网关服务
│  │  ├─group           // 群服务
│  │  ├─messaging       // IM 消息路由服务
│  │  └─singleton       // 单实例运行 (这里同时启动 IM 和 HTTP API 接口)
│  └─script             // 部署脚本
│      ├─etcd           // 启动 etcd 脚本
│      ├─glide_im       // 项目部署脚本
│      └─nsq            // nsq 部署脚本
├─config                // 配置入口
├─doc                   // 项目文档
├─im                    // IM 核心逻辑入口
│  ├─api                ////////////// API 接口
│  │  ├─apidep          // API 外部依赖        
│  │  ├─auth            // 登录认证
│  │  ├─comm            // 公共
│  │  ├─groups          // 群管理
│  │  ├─http_srv        // api http 服务启动逻辑
│  │  ├─msg             // 消息
│  │  ├─router          // 通过长连接访问接口的路由抽象
│  │  └─user            // 用户相关
│  ├─client             ///////////// 用户连接管理相关
│  ├─conn               // 长连接基础抽象
│  ├─dao                // 数据访问层, 数据库相关
│  ├─group              // 群聊, 及群聊消息
│  ├─message            // IM 消息定义
│  ├─messaging          // IM 消息路由
│  └─statistics         // 数据统计, 测试用
├─pkg                   ///////////// 包, 公共依赖管理
│  ├─db                 // 数据库
│  ├─hash               // hash 算法实现
│  ├─logger             // 日志打印
│  ├─lru                // lru 缓存实现
│  ├─mq_nsq             // nsq 封装
│  ├─rpc                // rpc 封装, 基于 rpcx
│  └─timingwheel        // 定时器, 时间轮算法实现
├─protobuf              //////////// protobuf 消息定义
│  ├─gen                // 编译好的文件
│  ├─im                 // im 消息定义
│  └─rpc                // rpc 通讯消息定义
├─service               /////////// 微服务
│  ├─api_service        // api 微服务实现
│  ├─broker             // 群路由 broker 服务
│  ├─dispatch           // 网关消息路由服务
│  ├─gateway            // 网关服务实现
│  ├─group_messaging    // 群服务
│  ├─messaging_service  // im 消息路由服务
├─sql                   // 数据库表结构 SQL
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;项目查看指南&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IM 核心逻辑在根目录下 &lt;code&gt;im&lt;/code&gt; 中, 除了微服务相关, IM 主要业务逻辑实现均在这个目录下, &lt;code&gt;im&lt;/code&gt; 下包的划分大致可以看做是后面微服务的划分, &lt;code&gt;im/conn&lt;/code&gt; 包中是长连接服务器启动和连接对象接口的逻辑, 新的连接将交由 &lt;code&gt;im/client&lt;/code&gt; 包中管理, 这个包大致是管理连接, 读写解析消息的, 收到链接中的消息将交由 &lt;code&gt;im/messaging&lt;/code&gt; 包处理, 这个包工具消息类型交给不同的模块, 例如: 认证消息给 &lt;code&gt;api&lt;/code&gt; 模块处理, 群消息分发给 &lt;code&gt;group&lt;/code&gt;, 单聊消息则 &lt;code&gt;im/client&lt;/code&gt; 下发. &lt;code&gt;im&lt;/code&gt; 下涉及业务逻辑的包下基本都有一个 &lt;code&gt;interface.go&lt;/code&gt; 文件, 这个文件定义了这个包的依赖以及向外部提供的接口.&lt;/p&gt;
&lt;p&gt;微服务相关的代码都在根目录 &lt;code&gt;service&lt;/code&gt; 包下面, IM 核心业务相关的服务逻辑都在 &lt;code&gt;im&lt;/code&gt; 下, 服务只是对其接口使用 rpc 服务的方式进行实现, 并在 &lt;code&gt;im&lt;/code&gt; 包中对应接口的默认实现进行替换, 例如 &lt;code&gt;messaging_service&lt;/code&gt; 服务(消息路由)则是将 &lt;code&gt;im/messaging&lt;/code&gt; 包下的 &lt;code&gt;Interface&lt;/code&gt; 接口的实现替换为 &lt;code&gt;messaging_service&lt;/code&gt; 的 &lt;code&gt;Server&lt;/code&gt;, 而 &lt;code&gt;messaging&lt;/code&gt; 依赖的其他包则是对应服务下的 &lt;code&gt;Client&lt;/code&gt;, 查阅每个服务包下的 &lt;code&gt;run.go&lt;/code&gt; 即可找到服务启动代码, 其中包含了其依赖的和实现设置.&lt;/p&gt;
&lt;p&gt;对于将核心逻辑和微服务剥离的这种模式是因为一开始并将微服务的划分定型(也经过了几次较大的改动), 或者为了方便将 IM 部分核心逻辑先实现和理清, 所以将两者放在两个不同的地方, 但在我实践的过程中, 对于服务的改动和 &lt;code&gt;im&lt;/code&gt; 下核心逻辑(模块接口改动除外)的改动并不会互相牵连, 这点给我很大的便利, 我还有一定的自由度划分添加服务, 例如在 &lt;code&gt;group&lt;/code&gt; 服务中间加一个 &lt;code&gt;broker&lt;/code&gt;, 或者可以针对特定 &lt;code&gt;im&lt;/code&gt; 中某个模块的接口中的一个方法进行特殊处理.&lt;/p&gt;
&lt;p&gt;但是上面所说的便利仅仅是因为我当时对微服务不太熟悉, 项目开发过程改动较大, 分开改动的时候稍微方便一些. 这样做代价就是, 两者分开不利于代码查看, 这其实是一种分层, &lt;code&gt;im&lt;/code&gt; 下定义接口及默认实现, 上层&lt;code&gt;service&lt;/code&gt;定义接口的实现, 但这些接口之间的依赖关系, 还是要去 &lt;code&gt;im&lt;/code&gt; 中寻找, 后面可能会考虑将这两个包合并在一起.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-23&quot;&gt;项目主要依赖&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FBurntSushi%2Ftoml&quot; target=&quot;_blank&quot; title=&quot;https://github.com/BurntSushi/toml&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;BurntSushi/toml&lt;/a&gt;: 这是一款优秀的配置文件格式, 个人比较喜欢&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgin-gonic%2Fgin&quot; target=&quot;_blank&quot; title=&quot;https://github.com/gin-gonic/gin&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;gin&lt;/a&gt;: 优秀的 HTTP Web 框架&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgogo%2Fprotobuf&quot; target=&quot;_blank&quot; title=&quot;https://github.com/gogo/protobuf&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;protobuff&lt;/a&gt;: Google 出品二进制数据传输协议&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgorilla%2Fwebsocket&quot; target=&quot;_blank&quot; title=&quot;https://github.com/gorilla/websocket&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;gorilla/websocket&lt;/a&gt;: Golang 中最多 star 的 WebSocket 库&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnsqio%2Fgo-nsq&quot; target=&quot;_blank&quot; title=&quot;https://github.com/nsqio/go-nsq&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;nsq&lt;/a&gt;: 简单, 高性能, 分布式 MQ&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsmallnest%2Frpcx&quot; target=&quot;_blank&quot; title=&quot;https://github.com/smallnest/rpcx&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;rpcx&lt;/a&gt;: 高性能, 功能丰富的微服务框架&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://link.juejin.cn/?target=gorm.io%2Fgorm&quot; target=&quot;_blank&quot; title=&quot;gorm.io/gorm&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;gorm&lt;/a&gt;: ORM&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fgo-redis%2Fredis&quot; target=&quot;_blank&quot; title=&quot;https://github.com/go-redis/redis&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;go-redis/redis&lt;/a&gt;: Redis 客户端&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://link.juejin.cn/?target=github.com%2Fpanjf2000%2Fants%2Fv2&quot; target=&quot;_blank&quot; title=&quot;github.com/panjf2000/ants/v2&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;ants&lt;/a&gt;: 协程池&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 data-id=&quot;heading-24&quot;&gt;构建和运行&lt;/h4&gt;
&lt;p&gt;根目录下 &lt;code&gt;cmd/run&lt;/code&gt; 下的包为程序入口, 包名表示其服务/模式, 例如 &lt;code&gt;api_http&lt;/code&gt; 包为以 HTTP 服务启动 API 的接口(提供给客户端HTTP方式调用), &lt;code&gt;api_rpc&lt;/code&gt; 为启动 API RPC 服务(提供给其他服务调用), 为了快速调试, 这里还有一个单实例模式 &lt;code&gt;singleton&lt;/code&gt;, 这个入口会同时启动 IM长连接服务和 HTTP API 服务, 方便调试 &lt;code&gt;im&lt;/code&gt; 核心逻辑, 或者调试客户端用.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境依赖&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单实例
&lt;ul&gt;
&lt;li&gt;redis&lt;/li&gt;
&lt;li&gt;mysql&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;微服务
&lt;ul&gt;
&lt;li&gt;nsq&lt;/li&gt;
&lt;li&gt;etcd&lt;/li&gt;
&lt;li&gt;包含单实例的所有依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单实例模式在 &lt;code&gt;singleton&lt;/code&gt; 包中 &lt;code&gt;config.toml&lt;/code&gt; 修改相关配置&lt;/li&gt;
&lt;li&gt;微服务模式需要将 &lt;code&gt;service/example_config.toml&lt;/code&gt; 文件复制到对于服务入口下, 并根据环境修改相关配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果依赖或者其他原因无法在 IDE 中运行代码, 可以在 &lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fp3-juejin.byteimg.com%2Ftos-cn-i-k3u1fbpfcp%2F09c2b4f6397e4554b0910670afb11ad8~tplv-k3u1fbpfcp-zoom-1.image&quot; target=&quot;_blank&quot; title=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09c2b4f6397e4554b0910670afb11ad8~tplv-k3u1fbpfcp-zoom-1.image&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;这里&lt;/a&gt; 下载已经编译好的 &lt;code&gt;singleton&lt;/code&gt; 模式的可执行文件.&lt;/p&gt;
&lt;h3 data-id=&quot;heading-25&quot;&gt;2.7 现存问题&lt;/h3&gt;
&lt;h4 data-id=&quot;heading-26&quot;&gt;协议相关&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;客户端协议选择&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前为了方便客户端使用 json 进行通信, 也是因为浏览器对二进制协议的支持不友好, 但后端对二者都有实现, 协议动态选择并没有实现, 或者区分 websocket 和 tcp 网关, 将二者区分, 浏览器的与移动端环境有差异, 但未做处理.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Protobuf 和 Json 的兼容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;微服务使用 protobuf 协议, 而客户端消息可能以 json 协议, 部分使用同一个由 &lt;code&gt;protoc&lt;/code&gt; 编译生成的 struct 在兼容上存在一些问题, 暂未处理.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息解析性能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 go 中的 json.Marshal 性能极差, 在整个消息流转过程中占用了大量时间, 暂未优化, 目前有多种第三方方案可以选择.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协议版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;消息协议可能会升级, 新老客户端使用不同协议版本兼容上为做处理.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-27&quot;&gt;数据库相关&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;消息 ID 生成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目中目前使用 Redis Incr 生成递增 ID, 存在性能问题, 后面可以考虑使用 Leaf 等方案.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库, 表, 查询优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;未对这方面做任何优化, dao 层均只是简单实现了 CRUD 功能.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-28&quot;&gt;微服务相关&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;配置管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前启动服务是通过本地配置文件加载配置启动, 部署管理起来不太方便, 后面考虑使用配置中心.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前微服务和 IM 逻辑是分层设计, 不方便维护和查看, 后面需要调整.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-29&quot;&gt;群聊的相关&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;消息风暴&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;群消息存在扩散问题, 尤其是大群一个成员发消息扩散几千上万次, 群数量稍微多一点或者消息稍微频繁一点, 消息数量非常容易失控. 在微服务模式下需要对系统网关的用户消息进行合并打包成一条消息.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;群聊服务故障&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;群聊属于带状态服务, 当群所在服务宕机后如何不影响群消息的分发, 这点暂未处理, 对于恢复可以新增一个群聊服务监控服务, 监控到某一个群聊服务掉线立马恢复, 但这仅是故障恢复而不是对故障转移.&lt;/p&gt;
&lt;h2 data-id=&quot;heading-30&quot;&gt;三. 设计细节&lt;/h2&gt;
&lt;p&gt;由于 GlideIM 的设计细节较多, 限于时间和篇幅, 这里只列举了几个较为重要的环节来做简单的说明, 详细情况或其他未说明的地方可以查看源码或加入讨论群一起讨论.&lt;/p&gt;
&lt;h3 data-id=&quot;heading-31&quot;&gt;3.1 消息类型&lt;/h3&gt;
&lt;p&gt;IM 消息类型指的是聊天协议消息类型, 注意区别聊天内容的消息类型, IM 消息类型关联前后端双方的业务逻辑, 聊天消息类型只需要在前端处理.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IM 消息类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;聊天消息: 重发, 重试, 撤回, 群聊, 单聊&lt;/li&gt;
&lt;li&gt;ACK 消息: 服务器确认收到, 接受者确认通知, 接受者确认送达&lt;/li&gt;
&lt;li&gt;心跳消息: 客户端心跳, 服务端心跳&lt;/li&gt;
&lt;li&gt;API 消息: 令牌认证, 退出等&lt;/li&gt;
&lt;li&gt;通知消息: 新联系人, kickout, 多端登录等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;聊天内容消息类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图片&lt;/li&gt;
&lt;li&gt;文本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;消息类型由客户端定义及处理, 二进制消息例如语音, 图片则上传到服务器再发送 URL. 例如红包这种互动型消息, 一样可以使用这种方法.&lt;/p&gt;
&lt;p&gt;客户端之间定义约定消息类型即方便了后期添加消息类型, 也方便了后端维护, 后端并不需要知道消息内容的类型.&lt;/p&gt;
&lt;h3 data-id=&quot;heading-32&quot;&gt;3.2 送达机制&lt;/h3&gt;
&lt;p&gt;虽说 TCP 是可靠传输, 但在消息传递过程并不是万无一失的, 例如, 接受者在线但网络不好, 客户端在重连, 则消息可能不能及时送达接受者, 设计一个送达机制提高送达率是必要的. GlideIM 采用了单条消息两次确认(服务端和接收者)的送达机制.&lt;/p&gt;
&lt;p&gt;A 发送一条消息给 B, 如果 B 在线, 服务端则回复 A 一条服务端确认收到消息告诉 A 服务端已收到, 已经入库保存了, 然后服务端发送给 B, B 收到则发送一条确认收到消息给服务端, 服务端收到后再发送一条确认送达消息给 A, 若 B 不在线则直接发送给 A 确认送达,  A 此时就知道这条消息一定被 B 收到了, 在此过程中 A 如果没有收到 B 确认收到则多次重试.&lt;/p&gt;
&lt;p&gt;在客户端做重发避免了服务端逻辑复杂化, 而客户端做则大大简化了逻辑. 有了这个送达机制, 不管是消息丢了还是网络环境不好的时候, 都能提高送达率和消息及时率, 再者若我们使用 UDP, 有了这个机制也可以确保消息的送达率.&lt;/p&gt;
&lt;p&gt;GlideIM 消息 ACK 机制几种消息丢失情况下的时序图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e9b002e69ef403dac81265e1a2280ae~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?&quot; alt=&quot;message_ack.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;以上只是 GlideIM 保障送达的一部分, 实际上还有接收端根据 Seq 判断是否消息缺失等其他措施.&lt;/p&gt;
&lt;h3 data-id=&quot;heading-33&quot;&gt;3.3 消息路由&lt;/h3&gt;
&lt;p&gt;在分布式环境下, 用户连接到不同的网关上, 我们必须知道用户所在的网关才能准确的投递消息, 因此, 必须在用户连接到网关的时候缓存所在网关信息, 在投递消息的时候才能准确地投递到用户所在网关.&lt;/p&gt;
&lt;p&gt;GlideIM 的设计是在用户登录时在 Redis 中缓存网关信息, 我们当然不能每次发消息都查询 Redis, 可以在内存中缓存一份, 内存中没有则查询 Redis. 用户登录聊天服务后根据联系人列表所在不同网关, 通知网关更新自己的路由信息.&lt;/p&gt;
&lt;p&gt;为了避免客户端频繁切换网关, 客户端接入网关由服务端在用户登录时返回, 这样做还可以为制定负载均衡策略, 多端登录连接同网关等做考虑.&lt;/p&gt;
&lt;h3 data-id=&quot;heading-34&quot;&gt;3.4 保活机制&lt;/h3&gt;
&lt;p&gt;TCP 虽有 KeepAlive, 但其默认时间太长, 且不能判断服务是否可用或客户端是否可用, KeepAlive 仅仅保证 TCP 处于连接状态, 如果应用层发生错误, 服务端连接却依旧通畅明显是不行的.&lt;/p&gt;
&lt;p&gt;心跳分为服务端心跳和客户端心跳, 大部分情况是客户端侧网络不通畅, 例如进电梯, 息屏省电模式, 而服务端一般只会在宕机的情况才会网络不通畅, 因此 GlideIM 在客户端进行主动心跳, 若在指定时间内服务端未收到心跳则服务端开始发送心跳包, 指定次数没有收到客户端心跳则断开连接.&lt;/p&gt;
&lt;p&gt;客户端心跳为 30s, 但并不是每隔30s都发心跳, 而是 30s 内客户端没有主动发送任何消息, 则进行一次心跳, 服务端也是根据这个规则判断, 这样减少了心跳的次数的同时也能确保存活.&lt;/p&gt;
&lt;h3 data-id=&quot;heading-35&quot;&gt;3.5 消息协议&lt;/h3&gt;
&lt;p&gt;消息协议需要考虑到消息编码后的大小, 可读性, 编码速度, 支持的语言等. 可以选择二进制协议和文本协议两种, 二进制例如 Protobuff, 或者自定义, 文本协议例如 JSON, XML.&lt;/p&gt;
&lt;p&gt;GlideIM 同时实现了 Protobuff 和 JSON 两种消息协议. 客户端可以自由选择使用哪种协议, 在测试结果中显示 Protobuff 比 JSON 至少快 10 倍, 在使用JSON时整个流程中, 消息解析占用了很大一部分时间.&lt;/p&gt;
&lt;h3 data-id=&quot;heading-36&quot;&gt;3.6 消息去重和排序&lt;/h3&gt;
&lt;p&gt;GlideIM 的消息去重依靠全局消息 ID, 消息ID暂时使用 Redis Incr, 后面会使用美团 Leaf, 在 GlideIM 中替换消息 ID 生成策略非常简单, 消息 ID 由客户端发送消息时获取, 发送时附带该 ID 以实现去重, 和发送方消息的排序.&lt;/p&gt;
&lt;p&gt;在一对一单聊的情况, GlideIM 只保障发送方有序, 而一个会话内的所有消息是不必保障顺序的, 相对其付出的代价和带来的收益. 而群聊则是保障所有消息有序的, 群消息下发会附带当前群的连续递增 Seq, 收到群消息根据 Seq 排序, 若发现不连续则拉取不连续部分的消息.&lt;/p&gt;
&lt;h2 data-id=&quot;heading-37&quot;&gt;四. 性能测试&lt;/h2&gt;
&lt;p&gt;GlideIM 消息面对高并发吞吐量压力测试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ceb50b69363340159cd814f1bb17348e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp&quot; alt=&quot;P&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h3 data-id=&quot;heading-38&quot;&gt;4.1 测试结果&lt;/h3&gt;
&lt;p&gt;单实例部署模式下, 4H8G, 100Mbps 宽带理论上支持 20w 活跃用户在线同时聊天, 此时带宽是性能的瓶颈.&lt;/p&gt;
&lt;h3 data-id=&quot;heading-39&quot;&gt;4.2 测试过程&lt;/h3&gt;
&lt;p&gt;服务端配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs language-yaml&quot; lang=&quot;yaml&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;Windows&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;hljs-string&quot;&gt;AMD&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;R5&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;3600 &lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;核12线程&lt;/span&gt; 
&lt;span class=&quot;hljs-string&quot;&gt;16GB&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;内存&lt;/span&gt;
&lt;span class=&quot;hljs-string&quot;&gt;100Mbps&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;网卡&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 data-id=&quot;heading-40&quot;&gt;案例 1 测试过程&lt;/h4&gt;
&lt;p&gt;A 机器运行服务端, B模拟客户端连接登录发消息的过程, 并运行数据库&lt;/p&gt;
&lt;p&gt;同时模拟 2000 客户端, 每间隔 60ms-200ms 发送一条消息, 每个客户端发送 600 条消息, 共计 1200_000 条消息.&lt;/p&gt;
&lt;p&gt;网卡负载平均 90% (100Mbps), 每秒约 30_000 条消息吞吐量, 每秒上下行各 15k 条, 送达率 100%, 所有消息延时&amp;lt;=20ms, 参考结果1图.&lt;/p&gt;
&lt;p&gt;测试情况:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs language-erlang&quot; lang=&quot;erlang&quot;&gt;网络 &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;%&lt;/span&gt;
&lt;span class=&quot;hljs-number&quot;&gt;2000&lt;/span&gt; 连接
&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;条消息/秒/连接
&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;k消息/tps
送达率 &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;%&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 data-id=&quot;heading-41&quot;&gt;案例 2 测试过程&lt;/h4&gt;
&lt;p&gt;这个案例只为了测试程序在高并发情况下的运行情况, 参考价值也仅限于程序本身的短板和代码逻辑极限, 在实际情况中我们无法忽略网络速率等因素的影响.&lt;/p&gt;
&lt;p&gt;由于需要去除网卡速率限制, 服务和模拟客户端都在同一台设备上运行则不受网络因素影响, 模拟10000个链接, 每个连接 50ms-100ms 发送一条消息, 总共发送 800 条.&lt;/p&gt;
&lt;p&gt;此案例消息吞吐量极限为 28w, 此时已达到 cpu 性能极限, 占用率约98%, 客户端模拟 cpu 占用率高于服务端, 但无关紧要.&lt;/p&gt;
&lt;p&gt;测试案例 pprof CPU使用情况分析数据: &lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FGlide-IM%2FGlide-IM%2Fraw%2Fmaster%2F_art%2Fcpu_pprof_msg_io_no_db.out&quot; target=&quot;_blank&quot; title=&quot;https://github.com/Glide-IM/Glide-IM/raw/master/_art/cpu_pprof_msg_io_no_db.out&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;cpu.out&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;测试情况:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs language-erlang&quot; lang=&quot;erlang&quot;&gt;CPU &lt;span class=&quot;hljs-number&quot;&gt;98&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;%&lt;/span&gt;
内存约 &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; GB
&lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt; 连接峰值, 每 &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;ms 开始一个连接
&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;条消息/秒/连接, 累计发送&lt;span class=&quot;hljs-number&quot;&gt;800&lt;/span&gt;条
&lt;span class=&quot;hljs-number&quot;&gt;280&lt;/span&gt;k消息/tps 峰值
送达率 &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;%&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 data-id=&quot;heading-42&quot;&gt;测试环境限制&lt;/h4&gt;
&lt;p&gt;由于测试只有两台电脑, 存在端口数限制(部署到服务器, 用户连接不存在这个限制), 为了提高 MySQL 连接池的大小提高并发, 必须尽量用更少的连接数和每个连接更密集的发送消息来进行测试&lt;/p&gt;
&lt;p&gt;百兆网卡上限速率只有 12.5MB/s, 一条消息包含 20 个汉字则至少需要 40B, 再加上报头其他占用, 假设 100B, 则实际百兆网卡最大的消息并发是 12.5 x 1024 x 1024 / 100 = 13w 条, 而去除
ACK, 再上下行消息数量对半, 实际可能就 6w/s 消息就是 GlideIM 在 100Mbps 环境下的理论极限.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-43&quot;&gt;测试代码&lt;/h4&gt;
&lt;p&gt;单机性能测试&lt;/p&gt;
&lt;p&gt;测试代码路径: &lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FGlide-IM%2FGlide-IM%2Ftree%2Fmaster%2Fcmd%2Fperformance_test&quot; target=&quot;_blank&quot; title=&quot;https://github.com/Glide-IM/Glide-IM/tree/master/cmd/performance_test&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;/cmd/performance_test/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.启动服务器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs language-shell&quot; lang=&quot;shell&quot;&gt;go test -v -run=TestServerPerf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.开始用户模拟&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs language-shell&quot; lang=&quot;shell&quot;&gt;go test -v -run=TestRunClient
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 data-id=&quot;heading-44&quot;&gt;4.3 性能参考指标说明&lt;/h3&gt;
&lt;h4 data-id=&quot;heading-45&quot;&gt;连接数&lt;/h4&gt;
&lt;p&gt;很多 IM 项目喜欢用类似于 &quot;百万连接&quot; 之类的字眼, 很多人可能是受常规 HTTP 服务 &quot;百万并发&quot; 的影响, 认为百万连接与百万并发具有一致的性能参考价值, 开发者为了吸引眼球使用百万连接的字眼, 也确实支持百万链接.&lt;/p&gt;
&lt;p&gt;事实上, TCP(或WS) 连接数的限制并不在于程序本身, 系统最大可打开 文件描述符 和 内存 限制了最大连接数, 一个 TCP 连接大约需要占用 4-10KB 内存, 一台 16GB 的服务器理论上最大支持约 16 * 1024 *
1024 / 5 ≈ 335w 连接.&lt;/p&gt;
&lt;p&gt;活跃用户数则比单纯的连接数更有参考价值, 例如支持 100w 活跃连接, 每个活跃连接10s发送一条消息.&lt;/p&gt;
&lt;h4 data-id=&quot;heading-46&quot;&gt;消息吞吐量&lt;/h4&gt;
&lt;p&gt;相比连接数, 消息吞吐量更具有参考价值, 消息吞吐量需要结合网络速率做参考. 消息吞吐量受限点主要有一下几个:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息送达保障机制的性能(即保障送达又不冗余)&lt;/li&gt;
&lt;li&gt;消息数据传输协议的性能(单条消息尽可能减小体积)&lt;/li&gt;
&lt;li&gt;非用户消息的数据包数量控制(例如心跳包, 内容同步包等)&lt;/li&gt;
&lt;li&gt;网络速率和质量(外部因素)&lt;/li&gt;
&lt;li&gt;程序本身消息下发设计缺陷&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 data-id=&quot;heading-47&quot;&gt;其他指标&lt;/h4&gt;
&lt;p&gt;考量一款 IM 的性能的意义大部分可能只在于揭示它自身的性能短板, 横向对比其他项目在大部分情况都无法得出正确的对比结果, 单项指标也不能完全衡量整个项目的优劣, 我们应该结合其业务逻辑, 设计思想, 学习其优点才能有所收获.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息送达率&lt;/li&gt;
&lt;li&gt;消息延迟和消息顺序的准确性&lt;/li&gt;
&lt;li&gt;链接保活和去死链(心跳)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 data-id=&quot;heading-48&quot;&gt;4.4 性能指标估算&lt;/h3&gt;
&lt;p&gt;1.连接数&lt;/p&gt;
&lt;p&gt;假设设内存为 M GB&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs language-text&quot; lang=&quot;text&quot;&gt;理论连接数  = M * 1024m * 1024k / (4k/tcp)

保守估算连接数 = M * 1024m * 1024k / (10k/tcp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.消息吞吐量估算&lt;/p&gt;
&lt;p&gt;设网卡速率为 S Mbps, 平均每条消息为 K 字节(写入 TCP 连接时的总大小).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs language-text&quot; lang=&quot;text&quot;&gt;消息吞吐量 = S / 8 * 1024k * 1024b / K
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.活跃用户数估算&lt;/p&gt;
&lt;p&gt;设吞吐量 T, 设平均每个用户每 N 秒发送一条消息.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在确认送达机制下 (每条消息的发送, 假设收发双方读在线, 服务端客户都需ACK, 共需要 5 条消息上下行)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;hljs language-text&quot; lang=&quot;text&quot;&gt;活跃用户数 = T / 5 * N
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;仅确认送达服务端&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;hljs language-text&quot; lang=&quot;text&quot;&gt;活跃用户数 = T / 3 * N
&lt;/code&gt;&lt;/pre&gt;</description><link>https://juejin.cn/post/7088262766779170853</link><guid isPermaLink="false">https://juejin.cn/post/7088262766779170853</guid><pubDate>Tue, 19 Apr 2022 10:40:15 GMT</pubDate><author>dengzi</author><category>后端</category><category>Go</category></item><item><title>SQL 查找是否“存在“，别再 count 了，很耗费时间的！</title><description>&lt;ul&gt;
&lt;li&gt;目前多数人的写法&lt;/li&gt;
&lt;li&gt;优化方案&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据某一条件从数据库表中查询 『有』与『没有』，只有两种状态，那为什么在写SQL的时候，还要SELECT count(*) 呢？&lt;/p&gt;
&lt;p&gt;无论是刚入道的程序员新星，还是精湛沙场多年的程序员老白，都是一如既往的count
目前多数人的写法
多次REVIEW代码时，发现如现现象：
业务代码中，需要根据一个或多个条件，查询是否存在记录，不关心有多少条记录。普遍的SQL及代码写法如下&lt;/p&gt;
&lt;h4 data-id=&quot;heading-0&quot;&gt;SQL写法:&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs language-sql&quot; lang=&quot;sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;count&lt;/span&gt;(&lt;span class=&quot;hljs-operator&quot;&gt;*&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; a &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;AND&lt;/span&gt; b &lt;span class=&quot;hljs-operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 data-id=&quot;heading-1&quot;&gt;Java写法:&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs language-csharp&quot; lang=&quot;csharp&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; nums = xxDao.countXxxxByXxx(&lt;span class=&quot;hljs-keyword&quot;&gt;params&lt;/span&gt;);
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ( nums &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; ) {
  &lt;span class=&quot;hljs-comment&quot;&gt;//当存在时，执行这里的代码&lt;/span&gt;
} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
  &lt;span class=&quot;hljs-comment&quot;&gt;//当不存在时，执行这里的代码&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是不是感觉很OK，没有什么问题
优化方案
推荐写法如下：&lt;/p&gt;
&lt;h4 data-id=&quot;heading-2&quot;&gt;SQL写法:&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs language-css&quot; lang=&quot;css&quot;&gt;SELECT &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;table&lt;/span&gt; WHERE &lt;span class=&quot;hljs-selector-tag&quot;&gt;a&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; AND &lt;span class=&quot;hljs-selector-tag&quot;&gt;b&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; LIMIT &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 data-id=&quot;heading-3&quot;&gt;Java写法:&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs language-arduino&quot; lang=&quot;arduino&quot;&gt;Integer exist = xxDao.&lt;span class=&quot;hljs-built_in&quot;&gt;existXxxxByXxx&lt;/span&gt;(params);
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ( exist != &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt; ) {
  &lt;span class=&quot;hljs-comment&quot;&gt;//当存在时，执行这里的代码&lt;/span&gt;
} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
  &lt;span class=&quot;hljs-comment&quot;&gt;//当不存在时，执行这里的代码&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SQL不再使用count，而是改用LIMIT 1，让数据库查询时遇到一条就返回，不要再继续查找还有多少条了
业务代码中直接判断是否非空即可&lt;/p&gt;
&lt;h4 data-id=&quot;heading-4&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;根据查询条件查出来的条数越多，性能提升的越明显，在某些情况下，还可以减少联合索引的创建。&lt;/p&gt;</description><link>https://juejin.cn/post/6933481147699560455</link><guid isPermaLink="false">https://juejin.cn/post/6933481147699560455</guid><pubDate>Fri, 26 Feb 2021 08:08:20 GMT</pubDate><author>码农突围</author><category>后端</category><category>MySQL</category></item><item><title>如何像spring 一样使用vertx</title><description>&lt;h1 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;如何像spring 一样使用vertx&lt;/h1&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;什么是vertx&lt;/h2&gt;
&lt;p&gt;EclipseVert.x是事件驱动和非阻塞的。这意味着您的应用程序可以使用少量的内核线程处理大量并发。Vert.x让你的应用程序可以用最少的硬件扩展,Vert.x与多种语言一起使用，包括Java、Kotlin、JavaScript、Groovy、Ruby和Scala。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/25/171b1c3a8d2d8eda~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;
&lt;figure&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/25/171b1c3c5af49169~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;
技术无好坏,只有适合不适合.&lt;p&gt;&lt;/p&gt;
&lt;p&gt;Vertx，是一个基于JVM、轻量级、高性能的应用平台，非常适用于移动端后台、互联网、企业应用架构。&lt;/p&gt;
&lt;p&gt;Vertx，基于Netty全异步通信，并扩展出了很多有用的特性。&lt;/p&gt;
&lt;p&gt;Vertx，是基于事件总线设计的高性能架构，保证应用中不同部分以一种非堵塞的线程安全方式通讯。&lt;/p&gt;
&lt;p&gt;Vertx，是借鉴Erlang和Akka架构设计，能充分利用多核处理器性能并实现高并发编程需求的框架。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vertx特点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支持多种编程语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前支持Java、JavaScript、Ruby、Python、Groovy、Clojure、Ceylon等，并提供友好的API接口。以上技术栈的工程师可以非常容易的学习和使用Vert.x 架构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;异步无锁编程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经典的多线程编程模型能满足很多Web开发场景，但随着移动互联网并发连接数的猛增，多线程并发控制模型性能难以扩展，同时要想控制好并发锁需要较高的技巧，目前Reactor异步编程模型开始跑马圈地，而Vert.x就是这种异步无锁编程的一个首选。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对各种IO的丰富支持&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前Vert.x的异步模型已支持TCP、UDP、FileSystem、DNS、EventBus、Sockjs等，基本满足绝大多数系统架构需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分布式消息传输&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vert.x基于分布式Bus消息机制实现其Actor模型，我们的业务逻辑如果依赖其他Actor则通过Bus简单的将消息发送出去就可以了。EventBus事件总线，可以轻松编写分布式解耦的程序，具有很好的扩展性。&lt;/p&gt;
&lt;p&gt;EventBus也是Vert.x架构的灵魂所在。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;生态体系日趋成熟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vertx归入Eclipse基金会门下，异步驱动已经支持了Postgres、MySQL、MongoDB、Redis等常用组件，并且有若干Vertx在生产环境中的应用案例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/25/171b1c44076db37b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Vertx是轻量级的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vertx的核心代码包只有650kB左右，同时提供丰富的扩展插件，满足各类需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vertx本身内置强大的模块管理机制,当你写完一个Vert.x业务逻辑的时候,你可以将其打包成module,然后部署到基于Maven的仓库里,与现有主流的开发过程无缝结合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支持WebSocket&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;支持WebSocket协议兼容SockJS ， 可以非常方便的实现web前端和服务后端长连接通信，是轻量级web聊天室应用首选解决方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用简单&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里的简单意味着你编写的代码是完全基于异步事件的,类似Node.JS,与此同时.你不需要关注线程上的同步,与锁之类的概念,所有的程序都是异步执行并且通信是无阻塞的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;良好的扩展性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为基于Actor模型,所以你的程序都是一个点一个点的单独在跑,一群点可以组成一个服务,某个点都是可以水平扩展,动态替换,这样你的程序,基本就可以达到无限制的水平扩展。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;高并发性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vert.x是一个事件驱动非阻塞的异步编程框架，你可以在极少的核心线程里占用最小限度的硬件资源处理大量的高并发请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;基本概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;handler: 事件处理器
event loop:事件循环(线程)(同netty)
verticle: Vert.x 基本组件,模块。
worker: 工作线程
event bus: 事件总线&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们看下vertx 的java开发流程&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs java&quot; lang=&quot;java&quot;&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; io.vertx.core.AbstractVerticle;
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Server&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;AbstractVerticle&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
    vertx.createHttpServer().requestHandler(req -&amp;gt; {
      req.response()
        .putHeader(&lt;span class=&quot;hljs-string&quot;&gt;&quot;content-type&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;text/plain&quot;&lt;/span&gt;)
        .end(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello from Vert.x!&quot;&lt;/span&gt;);
    }).listen(&lt;span class=&quot;hljs-number&quot;&gt;8080&lt;/span&gt;);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/25/171b1c46a13224db~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;但同时vertx也有他的缺点,就拿vertx-web相比springmvc来说,vertx更加灵活,但同时也需要开发人员weba原生开发有更深刻的了解,包括各种请求返回头的添加,以及各种拦截器,自定义消息转换等的处理,都需要开发人员自行配置,这显然是大部分开发人员所不愿意的,所以导致了vertx目前并不怎么流行,但这些并不影响一个框架本身的魅力.当然还有很多轻量级的web开发框架,jfinal,play等等小众框架.&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;什么是vertx-web-springmvc?&lt;/h2&gt;
&lt;p&gt;vertx-web-springmvc  是基于vertx -web 类似springmvc的开发风格的web框架,方便原spring开发人员无缝迁移&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;springmvc 风格开发&lt;/li&gt;
&lt;li&gt;统一异常处理&lt;/li&gt;
&lt;li&gt;拦截器&lt;/li&gt;
&lt;li&gt;统一结果处理&lt;/li&gt;
&lt;li&gt;springmvc 风格模板渲染&lt;/li&gt;
&lt;li&gt;静态资源&lt;/li&gt;
&lt;li&gt;支持spring容器&lt;/li&gt;
&lt;li&gt;跨域支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;springmvc 风格注解介绍&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;注解&lt;/th&gt;
&lt;th&gt;用法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;TemplateBody&lt;/td&gt;
&lt;td&gt;类似springmvc的@ ResponseBody标记模板渲染 阻塞执行,配合 VertxTemplateEngine标记&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ResponseBody&lt;/td&gt;
&lt;td&gt;类似springmvc的 @ResponseBody 标记消息转换 (依赖 MessageConverter)阻塞执行,配合 VertxMessageConverter标记&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RouteHandler&lt;/td&gt;
&lt;td&gt;类似springmvc的 @Controller&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RouteMapping&lt;/td&gt;
&lt;td&gt;类似springmvc的 @RequestMapping&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Interceptor&lt;/td&gt;
&lt;td&gt;vertx 拦截器标记&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RouterAdvice&lt;/td&gt;
&lt;td&gt;类似springmvc的 @ControllerAdvice&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ExceptionHandler&lt;/td&gt;
&lt;td&gt;类似springmvc的 @ExceptionHandler 异常处理&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;vertx-web-springmvc 开发示例&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;json,模板渲染,vertx-web 原生开发示例&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;hljs java&quot; lang=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.taoyuanx.vertxdemo.withspring.web;

&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.taoyuanx.springmvc.vertx.core.anno.route.ResponseBody;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.taoyuanx.springmvc.vertx.core.anno.route.RouteHandler;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.taoyuanx.springmvc.vertx.core.anno.route.RouteMapping;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; com.taoyuanx.springmvc.vertx.core.core.template.TemplateBody;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; io.vertx.core.Handler;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; io.vertx.core.http.HttpMethod;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; io.vertx.core.json.JsonObject;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; io.vertx.ext.web.RoutingContext;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; org.springframework.stereotype.Component;

&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.TimeUnit;

&lt;span class=&quot;hljs-comment&quot;&gt;/**
 * &lt;span class=&quot;hljs-doctag&quot;&gt;@author&lt;/span&gt; dushitaoyuan
 * &lt;span class=&quot;hljs-doctag&quot;&gt;@date&lt;/span&gt; 2020/4/21
 */&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;@RouteHandler&lt;/span&gt;(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;api&quot;&lt;/span&gt;)

&lt;span class=&quot;hljs-meta&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;RouteHandlerDemo&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-meta&quot;&gt;@RouteMapping&lt;/span&gt;(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;demo&quot;&lt;/span&gt;, method = HttpMethod.GET)
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Handler&amp;lt;RoutingContext&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ctx -&amp;gt; {
            ctx.response().end(&lt;span class=&quot;hljs-string&quot;&gt;&quot;demo&quot;&lt;/span&gt;);
            System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;demo&quot;&lt;/span&gt;);
        };
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@RouteMapping&lt;/span&gt;(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;blockDemo&quot;&lt;/span&gt;, method = HttpMethod.GET, blocked = &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;)
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Handler&amp;lt;RoutingContext&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;blockHande&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ctx -&amp;gt; {
            &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
                TimeUnit.SECONDS.sleep(&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;);
                System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;blockDemo&quot;&lt;/span&gt;);
                ctx.response().end(&lt;span class=&quot;hljs-string&quot;&gt;&quot;blockDemo&quot;&lt;/span&gt;);
            } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; RuntimeException(e);
            }

        };
    }
  
    &lt;span class=&quot;hljs-meta&quot;&gt;@RouteMapping&lt;/span&gt;(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;jsonMessage&quot;&lt;/span&gt;, method = HttpMethod.GET)
    &lt;span class=&quot;hljs-meta&quot;&gt;@ResponseBody&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; JsonObject &lt;span class=&quot;hljs-title&quot;&gt;jsonMessage&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(RoutingContext ctx)&lt;/span&gt; &lt;/span&gt;{
        JsonObject jsonObject=&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; JsonObject();
        jsonObject.put(&lt;span class=&quot;hljs-string&quot;&gt;&quot;spring json&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;json&quot;&lt;/span&gt;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; jsonObject;
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@RouteMapping&lt;/span&gt;(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;template&quot;&lt;/span&gt;, method = HttpMethod.GET)
    &lt;span class=&quot;hljs-meta&quot;&gt;@TemplateBody&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(RoutingContext ctx,JsonObject dataModel)&lt;/span&gt;
    &lt;/span&gt;{
        dataModel.put(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;dushitaoyuan say hi to you! thymeleaf&quot;&lt;/span&gt;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;index.html&quot;&lt;/span&gt;;
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@RouteMapping&lt;/span&gt;(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;template2&quot;&lt;/span&gt;, method = HttpMethod.GET)
    &lt;span class=&quot;hljs-meta&quot;&gt;@TemplateBody&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;template2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(RoutingContext ctx,JsonObject dataModel)&lt;/span&gt;
    &lt;/span&gt;{
        dataModel.put(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;dushitaoyuan say hi to you! freemarker&quot;&lt;/span&gt;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;index.ftl&quot;&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;异常处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs java&quot; lang=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RouterAdvice&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;RouteAdviceDemo&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-meta&quot;&gt;@ExceptionHandler&lt;/span&gt;(value = MyException.class)
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Handler&amp;lt;RoutingContext&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ctx -&amp;gt; {
            MyException failure = (MyException) ctx.failure();
            ResponseUtil.responseJson(ctx, &lt;span class=&quot;hljs-number&quot;&gt;500&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; JsonObject().put(&lt;span class=&quot;hljs-string&quot;&gt;&quot;errorMsg&quot;&lt;/span&gt;,failure.getMessage()));
        };
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义模板引擎&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;hljs java&quot; lang=&quot;java&quot;&gt;    ThymeleafTemplateEngine thymeleafTemplateEngine = ThymeleafTemplateEngine.create(serverConfig.getVertx());
            FreeMarkerTemplateEngine freeMarkerTemplateEngine = FreeMarkerTemplateEngine.create(serverConfig.getVertx());
            springMvcRouterHandler.registVertxTemplateEngine(&lt;span class=&quot;hljs-string&quot;&gt;&quot;myTemplate&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;templates/&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;html&quot;&lt;/span&gt;, thymeleafTemplateEngine);
            springMvcRouterHandler.registVertxTemplateEngine(&lt;span class=&quot;hljs-string&quot;&gt;&quot;myTemplate2&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;templates/&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;ftl&quot;&lt;/span&gt;, freeMarkerTemplateEngine);
           
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;自定义拦截器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs java&quot; lang=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Interceptor&lt;/span&gt;(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;/api/*&quot;&lt;/span&gt;)
&lt;span class=&quot;hljs-meta&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;RouteInterceptorDemo&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;IRequestInterceptor&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;Order&lt;/span&gt; &lt;/span&gt;{


    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;pre&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(RoutingContext routingContext)&lt;/span&gt; &lt;/span&gt;{
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;pre1&quot;&lt;/span&gt;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;after&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(RoutingContext routingContext)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-comment&quot;&gt;/**
         * end 后 不执行
         */&lt;/span&gt;
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;after1&quot;&lt;/span&gt;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自定义json解析(默认内置)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs java&quot; lang=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@VertxMessageConverter&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;JsonMessageConverter&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MessageConverter&lt;/span&gt; &lt;/span&gt;{


    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;support&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Object source)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Handler&amp;lt;RoutingContext&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;convertTo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Object source)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ctx -&amp;gt; {
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (source &lt;span class=&quot;hljs-keyword&quot;&gt;instanceof&lt;/span&gt; JsonObject) {
                ResponseUtil.responseJson(ctx, HttpResponseStatus.OK.code(), ((JsonObject) source).encode());
                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;;
            }
            ResponseUtil.responseJson(ctx, HttpResponseStatus.OK.code(), JSONUtil.toJsonString(source));
        };
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/25/171b1c4a028b61c9~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;代码仓库地址:&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fdushitaoyuan%2Fvertx-web-springmvc&quot; title=&quot;https://github.com/dushitaoyuan/vertx-web-springmvc&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;github.com/dushitaoyua…&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方例子仓库:&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvert-x3%2Fvertx-examples&quot; title=&quot;https://github.com/vert-x3/vertx-examples&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;github.com/vert-x3/ver…&lt;/a&gt;&lt;/p&gt;
</description><link>https://juejin.cn/post/6844904137918775303</link><guid isPermaLink="false">https://juejin.cn/post/6844904137918775303</guid><pubDate>Sat, 25 Apr 2020 14:37:54 GMT</pubDate><author>都市桃源</author><category>后端</category><category>Java</category></item><item><title>react源码-事件监听</title><description>&lt;p&gt;本文以 React v16.5.2 为基础进行源码分析&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 react源码的 react-dom/src/events/ReactBrowserEventEmitter.js文件的开头，有这么一大段注释：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/14/16ab505e4e6299f3~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;事件委托是很常用的一种浏览器事件优化策略，于是 React就接管了这件事情，并且还贴心地消除了浏览器间的差异，赋予开发者跨浏览器的开发体验，主要是使用 EventPluginHub这个东西来负责调度事件的存储，合成事件并以对象池的方式实现创建和销毁，至于下面的结构图形，则是对事件机制的一个图形化描述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React事件使用了事件委托的机制，一般事件委托的作用都是为了减少页面的注册事件数量，减少内存开销，优化浏览器性能，React这么做也是有这么一个目的，除此之外，也是为了能够更好的管理事件，实际上，React中所有的事件最后都是被委托到了 document这个顶级DOM上&lt;/li&gt;
&lt;li&gt;既然所有的事件都被委托到了 document上，那么肯定有一套管理机制，所有的事件都是以一种先进先出的队列方式进行触发与回调&lt;/li&gt;
&lt;li&gt;既然都已经接管事件了，那么不对事件做些额外的事情未免有些浪费，于是 React中就存在了自己的 合成事件(SyntheticEvent)，合成事件由对应的 EventPlugin负责合成，不同类型的事件由不同的 plugin合成，例如 SimpleEvent Plugin、TapEvent Plugin等&lt;/li&gt;
&lt;li&gt;为了进一步提升事件的性能，使用了 EventPluginHub这个东西来负责合成事件对象的创建和销毁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#开始&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&amp;lt;button onClick={this.autoFocus}&amp;gt;点击聚焦&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是我们在React中绑定事件的常规写法。经由JSX解析，button会被当做组件挂载。而onClick这时候也只是一个普通的props。
ReactDOMComponent在进行组件加载(mountComponent)、更新(updateComponent)的时候，需要对props进行处理(_updateDOMProperties):&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;事件注册&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;ReactDOMComponent.Mixin = {
    mountComponent:&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;(){},
    _createOpenTagMarkupAndPutListeners:&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;(){},
    ....,
    
    // 方法中有指向上次属性值得lastProp,
    // nextProp是当前属性值，这里nextProp是我们绑定给组件的onclick事件处理函数。
  //  nextProp 不为空调用enqueuePutListener绑定事件,为空则注销事件绑定。
     _updateDOMProperties:&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(lastProps, nextProps, transaction){
         &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (propKey &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; lastProps) {}   //省略。。。
         &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (propKey &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; nextProps) {
         // 判断是否为事件属性
             &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (registrationNameModules.hasOwnProperty(propKey))  {
          enqueuePutListener(this, propKey, nextProp, transaction);
              }
         }
         
     }
}


//这里进行事件绑定

首先判断了 rootContainerElement是不是一个 document或者 Fragment(文档片段节点)

enqueuePutListener 这个方法只在浏览器环境下执行，传给listenTo参数分别是事件名称&lt;span class=&quot;hljs-string&quot;&gt;&#39;onclick&#39;&lt;/span&gt;和代理事件的绑
     定dom。如果是fragement 就是根节点（在reactDom.render指定的），不是的话就是document。listenTo
     用于绑定事件到 document ，下面交由事务处理的是回调函数的存储，便于调用。
     ReactBrowserEventEmitter 文件中的 listenTo 看做事件处理的源头。
     这里获取了当前组件（其实这时候就是button）所在的document
     
     
&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; enqueuePutListener(inst, registrationName, listener, transaction) {
    ...
    var containerInfo = inst._hostContainerInfo;
    var isDocumentFragment = containerInfo._node &amp;amp;&amp;amp; containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
    var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
    
     
     
      listenTo(registrationName, doc);
      
     ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;绑定的重点是这里的listenTo方法。看源码(ReactBrowerEventEmitter)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;//registrationName:需要绑定的事件
//当前component所属的document，即事件需要绑定的位置

    listenTo: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
       //获取当前document上已经绑定的事件
    var isListening = getListeningForDocument(mountAt);
    // 获取 registrationName（注册事件名称）的topLevelEvent（顶级事件类型）
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (var i = 0; i &amp;lt; dependencies.length; i++) {
      var dependency = dependencies[i];
      &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!(isListening.hasOwnProperty(dependency) &amp;amp;&amp;amp; isListening[dependency])) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (dependency === &lt;span class=&quot;hljs-string&quot;&gt;&#39;topWheel&#39;&lt;/span&gt;) {
           ...         
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (dependency === &lt;span class=&quot;hljs-string&quot;&gt;&#39;topScroll&#39;&lt;/span&gt;) {
               ...
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (dependency === &lt;span class=&quot;hljs-string&quot;&gt;&#39;topFocus&#39;&lt;/span&gt; || dependency === &lt;span class=&quot;hljs-string&quot;&gt;&#39;topBlur&#39;&lt;/span&gt;) {
                ...
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (topEventMapping.hasOwnProperty(dependency)) {
        // 获取 topLevelEvent 对应的浏览器原生事件
          //冒泡处理  
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }
        isListening[dependency] = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;
      }
    }
  },

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于同一个事件，例如click有两个事件 onClick（在冒泡阶段触发） onClickCapture（在捕获阶段触发）两个事件名，这个冒泡和捕获都是react事件模拟出来的。绑定到 document上面的事件基本上都是在冒泡阶段（对 whell, focus, scroll 有额外处理）,如下图 click 事件绑定执行的如下。&lt;/p&gt;
&lt;p&gt;最后处理（EventListener的listen和capture中）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;//eventType:事件类型,target: document对象，
//callback:是固定的，始终是ReactEventListener的dispatch方法
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (target.addEventListener) {
      target.addEventListener(eventType, callback, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);
      &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; {
        remove: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;remove&lt;/span&gt;&lt;/span&gt;() {
          target.removeEventListener(eventType, callback, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);
        }
      };
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所有事件绑定在document上&lt;/p&gt;
&lt;p&gt;所以事件触发的都是ReactEventListener的dispatch方法&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;回调储存&lt;/h2&gt;
&lt;p&gt;看到这边你可能疑惑，所有回调都执行的ReactEventListener的dispatch方法，那我写的回调干嘛去了。别急，接着看：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; enqueuePutListener(inst, registrationName, listener, transaction) {
  ...
  //注意这里！！！！！！！！！
  //这里获取了当前组件（其实这时候就是button）所在的document
  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
  //事件绑定
  listenTo(registrationName, doc);
 //这段代码表示将putListener放入回调序列，当组件挂载完成是会依次执行序列中的回调。putListener也是在那时候执行的。
 //不明白的可以看看本专栏中前两篇关于transaction和挂载机制的讲解
  transaction.getReactMountReady().enqueue(putListener, {
    inst: inst,
    registrationName: registrationName,
    listener: listener
  });
  //保存回调
  &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;putListener&lt;/span&gt;&lt;/span&gt;() {
    var listenerToPut = this;
    EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还是这段代码，事件绑定我们介绍过，主要是listenTo方法。
当绑定完成以后会执行putListener。该方法会在ReactReconcileTransaction事务的close阶段执行，具体由EventPluginHub来进行管理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;//
var listenerBank = {};
var getDictionaryKey = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (inst) {
//inst为组建的实例化对象
//_rootNodeID为组件的唯一标识
  &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;.&#39;&lt;/span&gt; + inst._rootNodeID;
}
var EventPluginHub = {
//inst为组建的实例化对象
//registrationName为事件名称
//listner为我们写的回调函数，也就是列子中的this.autoFocus
  putListener: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (inst, registrationName, listener) {
    ...
    var key = getDictionaryKey(inst);
    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[key] = listener;
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;EventPluginHub在每个项目中只实例化一次。也就是说，项目组所有事件的回调都会储存在唯一的listenerBank中。&lt;/p&gt;
&lt;p&gt;是不是有点晕，放上流程图，仔细回忆一下&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/14/16ab5481db9ffc4c~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;事件触发&lt;/h2&gt;
&lt;p&gt;注册事件时我们说过，所有的事件都是绑定在Document上。回调统一是ReactEventListener的dispatch方法。
由于冒泡机制，无论我们点击哪个DOM，最后都是由document响应（因为其他DOM根本没有事件监听）。也即是说都会触发dispatch&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;dispatchEvent: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(topLevelType, nativeEvent) {
    //实际触发事件的DOM对象
    var nativeEventTarget = getEventTarget(nativeEvent);
    //nativeEventTarget对应的virtual DOM
    var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(
      nativeEventTarget,
    );
    ...
    //创建bookKeeping实例，为handleTopLevelImpl回调函数传递事件名和原生事件对象
    //其实就是把三个参数封装成一个对象
    var bookKeeping = getTopLevelCallbackBookKeeping(
      topLevelType,
      nativeEvent,
      targetInst,
    );

    try {
    //这里开启一个transactIon，perform中执行了
    //handleTopLevelImpl(bookKeeping)
      ReactGenericBatching.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      releaseTopLevelCallbackBookKeeping(bookKeeping);
    }
  },
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; handleTopLevelImpl(bookKeeping) {
//触发事件的真实DOM
  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
  //nativeEventTarget对应的ReactElement
  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
  //bookKeeping.ancestors保存的是组件。
  var ancestor = targetInst;
  &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt; {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor &amp;amp;&amp;amp; findParent(ancestor);
  } &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (ancestor);

  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (var i = 0; i &amp;lt; bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    //具体处理逻辑
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;//这就是核心的处理了
handleTopLevel: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
//首先封装event事件
    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
    //发送包装好的event
    runEventQueueInBatch(events);
  }
&lt;/code&gt;&lt;/pre&gt;&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;事件封装&lt;/h2&gt;
&lt;p&gt;首先是EventPluginHub的extractEvents&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;extractEvents: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (var i = 0; i &amp;lt; plugins.length; i++) {
      // Not every plugin &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (possiblePlugin) {
      //主要看这边
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        ......
      }
    }
    &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; events;
  },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接着看SimpleEventPlugin的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;extractEvents: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    ......
    //这里是对事件的封装，但是不是我们关注的重点
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    //重点看这边
    EventPropagators.accumulateTwoPhaseDispatches(event);
    &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; event;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来是方法中的各种引用，跳啊跳，转啊转，我们来到了ReactDOMTraversal中的traverseTwoPhase方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;//inst是触发事件的target的ReactElement
//fn：EventPropagator的accumulateDirectionalDispatches
//arg: 就是之前部分封装好的event（之所以说是部分，是因为现在也是在处理Event，这边处理完才是封装完成）
&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; traverseTwoPhase(inst, fn, arg) {
  var path = [];
  &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (inst) {
   //注意path，这里以ReactElement的形式冒泡着，
   //把触发事件的父节点依次保存下来
    path.push(inst);
    //获取父节点
    inst = inst._hostParent;
  }
  var i;
  //捕捉，依次处理
  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (i = path.length; i-- &amp;gt; 0;) {
    fn(path[i], &lt;span class=&quot;hljs-string&quot;&gt;&#39;captured&#39;&lt;/span&gt;, arg);
  }
  //冒泡，依次处理
  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (i = 0; i &amp;lt; path.length; i++) {
    fn(path[i], &lt;span class=&quot;hljs-string&quot;&gt;&#39;bubbled&#39;&lt;/span&gt;, arg);
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;//判断父组件是否保存了这一类事件
&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; accumulateDirectionalDispatches(inst, phase, event) {
//获取到回调
  var listener = listenerAtPhase(inst, event, phase);
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (listener) {
  //如果有回调，就把包含该类型事件监听的DOM与对应的回调保存进Event。
  //accumulateInto可以理解成_.assign
  //记住这两个属性，很重要。
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;listenerAtPhase里面执行的是EventPluginHub的getListener函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;getListener: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (inst, registrationName) {
    //还记得之前保存回调的listenerBank吧？
    var bankForRegistrationName = listenerBank[registrationName];
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
      &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; null;
    }
    //获取inst的_rootNodeId
    var key = getDictionaryKey(inst);
    //获取对应的回调
    &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; bankForRegistrationName &amp;amp;&amp;amp; bankForRegistrationName[key];
  },
&lt;/code&gt;&lt;/pre&gt;&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;事件分发&lt;/h2&gt;
&lt;p&gt;runEventQueueInBatch主要进行了两步操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; runEventQueueInBatch(events) {
//将event事件加入processEventQueue序列
  EventPluginHub.enqueueEvents(events);
  //前一步保存好的processEventQueue依次执行
//executeDispatchesAndRelease
  EventPluginHub.processEventQueue(&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);
}

  processEventQueue: &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (simulated) {
    var processingEventQueue = eventQueue;
    eventQueue = null;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (simulated) {
      &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;EachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
    //重点看这里
    //&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;EachAccumulated可以看成&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;Each的封装
    //那么这里就是processingEventQueue保存的event依次执行executeDispatchesAndReleaseTopLevel（event）
      &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;EachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
  },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;executeDispatchesAndReleaseTopLevel（event）又是各种函数包装，最后干活的是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; executeDispatchesInOrder(event, simulated) {
  //对应的回调函数数组
  var dispatchListeners = event._dispatchListeners;
  //有eventType属性的ReactElement数组
  var dispatchInstances = event._dispatchInstances;
  
  ......
  
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (Array.isArray(dispatchListeners)) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (var i = 0; i &amp;lt; dispatchListeners.length; i++) {
      &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (event.isPropagationStopped()) {
        &lt;span class=&quot;hljs-built_in&quot;&gt;break&lt;/span&gt;;
      }
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;OK，这里总算出现了老熟人，在封装nativeEvent时我们保存在event里的两个属性，dispatchListeners与dispatchInstances，在这里起作用。
代码很简单，如果有处理这个事件的回调函数，就一次进行处理。细节我们稍后讨论，先看看这里是怎么处理的吧&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; executeDispatch(event, simulated, listener, inst) {
//&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;是事件类型
  var &lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt; = event.type || &lt;span class=&quot;hljs-string&quot;&gt;&#39;unknown-event&#39;&lt;/span&gt;;
  //这是触发事件的真实DOM，也就是列子中的button
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener, event);
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
  //看这里看这里
    ReactErrorUtils.invokeGuardedCallback(&lt;span class=&quot;hljs-built_in&quot;&gt;type&lt;/span&gt;, listener, event);
  }
  event.currentTarget = null;
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;终于来到最后了,代码位于ReactErrorUtil中
（为了帮助开发，React通过模拟真正的浏览器事件来获得更好的devtools集成。这段代码在开发模式下运行）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;    //创造一个临时DOM
    var fakeNode = document.createElement(&lt;span class=&quot;hljs-string&quot;&gt;&#39;react&#39;&lt;/span&gt;);
    ReactErrorUtils.invokeGuardedCallback = &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (name, func, a) {
    //绑定回调函数的上下文
      var boundFunc = func.bind(null, a);
      //定义事件类型
      var evtType = &lt;span class=&quot;hljs-string&quot;&gt;&#39;react-&#39;&lt;/span&gt; + name;
      //绑定事件
      fakeNode.addEventListener(evtType, boundFunc, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);
      //生成原生事件
      var evt = document.createEvent(&lt;span class=&quot;hljs-string&quot;&gt;&#39;Event&#39;&lt;/span&gt;);
      //将原生事件处理成我们需要的类型
      evt.initEvent(evtType, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);
      //发布事件---这里会执行回调
      fakeNode.dispatchEvent(evt);
      //移出事件监听
      fakeNode.removeEventListener(evtType, boundFunc, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);
    };

&lt;/code&gt;&lt;/pre&gt;&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;流程图&lt;/h2&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/14/16ab557e7313cf2e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
</description><link>https://juejin.cn/post/6844903843545743374</link><guid isPermaLink="false">https://juejin.cn/post/6844903843545743374</guid><pubDate>Tue, 14 May 2019 07:57:10 GMT</pubDate><author>南果梨</author><category>前端</category><category>React.js</category></item><item><title>一步一步，统一项目中的编码规范（vue, vscode, vetur, prettier, eslint）</title><description>&lt;p&gt;团队开发中，多人开发同一个项目，由于个人编码习惯不同，一个项目中最终的代码风格可能差别很大，所以需要通过工具进行约束来保证代码风格的统一。同时也希望通过工具尽可能的减少低级错误出现，并且能帮助修正，所以有了各种各样的 lint 和 formatter。&lt;/p&gt;
&lt;p&gt;本篇的目标是使用 vscode 编辑器，使用 prettier 插件，结合使用 eslint 对代码进行校验和修正，并使用 eslint-config-airbnb-base 规则来实现代码风格的统一。&lt;/p&gt;
&lt;p&gt;一般情况下，我们小公司、小 team 可能没有能力和精力来制订一套详尽规则，那么采用大厂已经制订好的规则就是很自然的选择（同时也必要争论你的好还是我的好了，人家大厂都这么干了，我们就按人家来吧！:)）&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;名词解释&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;vscode&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;一个文本编辑器 &lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fcode.visualstudio.com%2F&quot; title=&quot;https://code.visualstudio.com/&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;code.visualstudio.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;prettier&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;vscode 插件，官方的说明是：Opinionated Code Formatter&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;eslint&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;代码校验和修复工具，官方说明是：The pluggable linting utility for JavaScript and JSX&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;eslint-config-airbnb-base&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;一组预先定义好的 eslint 规则，官方说明是：This package provides Airbnb&#39;s base JS .eslintrc (without React plugins) as an extensible shared config.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面一步一步，通过 vscode 的格式化的使用，到和 prettier 的结合，eslint 使用， prettier 结合 eslint 对 js 和 vue 文件校验，完成对项目代码校验和 fix，力求能以最简洁的方式把问题说清楚。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;vscode 开箱即用的 code formatter 功能&lt;/h2&gt;
&lt;p&gt;vscode 提供开箱即用的代码样式化功能（没有 css 格式化功能），下面在当前文件夹下创建测试文件：&lt;code&gt;./src/demo.html&lt;/code&gt;、&lt;code&gt;./src/fun.js&lt;/code&gt;、&lt;code&gt;./src/style.css&lt;/code&gt;，格式化代码的快捷键是(win)：alt + shift + f&lt;/p&gt;
&lt;p&gt;HTML 格式化前：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs html&quot; lang=&quot;html&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;lang&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;en&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;charset&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;http-equiv&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;X-UA-Compatible&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;ie=edge&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;Demo page&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;This is a test page&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;Page content&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;格式化后：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs html&quot; lang=&quot;html&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;lang&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;en&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;charset&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;http-equiv&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;X-UA-Compatible&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;ie=edge&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;Demo page&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;This is a test page&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;Page content&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JS 格式化前：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getUserInfo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) &lt;/span&gt;{&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; HelloStr = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello, your name is: &quot;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; HelloStr + name
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;格式化后：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getUserInfo&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; HelloStr = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello, your name is: &quot;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; HelloStr + name
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CSS:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;CSS 文件的格式化&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/24/16a4d7d10616b385~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;可以看到，CSS 文件默认情况下是不能被格式化的，这个时间轮到 prettier 登场~&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;用 prettier 对代码进行格式化&lt;/h2&gt;
&lt;p&gt;prettier 的官方解释是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An opinionated code formatter&lt;/li&gt;
&lt;li&gt;Supports many languages&lt;/li&gt;
&lt;li&gt;Integrates with most editors&lt;/li&gt;
&lt;li&gt;Has few options&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它能和多种编辑器结合，对多种语言进行 format，所以 css 也不是话下。&lt;/p&gt;
&lt;p&gt;由于 vscode 默认有格式化的功能，安装了 prettier 插件后，prettier 也有格式化的功能以会造成冲突（对于html, js），这里编辑器会提示你，可以进行配置。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;Prettier 格式化 html&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/24/16a4e2b56f9e97ab~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，vscode 和 prettier 会有很多默认配置，可以通过 &lt;code&gt;CTRL + ,&lt;/code&gt; 快捷键进入配置界面进行管理，所有修改后的结果会保存在 &lt;code&gt;settings.json&lt;/code&gt; 文件里。&lt;/p&gt;
&lt;p&gt;刚刚由于 vscode 默认的格式化程序和 prettier 冲突，经过选择后形成配置文件并写入 &lt;code&gt;settings.json&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs json&quot; lang=&quot;json&quot;&gt;{
    &lt;span class=&quot;hljs-attr&quot;&gt;&quot;[html]&quot;&lt;/span&gt;: {
        &lt;span class=&quot;hljs-attr&quot;&gt;&quot;editor.defaultFormatter&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;esbenp.prettier-vscode&quot;&lt;/span&gt;
    },
    &lt;span class=&quot;hljs-attr&quot;&gt;&quot;[javascript]&quot;&lt;/span&gt;: {
        &lt;span class=&quot;hljs-attr&quot;&gt;&quot;editor.defaultFormatter&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;esbenp.prettier-vscode&quot;&lt;/span&gt;
    },
    &lt;span class=&quot;hljs-attr&quot;&gt;&quot;[jsonc]&quot;&lt;/span&gt;: {
        &lt;span class=&quot;hljs-attr&quot;&gt;&quot;editor.defaultFormatter&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;esbenp.prettier-vscode&quot;&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面是指针不同类型的文件，分别指定 formatter，当然你也可以一次性指定&lt;strong&gt;所有类型&lt;/strong&gt;文件的 formatter，修改后的配置文件 &lt;code&gt;settings.json&lt;/code&gt; 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs json&quot; lang=&quot;json&quot;&gt;{
    &lt;span class=&quot;hljs-attr&quot;&gt;&quot;editor.defaultFormatter&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;esbenp.prettier-vscode&quot;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;经过如上配置， &lt;code&gt;css&lt;/code&gt; 及其他类型的文件，拥有了通过 prettier 进行格式化的能力。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;用 eslint 对 javascript 代码进行校验&lt;/h2&gt;
&lt;p&gt;经过如上配置，可以对代码进行格式化了，但是如果要想去代码风格进行校验和修复，就要用到 eslint 了，下面分两步将 eslint 功能集成了项目中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在项目内安装 eslint 及相关的包&lt;/li&gt;
&lt;li&gt;给 vscode 安装 eslint 插件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面分别来说&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;在项目内安装 eslint 及相关的包&lt;/h3&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;安装 eslint&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/24/16a4e2b56fc91f2a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;经过上面的操作，将 eslint 及相关的包安装到项目里了 &lt;code&gt;package.json&lt;/code&gt;如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs json&quot; lang=&quot;json&quot;&gt;{
  ...
  &quot;dependencies&quot;: {
    &quot;eslint-plugin-vue&quot;: &quot;^5.2.2&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;eslint&quot;: &quot;^5.16.0&quot;
  }
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;项目目录下多了一个 eslint 的配置文件 &lt;code&gt;.eslintrc.js&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;module&lt;/span&gt;.exports = {
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;env&quot;&lt;/span&gt;: {
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;browser&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;es6&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;
    },
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;extends&quot;&lt;/span&gt;: [
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;eslint:recommended&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;plugin:vue/essential&quot;&lt;/span&gt;
    ],
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;globals&quot;&lt;/span&gt;: {
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;Atomics&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;readonly&quot;&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;SharedArrayBuffer&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;readonly&quot;&lt;/span&gt;
    },
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;parserOptions&quot;&lt;/span&gt;: {
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;ecmaVersion&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2018&lt;/span&gt;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;sourceType&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;module&quot;&lt;/span&gt;
    },
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;plugins&quot;&lt;/span&gt;: [
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;vue&quot;&lt;/span&gt;
    ],
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;rules&quot;&lt;/span&gt;: {
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个配置文件的内容，是通过 &lt;code&gt;npx eslint --init&lt;/code&gt; 自动生成的，当然你也可以手动配置，所有的选项这里都有中文说明：&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Feslint.cn%2Fdocs%2Fuser-guide%2Fconfiguring&quot; title=&quot;http://eslint.cn/docs/user-guide/configuring&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;eslint.cn/docs/user-g…&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来就可以手动执行校验了：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;eslint lint&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/24/16a4e2b56fa87b6a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;在执行的时候可能会有包未安装的提示&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Failed to load plugin vue: Cannot find module &#39;eslint-plugin-vue&#39;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;手动安装一下就好了，从执行结果来看，funs.js 文件有一个错误提示，说明校验程序已经能正常跑进来了。&lt;/p&gt;
&lt;p&gt;现在采用的规则是 &lt;code&gt;eslint:recommended&lt;/code&gt; ，我们的目标是采用 &#39;eslint-config-airbnb-base&#39;，所以再安装相应的包：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;npm i -D eslint-config-airbnb-base eslint-plugin-import
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后对 &lt;code&gt;.eslintrc.js&lt;/code&gt; 进行配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;module&lt;/span&gt;.exports = {
  &lt;span class=&quot;hljs-attr&quot;&gt;env&lt;/span&gt;: {
    &lt;span class=&quot;hljs-attr&quot;&gt;browser&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,
    &lt;span class=&quot;hljs-attr&quot;&gt;es6&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,
  },
  &lt;span class=&quot;hljs-attr&quot;&gt;extends&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&#39;airbnb-base&#39;&lt;/span&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;globals&lt;/span&gt;: {
    &lt;span class=&quot;hljs-attr&quot;&gt;Atomics&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&#39;readonly&#39;&lt;/span&gt;,
    &lt;span class=&quot;hljs-attr&quot;&gt;SharedArrayBuffer&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&#39;readonly&#39;&lt;/span&gt;,
  },
  &lt;span class=&quot;hljs-attr&quot;&gt;parserOptions&lt;/span&gt;: {
    &lt;span class=&quot;hljs-attr&quot;&gt;ecmaVersion&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2018&lt;/span&gt;,
    &lt;span class=&quot;hljs-attr&quot;&gt;sourceType&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&#39;module&#39;&lt;/span&gt;,
  },
  &lt;span class=&quot;hljs-attr&quot;&gt;plugins&lt;/span&gt;: [
    &lt;span class=&quot;hljs-string&quot;&gt;&#39;vue&#39;&lt;/span&gt;,
  ],
  &lt;span class=&quot;hljs-attr&quot;&gt;rules&lt;/span&gt;: {
    &lt;span class=&quot;hljs-string&quot;&gt;&#39;linebreak-style&#39;&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&quot;error&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;windows&quot;&lt;/span&gt;]
  },
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再进行校验：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;D:\works\secoo\&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;\code-formatter&amp;gt; npx eslint .\src\funs.js

D:\works\secoo\&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;\code-formatter\src\funs.js
  1:10  error  &lt;span class=&quot;hljs-string&quot;&gt;&#39;getUserInfo&#39;&lt;/span&gt; is defined but never used              no-unused-vars
  2:7   error  &lt;span class=&quot;hljs-string&quot;&gt;&#39;HelloStr&#39;&lt;/span&gt; is never reassigned. Use &lt;span class=&quot;hljs-string&quot;&gt;&#39;const&#39;&lt;/span&gt; instead  prefer-const
  3:7   error  &lt;span class=&quot;hljs-string&quot;&gt;&#39;age&#39;&lt;/span&gt; is assigned a value but never used             no-unused-vars
  3:7   error  &lt;span class=&quot;hljs-string&quot;&gt;&#39;age&#39;&lt;/span&gt; is never reassigned. Use &lt;span class=&quot;hljs-string&quot;&gt;&#39;const&#39;&lt;/span&gt; instead       prefer-const
  3:15  error  Missing semicolon                                    semi

✖ 5 problems (5 errors, 0 warnings)
  3 errors and 0 warnings potentially fixable with the `--fix` option.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到明显比之前的错误要多，Aribnb 的规则相对较为严格，可以规避很多低级错误。&lt;/p&gt;
&lt;p&gt;这里要重点说一下的是，我们在 &lt;code&gt;.eslintrc.js&lt;/code&gt; 的 &lt;code&gt;rules&lt;/code&gt; 里加了 &lt;code&gt;&#39;linebreak-style&#39;: [&quot;error&quot;, &quot;windows&quot;]&lt;/code&gt;，是由于不同系统间对换行的处理不同导致的，加这个规则来处理这个问题。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;给 vscode 安装 eslint 插件&lt;/h3&gt;
&lt;p&gt;走到这里我们已经可以校验 js 文件了，通过校验也发现了很多问题，但在 vscode里并没有错误提示，这就用到了 &lt;strong&gt;&lt;code&gt;vscode&lt;/code&gt;&lt;/strong&gt; 的另一个插件 &lt;code&gt;eslint&lt;/code&gt;，安装完插件以后，在 vscode 里可以看到错误提示了：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;eslint lint&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/24/16a4e2b56fb1182b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;走到这里，我们离成功已经很近啦！&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-6&quot;&gt;让 pretter 根据 eslint 校验结果，对代码进行样式化&lt;/h2&gt;
&lt;p&gt;到目前为上，已经可以对 js 文件进行校验，甚至可以对 js 文件按规则进行修复了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;D:\works\secoo\&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;\code-formatter&amp;gt; npx eslint --fix .\src\funs.js

D:\works\secoo\&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;\code-formatter\src\funs.js
  1:10  error  &lt;span class=&quot;hljs-string&quot;&gt;&#39;getUserInfo&#39;&lt;/span&gt; is defined but never used   no-unused-vars
  3:9   error  &lt;span class=&quot;hljs-string&quot;&gt;&#39;age&#39;&lt;/span&gt; is assigned a value but never used  no-unused-vars

✖ 2 problems (2 errors, 0 warnings)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是如果你用 vscode（如前述，vscode 使用 prettier） 进行修复，发现并没有应用 Airbnb 的规则，这里需要手动配置一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CTRL + ,&lt;/code&gt; 打开配置界面&lt;/li&gt;
&lt;li&gt;扩展 -&amp;gt; Prettier 里打到 Eslint Integration 并勾选
得到 vscode 的配置文件 &lt;code&gt;settings.json&lt;/code&gt; 如下&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;hljs json&quot; lang=&quot;json&quot;&gt;{
    &lt;span class=&quot;hljs-attr&quot;&gt;&quot;editor.defaultFormatter&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;esbenp.prettier-vscode&quot;&lt;/span&gt;,
    &lt;span class=&quot;hljs-attr&quot;&gt;&quot;prettier.eslintIntegration&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时再对 js 文件进行格式化，就能按照指定的规则执行了，具体操作如下：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;prettier format follow eslint&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/24/16a4ee945b11b14b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-7&quot;&gt;校验并且格式化 vue 代码&lt;/h2&gt;
&lt;p&gt;这部分是最麻烦的，很多同学都在这里翻车......&lt;/p&gt;
&lt;p&gt;首先，要想 &lt;code&gt;vscode&lt;/code&gt; 认识 &lt;code&gt;vue&lt;/code&gt; 文件，需要安装插件 &lt;code&gt;vetur&lt;/code&gt;，基本上安装好此插件后就可以开心的撸 vue 代码了，vetur 的默认配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs json&quot; lang=&quot;json&quot;&gt;{
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;vetur.format.defaultFormatter.html&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;prettyhtml&quot;&lt;/span&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;vetur.format.defaultFormatter.css&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;prettier&quot;&lt;/span&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;vetur.format.defaultFormatter.postcss&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;prettier&quot;&lt;/span&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;vetur.format.defaultFormatter.scss&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;prettier&quot;&lt;/span&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;vetur.format.defaultFormatter.less&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;prettier&quot;&lt;/span&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;vetur.format.defaultFormatter.stylus&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;stylus-supremacy&quot;&lt;/span&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;vetur.format.defaultFormatter.js&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;prettier&quot;&lt;/span&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;vetur.format.defaultFormatter.ts&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;prettier&quot;&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上是默认配置，看着很开以的以为可以按着如下方式对代码进行格式化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;发出格式化命令
    |
    | next
    |
vetur 收到命令 将格式化任务转交给 prettier
    |
    | next
    |
prettier 收到命令 将格式化任务转交给 eslint
    |
    | next
    |
eslint 收到命令，将代码格式化
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看似美好的结局被现实打破，当我们对 vue 文件进行格式化的时候，发它参考的规则是 prettier 规则，而非 eslint 规则。&lt;/p&gt;
&lt;p&gt;如果想按着上述规则对 vue 进行格式化需要做两个事：
&lt;code&gt;settings.json&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 vetur 中 js 的 formatter 设置为 prettier-eslint&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;hljs json&quot; lang=&quot;json&quot;&gt;{
  ...
  &quot;vetur.format.defaultFormatter.js&quot;: &quot;prettier-eslint&quot;
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;安装 prettier-eslint 包&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;npm i -D prettier-eslint
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于这个问题，prettier-eslint &lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fprettier%2Fprettier-eslint&quot; title=&quot;https://github.com/prettier/prettier-eslint&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;官网&lt;/a&gt;上说的很清楚：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This formats your code via prettier, and then passes the result of that to eslint --fix. This way you can get the benefits of prettier&#39;s superior formatting capabilities, but also benefit from the configuration capabilities of eslint.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但就是这么一个问题，我在网上看把无数的同学绕进去了，确实直线理解的话会有两个坑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;prettier 不是已经按着 eslint 来格式化 js 了吗，vetur 指给 prettier 按说没问题啊！现实是需要传递给 &lt;code&gt;prettier-eslint&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;很多同学跨过了第一道坎，但不曾想 &lt;code&gt;prettier-eslint&lt;/code&gt; 需要手动安装一个包啊！&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以导致在最后一步走不下去了。&lt;/p&gt;
&lt;p&gt;至此配置基本已经完成，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;eslint-vue-fix&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/24/16a4f08c6f302185~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-8&quot;&gt;最后总结&lt;/h2&gt;
&lt;p&gt;最后总结一下，总共需要做那些工作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装 vscode 插件 &lt;code&gt;eslint&lt;/code&gt;、 &lt;code&gt;prettier&lt;/code&gt;、 &lt;code&gt;vetur&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置 eslint 规则&lt;/li&gt;
&lt;li&gt;配置 prettier ，使其按着 eslint 工作&lt;/li&gt;
&lt;li&gt;配置 vetur&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终的配置文件如下：
settings.json&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs json&quot; lang=&quot;json&quot;&gt;{
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;extensions.autoUpdate&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;eslint.validate&quot;&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&quot;javascript&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;javascriptreact&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;vue&quot;&lt;/span&gt;],
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;prettier.eslintIntegration&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;vetur.format.defaultFormatterOptions&quot;&lt;/span&gt;: {
    &lt;span class=&quot;hljs-attr&quot;&gt;&quot;prettier&quot;&lt;/span&gt;: {
      &lt;span class=&quot;hljs-attr&quot;&gt;&quot;eslintIntegration&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;
    }
  },
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;vetur.format.defaultFormatter.js&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;prettier-eslint&quot;&lt;/span&gt;,
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;[javascript]&quot;&lt;/span&gt;: {
    &lt;span class=&quot;hljs-attr&quot;&gt;&quot;editor.defaultFormatter&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;esbenp.prettier-vscode&quot;&lt;/span&gt;
  },
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;[jsonc]&quot;&lt;/span&gt;: {
    &lt;span class=&quot;hljs-attr&quot;&gt;&quot;editor.defaultFormatter&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;esbenp.prettier-vscode&quot;&lt;/span&gt;
  },
  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;vetur.format.defaultFormatter.html&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;prettier&quot;&lt;/span&gt;
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;.eslintrc.js&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;module&lt;/span&gt;.exports = {
  &lt;span class=&quot;hljs-attr&quot;&gt;env&lt;/span&gt;: {
    &lt;span class=&quot;hljs-attr&quot;&gt;browser&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,
    &lt;span class=&quot;hljs-attr&quot;&gt;es6&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;
  },
  &lt;span class=&quot;hljs-attr&quot;&gt;extends&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&#39;airbnb-base&#39;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&#39;plugin:vue/recommended&#39;&lt;/span&gt;],
  &lt;span class=&quot;hljs-attr&quot;&gt;globals&lt;/span&gt;: {
    &lt;span class=&quot;hljs-attr&quot;&gt;Atomics&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&#39;readonly&#39;&lt;/span&gt;,
    &lt;span class=&quot;hljs-attr&quot;&gt;SharedArrayBuffer&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&#39;readonly&#39;&lt;/span&gt;
  },
  &lt;span class=&quot;hljs-attr&quot;&gt;parserOptions&lt;/span&gt;: {
    &lt;span class=&quot;hljs-attr&quot;&gt;ecmaVersion&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2018&lt;/span&gt;,
    &lt;span class=&quot;hljs-attr&quot;&gt;sourceType&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&#39;module&#39;&lt;/span&gt;
  },
  &lt;span class=&quot;hljs-attr&quot;&gt;plugins&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&#39;vue&#39;&lt;/span&gt;],
  &lt;span class=&quot;hljs-attr&quot;&gt;rules&lt;/span&gt;: {
    &lt;span class=&quot;hljs-string&quot;&gt;&#39;linebreak-style&#39;&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&#39;error&#39;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&#39;windows&#39;&lt;/span&gt;],
    &lt;span class=&quot;hljs-string&quot;&gt;&#39;comma-dangle&#39;&lt;/span&gt;: [&lt;span class=&quot;hljs-string&quot;&gt;&#39;error&#39;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&#39;never&#39;&lt;/span&gt;], &lt;span class=&quot;hljs-comment&quot;&gt;// 修正 eslint-plugin-vue 带来的问题&lt;/span&gt;
  }
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;源代码在 &lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwfzong%2Fvue-vscode-format&quot; title=&quot;https://github.com/wfzong/vue-vscode-format&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fvuejs.github.io%2Fvetur%2Fformatting.html&quot; title=&quot;https://vuejs.github.io/vetur/formatting.html&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;Vetur 官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fprettier%2Fprettier-eslint&quot; title=&quot;https://github.com/prettier/prettier-eslint&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;prettier-eslint github rep&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Feslint.cn%2Fdocs%2Fuser-guide%2Fconfiguring&quot; title=&quot;http://eslint.cn/docs/user-guide/configuring&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;eslint configuring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Feslint.cn%2Fdocs%2Frules%2F&quot; title=&quot;http://eslint.cn/docs/rules/&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;eslint rules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgit-scm.com%2Fdocs%2Fgitignore&quot; title=&quot;https://git-scm.com/docs/gitignore&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;gitignore&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fprettier.io%2Fdocs%2Fen%2Fintegrating-with-linters.html&quot; title=&quot;https://prettier.io/docs/en/integrating-with-linters.html&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;Prettier Integrating with Linters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Fstariveer.coding.me%2Ffe-doc%2F&quot; title=&quot;http://stariveer.coding.me/fe-doc/&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;He Xing 的 blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fblog.jongallant.com%2F2019%2F02%2Fvuejs-vetur-vscode-format-eslint-issues%2F&quot; title=&quot;https://blog.jongallant.com/2019/02/vuejs-vetur-vscode-format-eslint-issues/&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;How I Resolved Vue.js, VSCode, Vetur, Prettyhtml, and Prettier Formatting and ES Lint Issues&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbeautify-web%2Fjs-beautify&quot; title=&quot;https://github.com/beautify-web/js-beautify&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;js-beautify github rep 及说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Tips&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;由于 vetur 最新版本出现 bug，需要回退到  0.18.1 版本，具体信息见：&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvetur%2Fissues%2F1220&quot; title=&quot;https://github.com/vuejs/vetur/issues/1220&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;github.com/vuejs/vetur…&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><link>https://juejin.cn/post/6844903829956214791</link><guid isPermaLink="false">https://juejin.cn/post/6844903829956214791</guid><pubDate>Wed, 24 Apr 2019 11:09:42 GMT</pubDate><author>wfz</author><category>前端</category><category>代码规范</category></item><item><title>支撑日活百万用户的高并发系统，应该如何设计其数据库架构？【石杉的架构笔记】</title><description>&lt;p&gt;欢迎关注微信公众号：石杉的架构笔记（id：shishan100）&lt;/p&gt;
&lt;h1 data-id=&quot;heading-0&quot;&gt;目录：&lt;/h1&gt;
&lt;p&gt;1.用一个创业公司的发展作为背景引入
2.用多台服务器来分库支撑高并发读写
3.大量分表来保证海量数据下查询性能
4.读写分离来支撑按需扩容及性能提升
5.高并发下的数据库架构设计总结&lt;/p&gt;
&lt;p&gt;“ 这篇文章，我们来聊一下对于一个支撑日活百万用户的高并系统，他的数据库架构应该如何设计？&lt;/p&gt;
&lt;p&gt;看到这个题目，很多人第一反应就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分库分表啊！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是实际上，数据库层面的分库分表到底是用来干什么的，他的不同的作用如何应对不同的场景，我觉得很多同学可能都没搞清楚。&lt;/p&gt;
&lt;h1 data-id=&quot;heading-1&quot;&gt;（1）用一个创业公司的发展作为背景引入&lt;/h1&gt;
&lt;p&gt;假如我们现在是一个小创业公司，注册用户就20万，每天活跃用户就1万，每天单表数据量就1000，然后高峰期每秒钟并发请求最多就10。&lt;/p&gt;
&lt;p&gt;天哪！就这种系统，随便找一个有几年工作经验的高级工程师，然后带几个年轻工程师，随便干干都可以做出来。&lt;/p&gt;
&lt;p&gt;因为这样的系统，实际上主要就是在前期快速的进行业务功能的开发，搞一个单块系统部署在一台服务器上，然后连接一个数据库就可以了。&lt;/p&gt;
&lt;p&gt;接着大家就是不停的在一个工程里填充进去各种业务代码，尽快把公司的业务支撑起来，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/19/169017ef22738959~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp&quot; alt=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;结果呢，没想到我们运气这么好，碰上个优秀的CEO带着我们走上了康庄大道！&lt;/p&gt;
&lt;p&gt;公司业务发展迅猛，过了几个月，注册用户数达到了2000万！每天活跃用户数100万！每天单表新增数据量达到50万条！高峰期每秒请求量达到1万！&lt;/p&gt;
&lt;p&gt;同时公司还顺带着融资了两轮，估值达到了惊人的几亿美金！一只朝气蓬勃的幼年独角兽的节奏！&lt;/p&gt;
&lt;p&gt;好吧，现在大家感觉压力已经有点大了，为啥呢？&lt;/p&gt;
&lt;p&gt;因为每天单表新增50万条数据，一个月就多1500万条数据，一年下来单表会达到上亿条数据。&lt;/p&gt;
&lt;p&gt;经过一段时间的运行，现在咱们单表已经两三千万条数据了，勉强还能支撑着。&lt;/p&gt;
&lt;p&gt;但是，眼见着系统访问数据库的性能怎么越来越差呢，单表数据量越来越大，拖垮了一些复杂查询SQL的性能啊！&lt;/p&gt;
&lt;p&gt;然后高峰期请求现在是每秒1万，咱们的系统在线上部署了20台机器，平均每台机器每秒支撑500请求，这个还能抗住，没啥大问题。&lt;/p&gt;
&lt;p&gt;但是数据库层面呢？&lt;/p&gt;
&lt;p&gt;如果说此时你还是一台数据库服务器在支撑每秒上万的请求，负责任的告诉你，每次高峰期会出现下述问题：&lt;/p&gt;
&lt;p&gt;你的数据库服务器的磁盘IO、网络带宽、CPU负载、内存消耗，都会达到非常高的情况，数据库所在服务器的整体负载会非常重，甚至都快不堪重负了&lt;/p&gt;
&lt;p&gt;高峰期时，本来你单表数据量就很大，SQL性能就不太好，这时加上你的数据库服务器负载太高导致性能下降，就会发现你的SQL性能更差了&lt;/p&gt;
&lt;p&gt;最明显的一个感觉，就是你的系统在高峰期各个功能都运行的很慢，用户体验很差，点一个按钮可能要几十秒才出来结果&lt;/p&gt;
&lt;p&gt;如果你运气不太好，数据库服务器的配置不是特别的高的话，弄不好你还会经历数据库宕机的情况，因为负载太高对数据库压力太大了&lt;/p&gt;
&lt;h1 data-id=&quot;heading-2&quot;&gt;（2）多台服务器分库支撑高并发读写&lt;/h1&gt;
&lt;p&gt;首先我们先考虑第一个问题，数据库每秒上万的并发请求应该如何来支撑呢？&lt;/p&gt;
&lt;p&gt;要搞清楚这个问题，先得明白一般数据库部署在什么配置的服务器上。&lt;/p&gt;
&lt;p&gt;通常来说，假如你用普通配置的服务器来部署数据库，那也起码是16核32G的机器配置。&lt;/p&gt;
&lt;p&gt;这种非常普通的机器配置部署的数据库，一般线上的经验是：不要让其每秒请求支撑超过2000，一般控制在2000左右。&lt;/p&gt;
&lt;p&gt;控制在这个程度，一般数据库负载相对合理，不会带来太大的压力，没有太大的宕机风险。&lt;/p&gt;
&lt;p&gt;所以首先第一步，就是在上万并发请求的场景下，部署个5台服务器，每台服务器上都部署一个数据库实例。&lt;/p&gt;
&lt;p&gt;然后每个数据库实例里，都创建一个一样的库，比如说订单库。&lt;/p&gt;
&lt;p&gt;此时在5台服务器上都有一个订单库，名字可以类似为：db_order_01，db_order_02，等等。&lt;/p&gt;
&lt;p&gt;然后每个订单库里，都有一个相同的表，比如说订单库里有订单信息表，那么此时5个订单库里都有一个订单信息表。&lt;/p&gt;
&lt;p&gt;比如db_order_01库里就有一个tb_order_01表，db_order_02库里就有一个tb_order_02表。&lt;/p&gt;
&lt;p&gt;这就实现了一个基本的分库分表的思路，原来的一台数据库服务器变成了5台数据库服务器，原来的一个库变成了5个库，原来的一张表变成了5个表。&lt;/p&gt;
&lt;p&gt;然后你在写入数据的时候，需要借助数据库中间件，比如sharding-jdbc，或者是mycat，都可以。&lt;/p&gt;
&lt;p&gt;你可以根据比如订单id来hash后按5取模，比如每天订单表新增50万数据，此时其中10万条数据会落入db_order_01库的tb_order_01表，另外10万条数据会落入db_order_02库的tb_order_02表，以此类推。&lt;/p&gt;
&lt;p&gt;这样就可以把数据均匀分散在5台服务器上了，查询的时候，也可以通过订单id来hash取模，去对应的服务器上的数据库里，从对应的表里查询那条数据出来即可。&lt;/p&gt;
&lt;p&gt;依据这个思路画出的图如下所示，大家可以看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/19/1690182818c8d80d~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp&quot; alt=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;做这一步有什么好处呢？&lt;/p&gt;
&lt;p&gt;第一个好处，原来比如订单表就一张表，这个时候不就成了5张表了么，那么每个表的数据就变成1/5了。&lt;/p&gt;
&lt;p&gt;假设订单表一年有1亿条数据，此时5张表里每张表一年就2000万数据了。&lt;/p&gt;
&lt;p&gt;那么假设当前订单表里已经有2000万数据了，此时做了上述拆分，每个表里就只有400万数据了。&lt;/p&gt;
&lt;p&gt;而且每天新增50万数据的话，那么每个表才新增10万数据，这样是不是初步缓解了单表数据量过大影响系统性能的问题？&lt;/p&gt;
&lt;p&gt;另外就是每秒1万请求到5台数据库上，每台数据库就承载每秒2000的请求，是不是一下子把每台数据库服务器的并发请求降低到了安全范围内？&lt;/p&gt;
&lt;p&gt;这样，降低了数据库的高峰期负载，同时还保证了高峰期的性能。&lt;/p&gt;
&lt;h1 data-id=&quot;heading-3&quot;&gt;（3）大量分表来保证海量数据下的查询性能&lt;/h1&gt;
&lt;p&gt;但是上述的数据库架构还有一个问题，那就是单表数据量还是过大，现在订单表才分为了5张表，那么如果订单一年有1亿条，每个表就有2000万条，这也还是太大了。&lt;/p&gt;
&lt;p&gt;所以还应该继续分表，大量分表。&lt;/p&gt;
&lt;p&gt;比如可以把订单表一共拆分为1024张表，这样1亿数据量的话，分散到每个表里也就才10万量级的数据量，然后这上千张表分散在5台数据库里就可以了。&lt;/p&gt;
&lt;p&gt;在写入数据的时候，需要做两次路由，先对订单id hash后对数据库的数量取模，可以路由到一台数据库上，然后再对那台数据库上的表数量取模，就可以路由到数据库上的一个表里了。&lt;/p&gt;
&lt;p&gt;通过这个步骤，就可以让每个表里的数据量非常小，每年1亿数据增长，但是到每个表里才10万条数据增长，这个系统运行10年，每个表里可能才百万级的数据量。&lt;/p&gt;
&lt;p&gt;这样可以一次性为系统未来的运行做好充足的准备，看下面的图，一起来感受一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/19/1690182a76438055~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp&quot; alt=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h1 data-id=&quot;heading-4&quot;&gt;（4）读写分离来支撑按需扩容以及性能提升&lt;/h1&gt;
&lt;p&gt;这个时候整体效果已经挺不错了，大量分表的策略保证可能未来10年，每个表的数据量都不会太大，这可以保证单表内的SQL执行效率和性能。&lt;/p&gt;
&lt;p&gt;然后多台数据库的拆分方式，可以保证每台数据库服务器承载一部分的读写请求，降低每台服务器的负载。&lt;/p&gt;
&lt;p&gt;但是此时还有一个问题，假如说每台数据库服务器承载每秒2000的请求，然后其中400请求是写入，1600请求是查询。&lt;/p&gt;
&lt;p&gt;也就是说，增删改的SQL才占到了20%的比例，80%的请求是查询。&lt;/p&gt;
&lt;p&gt;此时假如说随着用户量越来越大，假如说又变成每台服务器承载4000请求了。&lt;/p&gt;
&lt;p&gt;那么其中800请求是写入，3200请求是查询，如果说你按照目前的情况来扩容，就需要增加一台数据库服务器.&lt;/p&gt;
&lt;p&gt;但是此时可能就会涉及到表的迁移，因为需要迁移一部分表到新的数据库服务器上去，是不是很麻烦？&lt;/p&gt;
&lt;p&gt;其实完全没必要，数据库一般都支持读写分离，也就是做主从架构。&lt;/p&gt;
&lt;p&gt;写入的时候写入主数据库服务器，查询的时候读取从数据库服务器，就可以让一个表的读写请求分开落地到不同的数据库上去执行。&lt;/p&gt;
&lt;p&gt;这样的话，假如写入主库的请求是每秒400，查询从库的请求是每秒1600，那么图大概如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/19/1690182d93a231a3~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp&quot; alt=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;写入主库的时候，会自动同步数据到从库上去，保证主库和从库数据一致。&lt;/p&gt;
&lt;p&gt;然后查询的时候都是走从库去查询的，这就通过数据库的主从架构实现了读写分离的效果了。&lt;/p&gt;
&lt;p&gt;现在的好处就是，假如说现在主库写请求增加到800，这个无所谓，不需要扩容。然后从库的读请求增加到了3200，需要扩容了。&lt;/p&gt;
&lt;p&gt;这时，你直接给主库再挂载一个新的从库就可以了，两个从库，每个从库支撑1600的读请求，不需要因为读请求增长来扩容主库。&lt;/p&gt;
&lt;p&gt;实际上线上生产你会发现，读请求的增长速度远远高于写请求，所以读写分离之后，大部分时候就是扩容从库支撑更高的读请求就可以了。&lt;/p&gt;
&lt;p&gt;而且另外一点，对同一个表，如果你既写入数据（涉及加锁），还从该表查询数据，可能会牵扯到锁冲突等问题，无论是写性能还是读性能，都会有影响。&lt;/p&gt;
&lt;p&gt;所以一旦读写分离之后，对主库的表就仅仅是写入，没任何查询会影响他，对从库的表就仅仅是查询。&lt;/p&gt;
&lt;h1 data-id=&quot;heading-5&quot;&gt;（5）高并发下的数据库架构设计总结&lt;/h1&gt;
&lt;p&gt;其实从大的一个简化的角度来说，高并发的场景下，数据库层面的架构肯定是需要经过精心的设计的。&lt;/p&gt;
&lt;p&gt;尤其是涉及到分库来支撑高并发的请求，大量分表保证每个表的数据量别太大，读写分离实现主库和从库按需扩容以及性能保证。&lt;/p&gt;
&lt;p&gt;这篇文章就是从一个大的角度来梳理了一下思路，各位同学可以结合自己公司的业务和项目来考虑自己的系统如何做分库分表应该怎么做。&lt;/p&gt;
&lt;p&gt;另外就是，具体的分库分表落地的时候，需要借助数据库中间件来实现分库分表和读写分离，大家可以自己参考 sharding-jdbc 或者 mycat 的官网即可，里面的文档都有详细的使用描述。&lt;/p&gt;
&lt;p&gt;（封面图源网络，侵权删除）&lt;/p&gt;
&lt;h2 data-id=&quot;heading-6&quot;&gt;END&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/18/169007e734f5d1b5~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp&quot; alt=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;如有收获，请帮忙转发，您的鼓励是作者最大的动力，谢谢！&lt;/p&gt;
&lt;p&gt;一大波微服务、分布式、高并发、高可用的原创系列文章正在路上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎扫描下方二维码，持续关注：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/9/16833096471eb0ef~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp&quot; alt=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;石杉的架构笔记（id:shishan100）&lt;/p&gt;
&lt;p&gt;十余年BAT架构经验倾囊相授&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;https://juejin.im/post/6844903705553174541&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903705553174541&quot;&gt;拜托！面试请不要再问我Spring Cloud底层原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://juejin.im/post/6844903710301093896&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903710301093896&quot;&gt;【双11狂欢的背后】微服务注册中心如何承载大型系统的千万级访问？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://juejin.im/post/6844903711660064781&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903711660064781&quot;&gt;【性能优化之道】每秒上万并发下的Spring Cloud参数优化实战&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://juejin.im/post/6844903712431800327&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903712431800327&quot;&gt;微服务架构如何保障双11狂欢下的99.99%高可用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://juejin.im/post/6844903713211940877&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903713211940877&quot;&gt;兄弟，用大白话告诉你小白都能听懂的Hadoop架构原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://juejin.im/post/6844903713966915598&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903713966915598&quot;&gt;大规模集群下Hadoop NameNode如何承载每秒上千次的高并发访问&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7、&lt;a href=&quot;https://juejin.im/post/6844903714797387783&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903714797387783&quot;&gt;【性能优化的秘密】Hadoop如何将TB级大文件的上传性能优化上百倍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8、&lt;a href=&quot;https://juejin.im/post/6844903716089233416&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903716089233416&quot;&gt;拜托，面试请不要再问我TCC分布式事务的实现原理！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a href=&quot;https://juejin.im/post/6844903717007785998&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903717007785998&quot;&gt;【坑爹呀！】最终一致性分布式事务如何保障实际生产中99.99%高可用？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;10、&lt;a href=&quot;https://juejin.im/post/6844903717641142285&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903717641142285&quot;&gt;拜托，面试请不要再问我Redis分布式锁的实现原理！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;11、&lt;a href=&quot;https://juejin.im/post/6844903718324797453&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903718324797453&quot;&gt;【眼前一亮！】看Hadoop底层算法如何优雅的将大规模集群性能提升10倍以上？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;12、&lt;a href=&quot;https://juejin.im/post/6844903721793486861&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903721793486861&quot;&gt;亿级流量系统架构之如何支撑百亿级数据的存储与计算&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;13、&lt;a href=&quot;https://juejin.im/post/6844903725249593358&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903725249593358&quot;&gt;亿级流量系统架构之如何设计高容错分布式计算系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;14、&lt;a href=&quot;https://juejin.im/post/6844903726050705422&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903726050705422&quot;&gt;亿级流量系统架构之如何设计承载百亿流量的高性能架构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;15、&lt;a href=&quot;https://juejin.im/post/6844903726835073031&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903726835073031&quot;&gt;亿级流量系统架构之如何设计每秒十万查询的高并发架构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;16、&lt;a href=&quot;https://juejin.im/post/6844903727699230734&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903727699230734&quot;&gt;亿级流量系统架构之如何设计全链路99.99%高可用架构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;17、&lt;a href=&quot;https://juejin.im/post/6844903729406148622&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903729406148622&quot;&gt;七张图彻底讲清楚ZooKeeper分布式锁的实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;18、&lt;a href=&quot;https://juejin.im/post/6844903730303746061&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903730303746061&quot;&gt;大白话聊聊Java并发面试问题之volatile到底是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;19、&lt;a href=&quot;https://juejin.im/post/6844903731234865160&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903731234865160&quot;&gt;大白话聊聊Java并发面试问题之Java 8如何优化CAS性能？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;20、&lt;a href=&quot;https://juejin.im/post/6844903732061159437&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903732061159437&quot;&gt;大白话聊聊Java并发面试问题之谈谈你对AQS的理解？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;21、&lt;a href=&quot;https://juejin.im/post/6844903732883226637&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903732883226637&quot;&gt;大白话聊聊Java并发面试问题之公平锁与非公平锁是啥？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;22、&lt;a href=&quot;https://juejin.im/post/6844903734267510798&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903734267510798&quot;&gt;大白话聊聊Java并发面试问题之微服务注册中心的读写锁优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;23、&lt;a href=&quot;https://juejin.im/post/6844903734930046989&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903734930046989&quot;&gt;互联网公司的面试官是如何360°无死角考察候选人的？（上篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;24、&lt;a href=&quot;https://juejin.im/post/6844903735655661581&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903735655661581&quot;&gt;互联网公司面试官是如何360°无死角考察候选人的？（下篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;25、&lt;a href=&quot;https://juejin.im/post/6844903736444207117&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903736444207117&quot;&gt;Java进阶面试系列之一：哥们，你们的系统架构中为什么要引入消息中间件？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;26、&lt;a href=&quot;https://juejin.im/post/6844903737123667975&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903737123667975&quot;&gt;【Java进阶面试系列之二】：哥们，那你说说系统架构引入消息中间件有什么缺点？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;27、&lt;a href=&quot;https://juejin.im/post/6844903741213130765&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903741213130765&quot;&gt;【行走的Offer收割机】记一位朋友斩获BAT技术专家Offer的面试经历&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;28、&lt;a href=&quot;https://juejin.im/post/6844903742114906125&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903742114906125&quot;&gt;【Java进阶面试系列之三】哥们，消息中间件在你们项目里是如何落地的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;29、&lt;a href=&quot;https://juejin.im/post/6844903742928601095&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903742928601095&quot;&gt;【Java进阶面试系列之四】扎心！线上服务宕机时，如何保证数据100%不丢失？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;30、&lt;a href=&quot;https://juejin.im/post/6844903743712935944&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903743712935944&quot;&gt;一次JVM FullGC的背后，竟隐藏着惊心动魄的线上生产事故！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;31、&lt;a href=&quot;https://juejin.im/post/6844903744514031624&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903744514031624&quot;&gt;【高并发优化实践】10倍请求压力来袭，你的系统会被击垮吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;32、&lt;a href=&quot;https://juejin.im/post/6844903746636349453&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903746636349453&quot;&gt;【Java进阶面试系列之五】消息中间件集群崩溃，如何保证百万生产数据不丢失？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;33、&lt;a href=&quot;https://juejin.im/post/6844903747345219598&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903747345219598&quot;&gt;亿级流量系统架构之如何在上万并发场景下设计可扩展架构（上）？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;34、&lt;a href=&quot;https://juejin.im/post/6844903747903029261&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903747903029261&quot;&gt;亿级流量系统架构之如何在上万并发场景下设计可扩展架构（中）？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;35、&lt;a href=&quot;https://juejin.im/post/6844903748565745678&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903748565745678&quot;&gt;亿级流量系统架构之如何在上万并发场景下设计可扩展架构（下）？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;36、&lt;a href=&quot;https://juejin.im/post/6844903752030240782&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903752030240782&quot;&gt;亿级流量架构第二弹：你的系统真的无懈可击吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;37、&lt;a href=&quot;https://juejin.im/post/6844903753489858568&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903753489858568&quot;&gt;亿级流量系统架构之如何保证百亿流量下的数据一致性（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;38、&lt;a href=&quot;https://juejin.im/post/6844903757055016968&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903757055016968&quot;&gt;亿级流量系统架构之如何保证百亿流量下的数据一致性（中）？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;39、&lt;a href=&quot;https://juejin.im/post/6844903757830946829&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903757830946829&quot;&gt;亿级流量系统架构之如何保证百亿流量下的数据一致性（下）？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;40、&lt;a href=&quot;https://juejin.im/post/6844903758510424072&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903758510424072&quot;&gt;互联网面试必杀：如何保证消息中间件全链路数据100%不丢失（1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;41、&lt;a href=&quot;https://juejin.im/post/6844903759324119053&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903759324119053&quot;&gt;互联网面试必杀：如何保证消息中间件全链路数据100%不丢失（2&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;42、&lt;a href=&quot;https://juejin.im/post/6844903760561438727&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903760561438727&quot;&gt;面试大杀器：消息中间件如何实现消费吞吐量的百倍优化？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;43、&lt;a href=&quot;https://juejin.im/post/6844903761194778631&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903761194778631&quot;&gt;高并发场景下，如何保证生产者投递到消息中间件的消息不丢失？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;44、&lt;a href=&quot;https://juejin.im/post/6844903761899601933&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903761899601933&quot;&gt;兄弟，用大白话给你讲小白都能看懂的分布式系统容错架构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;45、&lt;a href=&quot;https://juejin.im/post/6844903762562121736&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903762562121736&quot;&gt;从团队自研的百万并发中间件系统的内核设计看Java并发性能优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;46、&lt;a href=&quot;https://juejin.im/post/6844903764499890190&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903764499890190&quot;&gt;【非广告，纯干货】英语差的程序员如何才能无障碍阅读官方文档？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;47、&lt;a href=&quot;https://juejin.im/post/6844903765733015559&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903765733015559&quot;&gt;如果20万用户同时访问一个热点缓存，如何优化你的缓存架构？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;48、&lt;a href=&quot;https://juejin.im/post/6844903766626402311&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903766626402311&quot;&gt;【非广告，纯干货】中小公司的Java工程师应该如何逆袭冲进BAT？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;49、&lt;a href=&quot;https://juejin.im/post/6844903767180050446&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903767180050446&quot;&gt;拜托，面试请不要再问我分布式搜索引擎的架构原理！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;50、&lt;a href=&quot;https://juejin.im/post/6844903775744819208&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903775744819208&quot;&gt;【金三银四跳槽季】Java工程师如何在1个月内做好面试准备？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;51、&lt;a href=&quot;https://juejin.im/post/1&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/1&quot;&gt;【offer收割机必备】我简历上的Java项目都好low，怎么办？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;52、&lt;a href=&quot;https://juejin.im/post/6844903777099595789&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903777099595789&quot;&gt;【offer去哪了】我一连面试了十个Java岗，统统石沉大海！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：石杉的架构笔记
链接：&lt;a href=&quot;https://juejin.im/post/6844903749199069198&quot; target=&quot;_blank&quot; title=&quot;https://juejin.im/post/6844903749199069198&quot;&gt;juejin.im/post/684490…&lt;/a&gt;
来源：掘金
著作权归作者所有，转载请联系作者获得授权！&lt;/p&gt;</description><link>https://juejin.cn/post/6844903779079290894</link><guid isPermaLink="false">https://juejin.cn/post/6844903779079290894</guid><pubDate>Tue, 19 Feb 2019 00:28:40 GMT</pubDate><author>石杉的架构笔记</author><category>后端</category><category>架构</category><category>Java</category></item><item><title>我与Microtasks的前世今生之一眼望穿千年</title><description>&lt;blockquote&gt;
&lt;p&gt;转自IMWeb社区，作者：孙世吉，&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Fimweb.io%2Ftopic%2F5bb9fd3779ddc80f36592f47&quot; title=&quot;http://imweb.io/topic/5bb9fd3779ddc80f36592f47&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文有标题党之嫌，内含大量Microtaks相关总结性信息，请谨慎服用。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;Google Developer Day China 2018 by Jake Archibald&lt;/h2&gt;
&lt;p&gt;2018年9月21日，虽然没有参加该场GDD，但是也有幸拜读了百度@小蘑菇小哥总结的文章&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F45111890&quot; title=&quot;https://zhuanlan.zhihu.com/p/45111890&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;深入浏览器的事件循环(GDD@2018)&lt;/a&gt;,配注的说明插图形象生动，文终的click代码也很有意思，推荐大家阅读。这里就先恬不知耻的将该文的精华以及一些自己的总结陈列如下:&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/26/166aeb3cc1b575e5~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;异步任务&lt;/th&gt;
&lt;th&gt;特点&lt;/th&gt;
&lt;th&gt;常见产生处&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Tasks (Macrotasks)&lt;/td&gt;
&lt;td&gt;- 当次事件循环执行队列内的一个任务&lt;br&gt;- 当次事件循环产生的新任务会在指定时机加入任务队列等待执行&lt;/td&gt;
&lt;td&gt;- setTimeout&lt;br&gt;- setInterval&lt;br&gt;- setImmediate&lt;br&gt;- I/O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Animation callbacks&lt;/td&gt;
&lt;td&gt;- 渲染过程(Structure-Layout-Paint)前执行&lt;br&gt;- 当次事件循环&lt;strong&gt;执行队列里的所有任务&lt;/strong&gt;&lt;br&gt;- 当次事件循环&lt;strong&gt;产生的新任务会在下一次循环执行&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- rAF&lt;br&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Microtasks&lt;/td&gt;
&lt;td&gt;- 当次事件循环的结尾立即执行的任务&lt;br&gt;- 当次事件循环&lt;strong&gt;执行队列里的所有任务&lt;/strong&gt;&lt;br&gt;- 当次事件循环&lt;strong&gt;产生的新任务会立即执行&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- Promise&lt;br&gt;- Object.observe&lt;br&gt;- MutationObserver&lt;br&gt;- process.nextTick&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;直观的感受一下Macrotasks和Microtasks&lt;/h2&gt;
&lt;p&gt;看过一篇公众号文章下面的留言:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那个所谓的mtask和task的区别我并不认同...，我认为事件对列只有一个，就是task。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;特别是对于JS异步编程思维还不太熟悉的同学，比如两年前从java转成javascript后的我，对于这种异步的调用顺序其实很难理解。&lt;/p&gt;
&lt;p&gt;不过有一个特别能说明Macrotasks和Microtasks的例子:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 普通的递归, 造成死循环, 页面无响应&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-string&quot;&gt;&#39;callback&#39;&lt;/span&gt;);
    callback();
}
callback();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码相信大家非常好理解，一个很简单的递归，由于事件循环得不到释放，UI渲染无法进行导致页面无响应。&lt;/p&gt;
&lt;p&gt;通常我们可以使用setTimeout来进行改造，我们把下一次执行放到异步队列里面，不会持久的占用计算资源，这就是我们说的Macrotasks:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Macrotasks，不会造成死循环&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-string&quot;&gt;&#39;callback&#39;&lt;/span&gt;);
  setTimeout(callback，&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);
}

callback();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是Promise回调产生的Microtasks呢，如下代码，同样会造成死循环。&lt;/p&gt;
&lt;p&gt;通过上文我们也可以知道&lt;strong&gt;当次事件循环产生的新Microtasks会立即执行&lt;/strong&gt;，同时当次事件循环要等到所有Microtasks队列执行完毕后才会结束。所以当我们的Microtasks在产生新的任务的同时，会导致Microtasks队列一直有任务等待执行，这次事件循环永远不会退出，也就导致了我们的死循环。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Microtasks，同样会造成死循环，页面无响应&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;callback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-string&quot;&gt;&#39;callback&#39;&lt;/span&gt;);
  &lt;span class=&quot;hljs-built_in&quot;&gt;Promise&lt;/span&gt;.resolve().then(callback);
}
callback();
&lt;/code&gt;&lt;/pre&gt;&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;Microtasks 与 Promise A+&lt;/h2&gt;
&lt;p&gt;当然，上文解决了本人关于Microtasks的相关疑虑 (&lt;s&gt;特别是有人拿出一段参杂setTimeout和Promise的代码让你看代码输出顺序时&lt;/s&gt;) 的同时，也让我回忆起似乎曾几何时也在哪里看到过关于Microtask的字眼。&lt;/p&gt;
&lt;p&gt;经过多日的寻找，终于在以前写过的一片关于Promise的总结文章 &lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Fimweb.io%2Ftopic%2F57a0760393d9938132cc8da9&quot; title=&quot;http://imweb.io/topic/57a0760393d9938132cc8da9&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;打开Promise的正确姿势&lt;/a&gt; 里找到了。该文通过一个实例说明了新建Promise的代码是会立即执行的，并不会放到异步队列里:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; d = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;();

&lt;span class=&quot;hljs-comment&quot;&gt;// 创建一个promise实例，该实例在2秒后进入fulfilled状态&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; promise1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;resolve，reject&lt;/span&gt;) &lt;/span&gt;{
  setTimeout(resolve，&lt;span class=&quot;hljs-number&quot;&gt;2000&lt;/span&gt;，&lt;span class=&quot;hljs-string&quot;&gt;&#39;resolve from promise 1&#39;&lt;/span&gt;);
});

&lt;span class=&quot;hljs-comment&quot;&gt;// 创建一个promise实例，该实例在1秒后进入fulfilled状态&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; promise2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;resolve，reject&lt;/span&gt;) &lt;/span&gt;{
  setTimeout(resolve，&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;，promise1); &lt;span class=&quot;hljs-comment&quot;&gt;// resolve(promise1)&lt;/span&gt;
});

promise2.then(
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;result&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-string&quot;&gt;&#39;result:&#39;&lt;/span&gt;，result，&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;() - d),
  error =&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-string&quot;&gt;&#39;error:&#39;&lt;/span&gt;，error)
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码输出&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;result: resolve from promise 1 2002
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们得到两点结论:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证了Promise/A+中的&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fpromisesaplus.com%2F%23point-49&quot; title=&quot;https://promisesaplus.com/#point-49&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;2.3.2规范&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;新建Promise的代码时会立即执行的 (运行时间是2秒而不是3秒)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是当时本人忽略了Promise/A+的相关&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fpromisesaplus.com%2F%23point-67&quot; title=&quot;https://promisesaplus.com/#point-67&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;注解内容&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Here “platform code” means engine，environment，and promise implementation code. In practice，this requirement ensures that &lt;code&gt;onFulfilled&lt;/code&gt; and &lt;code&gt;onRejected&lt;/code&gt; execute asynchronously，after the event loop turn in which &lt;code&gt;then&lt;/code&gt; is called，and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as &lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fwebappapis.html%23timers&quot; title=&quot;https://html.spec.whatwg.org/multipage/webappapis.html#timers&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;&lt;code&gt;setTimeout&lt;/code&gt;&lt;/a&gt; or &lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fdvcs.w3.org%2Fhg%2Fwebperf%2Fraw-file%2Ftip%2Fspecs%2FsetImmediate%2FOverview.html%23processingmodel&quot; title=&quot;https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html#processingmodel&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;&lt;code&gt;setImmediate&lt;/code&gt;&lt;/a&gt;，or with a “micro-task” mechanism such as &lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fdom.spec.whatwg.org%2F%23interface-mutationobserver&quot; title=&quot;https://dom.spec.whatwg.org/#interface-mutationobserver&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;&lt;code&gt;MutationObserver&lt;/code&gt;&lt;/a&gt; or &lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Fnodejs.org%2Fapi%2Fprocess.html%23process_process_nexttick_callback&quot; title=&quot;http://nodejs.org/api/process.html#process_process_nexttick_callback&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;&lt;code&gt;process.nextTick&lt;/code&gt;&lt;/a&gt;. Since the promise implementation is considered platform code，it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是的，这就是本人与MicroTasks的第一次相遇，没有一见钟情还真是非常抱歉啊。&lt;/p&gt;
&lt;p&gt;该注解说明了Promise的 &lt;code&gt;onFulfilled&lt;/code&gt; 和 &lt;code&gt;onRejected&lt;/code&gt; 回调的执行只要确保是在 &lt;code&gt;then&lt;/code&gt;被调用后异步执行就可以了。具体实现成 &lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fhtml.spec.whatwg.org%2Fmultipage%2Fwebappapis.html%23timers&quot; title=&quot;https://html.spec.whatwg.org/multipage/webappapis.html#timers&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;&lt;code&gt;setTimeout&lt;/code&gt;&lt;/a&gt; 似的 macrotasks 机制或者 &lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Fnodejs.org%2Fapi%2Fprocess.html%23process_process_nexttick_callback&quot; title=&quot;http://nodejs.org/api/process.html#process_process_nexttick_callback&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;&lt;code&gt;process.nextTick&lt;/code&gt;&lt;/a&gt; 似的microtasks机制都可以，具体视平台代码而定。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;为什么需要Microtasks&lt;/h2&gt;
&lt;p&gt;搜索引擎能找到的相关文章基本都指向了一篇&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fjakearchibald.com%2F2015%2Ftasks-microtasks-queues-and-schedules%2F%3Futm_source%3Dhtml5weekly&quot; title=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;《Tasks，microtasks，queues and schedules》&lt;/a&gt;，也许这就是传说中原罪的发源之地吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Microtasks&lt;/strong&gt; are usually scheduled for things that should happen straight after the currently executing script，such as reacting to a batch of actions，or to make something async without taking the penalty of a whole new task.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，就是希望对一系列的任务做出回应或者执行异步操作，但是又不想额外付出一整个异步任务的代价。在这种情况下，Microtasks就可以用来调度这些&lt;strong&gt;应当在当前执行脚本结束后立马执行的任务&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The microtask queue is processed after callbacks as long as no other JavaScript is mid-execution，and at the end of each task. Any additional microtasks queued during microtasks are added to the end of the queue and also processed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单独看Macrotasks和 Microtasks，执行顺序可以总结如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取出Macrotasks任务队列的一个任务，执行;&lt;/li&gt;
&lt;li&gt;取出Microtasks任务队列的所有任务，依次执行;&lt;/li&gt;
&lt;li&gt;本次事件循环结束，等待下次事件循环;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从这个方面我们也可以理解为什么Promise.then要被实现成Microtasks，回调在实现Promise/A+规范 (必须是异步执行)的基础上，也保证能够更快的被执行，而不是跟Macrotasks一样必须等到下次事件循环才能执行。大家可以重新执行一下上文对比Macrotasks和Microtasks时举的例子，也会发现他们两的单位时间内的执行次数是不一样的。&lt;/p&gt;
&lt;p&gt;可以试想一些综合了异步任务和同步任务的的Promise实例，Microtasks可以保证它们更快的得到执行资源，例如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;resolve&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;hljs-comment&quot;&gt;/* 检查资源是否需要异步加载 */&lt;/span&gt;) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; asyncAction().then(resolve);
  }
  &lt;span class=&quot;hljs-comment&quot;&gt;// 直接返回加载好的异步资源&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; syncResource;
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果上面的代码是为了加载远程的资源，那么只有第一次需要执行异步加载，后面的所有执行都可以直接同步读取缓存内容。如果使用Microtasks，我们也就不用每次都等待多一次的事件循环来获取该资源，Promise实例的新建过程是立即执行的，同时&lt;code&gt;onFulfilled&lt;/code&gt;回调也是在本次事件循环中全部执行完毕的，减少了切换上下文的成本，提高了性能。&lt;/p&gt;
&lt;p&gt;但是呢，从上文关于Promise/A+规范的引用中我们已经知道不同浏览器对于该实现是不一致的。部分浏览器 (越来越少) 将Promise的回调函数实现成了Macrotasks，原因就在于Promise的定义来自ECMAScript而不是HTML。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Job is an abstract operation that initiates an ECMAScript computation when no other ECMAScript computation is currently in progress. A Job abstract operation may be defined to accept an arbitrary set of job parameters.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Ftc39.github.io%2Fecma262%2F%23sec-jobs-and-job-queues&quot; title=&quot;https://tc39.github.io/ecma262/#sec-jobs-and-job-queues&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;ECMAScript的规范&lt;/a&gt;，是没有Microtasks的相关定义的，类似的有一个&lt;code&gt;jobs&lt;/code&gt; 的概念，和Microtasks很相似.&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;相关应用&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue%2Fblob%2Fdev%2Fsrc%2Fcore%2Futil%2Fnext-tick.js&quot; title=&quot;https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;Vue - src/core/utils/next-tick.js&lt;/a&gt; 中也有相关Macrotask和Microtask的实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; microTimerFunc
&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; macroTimerFunc
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; setImmediate !== &lt;span class=&quot;hljs-string&quot;&gt;&#39;undefined&#39;&lt;/span&gt; &amp;amp;&amp;amp; isNative(setImmediate)) {
  macroTimerFunc = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {
    setImmediate(flushCallbacks)
  }
} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; MessageChannel !== &lt;span class=&quot;hljs-string&quot;&gt;&#39;undefined&#39;&lt;/span&gt; &amp;amp;&amp;amp; (
  isNative(MessageChannel) ||
  &lt;span class=&quot;hljs-comment&quot;&gt;// PhantomJS&lt;/span&gt;
  MessageChannel.toString() === &lt;span class=&quot;hljs-string&quot;&gt;&#39;[object MessageChannelConstructor]&#39;&lt;/span&gt;
)) {
  &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; channel = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MessageChannel()
  &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; port = channel.port2
  channel.port1.onmessage = flushCallbacks
  macroTimerFunc = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {
    port.postMessage(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)
  }
} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
  &lt;span class=&quot;hljs-comment&quot;&gt;/* istanbul ignore next */&lt;/span&gt;
  macroTimerFunc = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {
    setTimeout(flushCallbacks，&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)
  }
}
&lt;span class=&quot;hljs-comment&quot;&gt;// Determine microtask defer implementation.&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;/* istanbul ignore next，$flow-disable-line */&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Promise&lt;/span&gt; !== &lt;span class=&quot;hljs-string&quot;&gt;&#39;undefined&#39;&lt;/span&gt; &amp;amp;&amp;amp; isNative(&lt;span class=&quot;hljs-built_in&quot;&gt;Promise&lt;/span&gt;)) {
  &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; p = &lt;span class=&quot;hljs-built_in&quot;&gt;Promise&lt;/span&gt;.resolve()
  microTimerFunc = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {
    p.then(flushCallbacks)
    &lt;span class=&quot;hljs-comment&quot;&gt;// in problematic UIWebViews，Promise.then doesn&#39;t completely break，but&lt;/span&gt;
    &lt;span class=&quot;hljs-comment&quot;&gt;// it can get stuck in a weird state where callbacks are pushed into the&lt;/span&gt;
    &lt;span class=&quot;hljs-comment&quot;&gt;// microtask queue but the queue isn&#39;t being flushed，until the browser&lt;/span&gt;
    &lt;span class=&quot;hljs-comment&quot;&gt;// needs to do some other work，e.g. handle a timer. Therefore we can&lt;/span&gt;
    &lt;span class=&quot;hljs-comment&quot;&gt;// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (isIOS) setTimeout(noop)
  }
} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
  &lt;span class=&quot;hljs-comment&quot;&gt;// fallback to macro&lt;/span&gt;
  microTimerFunc = macroTimerFunc
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F45111890&quot; title=&quot;https://zhuanlan.zhihu.com/p/45111890&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;浏览器的 Event Loop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Fimweb.io%2Ftopic%2F57a0760393d9938132cc8da9&quot; title=&quot;http://imweb.io/topic/57a0760393d9938132cc8da9&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;打开Promise的正确姿势&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fpromisesaplus.com&quot; title=&quot;https://promisesaplus.com&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;Promise/A+&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fjakearchibald.com%2F2015%2Ftasks-microtasks-queues-and-schedules%2F%3Futm_source%3Dhtml5weekly&quot; title=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;Tasks，microtasks，queues and schedules&lt;/a&gt;&lt;/p&gt;
</description><link>https://juejin.cn/post/6844903699911819272</link><guid isPermaLink="false">https://juejin.cn/post/6844903699911819272</guid><pubDate>Fri, 26 Oct 2018 04:49:18 GMT</pubDate><author>腾讯IMWeb团队</author><category>前端</category><category>Promise</category><category>JavaScript</category><category>Vue.js</category></item><item><title>前端组件设计--位运算的妙用</title><description>&lt;blockquote&gt;
&lt;p&gt;Hello好久不见。跳槽之后一直没什么时间总结记录这段时间的见闻或实践，好不容易挤出点时间，今天想记录一下最近的一个组件设计&amp;amp;开发历程，&lt;strong&gt;该组件的开发环境是小程序&lt;/strong&gt;，但是我认为这个思维是通用的~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文可能涉及内容--&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需求简介&lt;/li&gt;
&lt;li&gt;位运算与表单组件的结合&lt;/li&gt;
&lt;li&gt;组件设计小结&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;需求简介&lt;/h2&gt;
&lt;p&gt;我们大概需要完成这样一个表单组件↓↓&lt;/p&gt;
&lt;img width=&quot;50%&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a5c386b119458~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;
&lt;p&gt;由图大致可以判断，我们应该将此组件拆成两块，一个是tab选项区，一个是下方的附加选项区。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么需要分拆？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最主要的原因是项目自身原因，之前就有tab的组件，我们可以直接引用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当然，就算我们自身项目没有这个组件，我也是建议拆分开来，因为在表单的开发中，这种tab选择的形式可以说太常见了，拆分开来肯定是有益的，并且它的功能十分单一，很适合作为一个独立组件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如何用数据结构描述组件？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态结构大概明了，那么我们应该怎么用数据来描述这个组件呢？接下来就来考虑一下组件的数据结构，开始之前先明确几个前提--&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「tab数目不定、tab与附加项内容有联动、附加项数目不定」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img width=&quot;50%&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a5c3d14e49cf9~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;
&lt;p&gt;上图是我在第一版中构思的数据结构，制定该规则的原因如下--&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;由于tab数目不定，所以配置成数组由前端进行列表渲染最为合适(附加项的设定也同理)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为&lt;strong&gt;tab与附加项内容有联动&lt;/strong&gt;，所以我将附加项直接与tab内联，切换tab的时候直接切换相应的附加项数据即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于存在多个tab和多个附加项，所以必定会有组合排列的问题。在第一版方案中，我采用的是map的处理方式，将选中的value值拼接到一起，然后在valueMap中获取最终的value值。(不同业务不同方式，如果不需要处理组合问题，可直接输出所选的所有value值)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来逻辑就很顺畅啦，我们只需要获取用户最终选择的value拼接值就可以在valueMap中得到目标数据。&lt;/p&gt;
&lt;p&gt;但是这个方案是有瑕疵的，我忽略了&lt;strong&gt;配置复杂度&lt;/strong&gt;，这样在前端代码中可以很轻松的处理逻辑。但是会为后续的配置带来无穷后患，随着方案数量的增加，组合的情况会飞速增长。为了避免这个坑，我需要对valueMap做些优化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;valueMap的优化方案&lt;/strong&gt;&lt;/p&gt;
&lt;img width=&quot;50%&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a5c435ead31a4~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;
&lt;p&gt;如图中代码所示，摈弃原来键值一一对应的方式，采用根据tab项带出value可选范围的模式。&lt;/p&gt;
&lt;p&gt;然后通过对选中选项的处理得出value可选范围数组的下标。这样在配置起来会比上一种方案好一点，相对前端的逻辑会稍微复杂一点，但前端的代码只需要我们写一次，而配置则可能是无数次。&lt;/p&gt;
&lt;img width=&quot;50%&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a5c47601713da~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;
&lt;p&gt;新方案的前端逻辑大概是这样，等等...怎么看起来这么别扭？这段逻辑竟然完全和业务搅在一起了，万一新增附加项目岂不是爆炸了？万一附加方案间也出现了组合情况不也爆炸了:(&lt;/p&gt;
&lt;p&gt;那岂不是代表这种方案更不靠谱？&lt;strong&gt;我们是不是可以试试将其与业务解耦？&lt;/strong&gt;&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;位运算与表单组件的结合&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;JavaScript位运算简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;位运算就是直接对整数在内存中的二进制位进行操作，与是否处于JavaScript环境并没有什么关联，但我们可以借助一下这种位运算的思维。&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FBitwise_Operators&quot; title=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;有关JavaScript位运算的相关文档&lt;/a&gt;，在本文中我们主要会使用按位移动的操作符来达到我们的目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何将二者结合一起？&lt;/strong&gt;&lt;/p&gt;
&lt;img width=&quot;50%&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a5c4c0335dea4~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;
&lt;p&gt;直接上代码，我们看图说话--&lt;/p&gt;
&lt;p&gt;在新的逻辑中，我们已经看不到对addon项value的依赖，取而代之是二进制形式的位置下标。假设我们有这样一个数组：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;let A = [A-value-0, A-value-1, A-value-2, A-value-3]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;分别对这种四种选择情况的取值--&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选择情况&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;数组下标&lt;/th&gt;
&lt;th&gt;二进制下标&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;不选&lt;/td&gt;
&lt;td&gt;A-value-0&lt;/td&gt;
&lt;td&gt;A[0]&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;选择第一个&lt;/td&gt;
&lt;td&gt;A-value-1&lt;/td&gt;
&lt;td&gt;A[1]&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;选择第二个&lt;/td&gt;
&lt;td&gt;A-value-2&lt;/td&gt;
&lt;td&gt;A[2]&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全选&lt;/td&gt;
&lt;td&gt;A-value-3&lt;/td&gt;
&lt;td&gt;A[3]&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这样就很简单明了了，看二进制下标那一列不难发现，其中0表示未选，1表示已选，并且可通过1的位置，知道已选或未选的项目是哪一项。&lt;/p&gt;
&lt;p&gt;再看看数组下标与二进制下标的关系，将二进制下标转为十进制后，正好就是所需的数组下标。&lt;/p&gt;
&lt;p&gt;回头看看图中的代码，上述的取值思路正是forEach内部所干的事情：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;遍历addon数组中被checked的项，根据其index得出属于该项的二进制下标，再将遍历而来的所有二进制下标做OR运算得出最终的二进制下标，后转为真正的数组下标，从而得出最终的value值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过这种方案，我们可以在完全不关心addonList中的项个数或是每项值的情况下，得出我们想要的组合以及取到该组合对应的值，在我们配置项目的时候只需要留心每个value的顺序即可，无论配置多少项对前端的逻辑也不会产生影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将此案例中的addonList个数更改也是一样可行的，比如有3项的情况：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选择情况&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;数组下标&lt;/th&gt;
&lt;th&gt;二进制下标&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;不选&lt;/td&gt;
&lt;td&gt;A-value-0&lt;/td&gt;
&lt;td&gt;A[0]&lt;/td&gt;
&lt;td&gt;000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;选一&lt;/td&gt;
&lt;td&gt;A-value-1&lt;/td&gt;
&lt;td&gt;A[1]&lt;/td&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;选二&lt;/td&gt;
&lt;td&gt;A-value-2&lt;/td&gt;
&lt;td&gt;A[2]&lt;/td&gt;
&lt;td&gt;010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;一、二&lt;/td&gt;
&lt;td&gt;A-value-3&lt;/td&gt;
&lt;td&gt;A[3]&lt;/td&gt;
&lt;td&gt;011&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;选三&lt;/td&gt;
&lt;td&gt;A-value-4&lt;/td&gt;
&lt;td&gt;A[4]&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;一、三&lt;/td&gt;
&lt;td&gt;A-value-5&lt;/td&gt;
&lt;td&gt;A[5]&lt;/td&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;二、三&lt;/td&gt;
&lt;td&gt;A-value-6&lt;/td&gt;
&lt;td&gt;A[6]&lt;/td&gt;
&lt;td&gt;110&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全选&lt;/td&gt;
&lt;td&gt;A-value-7&lt;/td&gt;
&lt;td&gt;A[7]&lt;/td&gt;
&lt;td&gt;111&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;组件设计总结&lt;/h2&gt;
&lt;p&gt;通过这次的表单组件设计，对前端的组件设计有一点点思考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独立
&lt;ul&gt;
&lt;li&gt;组件功能单一，radio就应该负责radio选择，不要加上一些与业务相关的逻辑或文案。&lt;/li&gt;
&lt;li&gt;组件尽量不要过于复杂，既然分拆了组件就不要想着一个组件能完成所有的事情。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可复用
&lt;ul&gt;
&lt;li&gt;在设计组件的时候除了满足当前的需求，最好还要考虑其通用性。倘若发现它不具有通用性，就不如写在业务里，不需要单独抽离。&lt;/li&gt;
&lt;li&gt;当然，在设计组件时不可能要求使用组件的场景要百分百一致，让组件的适应、拓展能力变强，有助于组件的健壮。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中立
&lt;ul&gt;
&lt;li&gt;尽可能的少于业务耦合--保证组件中立。&lt;/li&gt;
&lt;li&gt;这一点看看就好，一般都是骨感的现实:)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;易用
&lt;ul&gt;
&lt;li&gt;尽量能做到使用者只需要考虑输入以及输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关于案例代码，也不确定大家是否需要。如果有需求的话，后面会补上一个完整版的组件代码。&lt;/strong&gt;&lt;/p&gt;
&lt;img width=&quot;50%&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a5c5da14df81f~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;
</description><link>https://juejin.cn/post/6844903699463012366</link><guid isPermaLink="false">https://juejin.cn/post/6844903699463012366</guid><pubDate>Thu, 25 Oct 2018 10:25:16 GMT</pubDate><author>mykurisu</author><category>前端</category><category>JavaScript</category></item><item><title>记录一次基于vue、typescript、pwa的项目由开发到部署</title><description>&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近秋招之余空出时间来按自己的兴趣动手做了一个项目，一个基于&lt;code&gt;vue，typescript，pwa&lt;/code&gt;的实验浏览移动端webapp，现在趁热打铁，将这个项目从开发到部署整个过程记录下来，并将从这个项目中学习到的东西分享出来，如果大家有什么意见或补充也可以在评论区提出。先介绍一下这个项目&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;项目介绍&lt;/h2&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;browseexp&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165f7ec4f3a3927c~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;基于vue，typescript，pwa的一个移动端webapp，取名叫browseExp，主要功能是浏览学校心理学院部分实验信息。（上图是添加到桌面的一级入口）。这个项目已经部署到了服务器上，我们看一下项目最终在客户端运行的样子&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;show&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165f7ec4f3b79206~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;可以看到我通过桌面上的一级入口，进入了我们的webapp，并且在断网的条件下进行。这就是pwa的作用，下面开始分享这次的开发到部署的过程。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;为什么要做这个项目呢？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;pwa 在国内已经火过一段时间了，但是自己还没做过一款pwa应用。&lt;/li&gt;
&lt;li&gt;vue-cli 3.0 增加了对pwa的支持&lt;/li&gt;
&lt;li&gt;vue2.5后增加了对ts的支持&lt;/li&gt;
&lt;li&gt;想搞事情！&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;开发过程&lt;/h2&gt;
&lt;p&gt;这个项目的地址为: &lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FHolyZheng%2FBrowseExp&quot; title=&quot;https://github.com/HolyZheng/BrowseExp&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;browseExp pwa&lt;/a&gt;，想要查看代码的同学可以看一下。这个项目要注意的点主要是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在vue中使用ts&lt;/li&gt;
&lt;li&gt;简单骨架屏的运用&lt;/li&gt;
&lt;li&gt;首屏加载时间和seo的优化&lt;/li&gt;
&lt;li&gt;pwa相关特性的实现&lt;/li&gt;
&lt;li&gt;移动端的一些问题解决&lt;/li&gt;
&lt;li&gt;如何部署项目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后面的内容也围绕着这些点来展开。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;vue中使用ts&lt;/h3&gt;
&lt;p&gt;使用ts主要是因为ts给我们带来了类型系统，可以让我们写出健壮的代码，它的作用在大型项目中尤其突出，所以还是非常鼓励大家去使用的，我们使用ts进行开发一般是编写基于类的vue组件，所以可以使用官方维护的&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue-class-component&quot; title=&quot;https://github.com/vuejs/vue-class-component&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;vue-class-component&lt;/a&gt;或者&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fkaorun343%2Fvue-property-decorator&quot; title=&quot;https://github.com/kaorun343/vue-property-decorator&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;vue-property-decorator&lt;/a&gt;，vue-cli3.0也给我们提供了开箱即用的typescript支持，开发体验还是相当友好的。一个vue组件demo：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;import { Component, Vue, Prop } from &lt;span class=&quot;hljs-string&quot;&gt;&#39;vue-property-decorator&#39;&lt;/span&gt;;
@Component
&lt;span class=&quot;hljs-built_in&quot;&gt;export&lt;/span&gt; default class Name extends Vue {
  @Prop() private name!: string;
  private complete!: boolean;
  private &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;data&lt;/span&gt;&lt;/span&gt;() {
    &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; {
      complete: &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;,
    };
  }
  private &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;myMethod&lt;/span&gt;&lt;/span&gt;() {
    // ...
  }
  private &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;created&lt;/span&gt;&lt;/span&gt;() {
    // ...
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外，在vue-cli3.0提供的脚手架下，可以在&lt;code&gt;shims-tsx.d.ts&lt;/code&gt;文件下添加全局接口或变量等，在&lt;code&gt;shims-vue.d.ts&lt;/code&gt;定义第三方包的类型声明。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;骨架屏的简单运用&lt;/h3&gt;
&lt;p&gt;骨架屏（skeleton screen）已经不是什么新奇的概念，他的主要作用就是用来过渡页面的空白状态，提升用户体验，比如页面跳转等待，数据加载等待等，传统的骨架平实现方案有 服务端渲染和预渲染等，而这个项目中引入骨架屏主要是想过渡数据加载时页面的局部空白状态，所以就直接采用编写一个骨架屏组件&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FHolyZheng%2FBrowseExp%2Fblob%2Fmaster%2Fsrc%2Fcomponents%2FSkeleton%2FSkeletonExp.vue&quot; title=&quot;https://github.com/HolyZheng/BrowseExp/blob/master/src/components/Skeleton/SkeletonExp.vue&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;SkeletonExp.vue&lt;/a&gt;的方式来过渡。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;skeletonOne&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165f7ec4f70c294f~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;
&lt;figure&gt;&lt;img alt=&quot;skeletonOne&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165f7ec506e60b45~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;如果你对骨架屏有更大的需求，可以在网上搜到更多的教程，这里就不列举了。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-6&quot;&gt;首屏加载速度和seo的优化&lt;/h3&gt;
&lt;p&gt;单页应用（single page web application，SPA）一个缺点就是首次加载需要加载较多的内容，所以首屏加载时间就会比较长。另外，单页应用因为数据前置到了前端，不利于搜索引擎的抓取。所以我们需要对自己的单页应用进行一些优化。这里我们使用了&lt;code&gt;prerender-spa-plugin&lt;/code&gt;这个webpack插件，他的作用就是将我们指定的路由进行预渲染到html，进而解决首次加载白屏时间长问题，以及一定程度上解决seo问题。在vue-cli3.0中，我们的相关配置是被隐藏起来的，我们可以通过vue.config.js来将我们的配置合并到默认配置中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;// vue.config.js

const path = require(&lt;span class=&quot;hljs-string&quot;&gt;&#39;path&#39;&lt;/span&gt;)
const PrerenderSPAPlugin = require(&lt;span class=&quot;hljs-string&quot;&gt;&#39;prerender-spa-plugin&#39;&lt;/span&gt;)

module.exports = {
  configureWebpack(config) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span class=&quot;hljs-string&quot;&gt;&#39;production&#39;&lt;/span&gt;) &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt;;
    &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt;  {
      plugins: [
        new PrerenderSPAPlugin({
          // Required - The path to the webpack-outputted app to prerender.
          staticDir: path.join(__dirname, &lt;span class=&quot;hljs-string&quot;&gt;&#39;dist&#39;&lt;/span&gt;),
          // Required - Routes to render.
          routes: [&lt;span class=&quot;hljs-string&quot;&gt;&#39;/&#39;&lt;/span&gt;],
        })
      ]
    }
  },
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;效果：
&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;prerender&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165f7ec4f70c055a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;上图是该app在网络环境为&lt;code&gt;slow 3G&lt;/code&gt;下首次打开时的效果，可以看到整个过程，先由谷歌页面跳至browseExp，首先引入眼帘的是我们的预渲染页面，它代替我网址跳转后应用加载的白屏时间，（前面的小段白屏是页面跳转的白屏，不是应用加载的白屏）然后加载完毕后就会去请求我们的数据，这时候骨架屏就出现了，过渡这段页面局部白屏的时间，最后为真实的页面。
&lt;strong&gt;预渲染也有它的缺点&lt;/strong&gt;：那就是预渲染的页面内容可能与真实内容由一定出入，而且还无法交互。所以如果应用的内容具有很强的实时性和交互性的话，可以考虑采用骨架屏的方式来进行首屏加载的白屏过渡，但是这样就无法优化seo了，所以按自己的实际场景来做选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外&lt;/strong&gt;对于首屏加载速度还可以通过&lt;strong&gt;组件懒加载&lt;/strong&gt;的方式，对组件进行懒加载，只有当需要默写组件的时候才去加载他们，也可以减少首屏加载需要加载的文件大小，提高首屏加载速度，也有利于service worker对app shell进行颗粒度更小的缓存。结合Vue的异步组件和webpack的代码分割功能，轻松实现路由组件的懒加载，例如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs JS&quot; lang=&quot;JS&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// router.js通过动态import来引入组件，其他&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Vue &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;vue&#39;&lt;/span&gt;;
&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Router &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;vue-router&#39;&lt;/span&gt;;
&lt;span class=&quot;hljs-comment&quot;&gt;// 这里用组件home来做例子&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Home = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&#39;./views/Home/Home.vue&#39;&lt;/span&gt;);

Vue.use(Router);

&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Router({
  &lt;span class=&quot;hljs-attr&quot;&gt;routes&lt;/span&gt;: [
    {
      &lt;span class=&quot;hljs-attr&quot;&gt;path&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&#39;/&#39;&lt;/span&gt;,
      &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&#39;Home&#39;&lt;/span&gt;,
      &lt;span class=&quot;hljs-attr&quot;&gt;component&lt;/span&gt;: Home,
  ],
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就可以对我们的路由组件进行懒加载了，你会发现我们的代码会按组件为单位打包成了多个js文件。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-7&quot;&gt;将项目升级为 pwa&lt;/h2&gt;
&lt;p&gt;在我们的项目基本成型之后，可以考虑将其升级为pwa了。关于pwa是什么，我相信大家都知道，这玩意在国外已经火了几百年了，但国内除了几家大公司，貌似没多少人去尝试它，不过在上一年开始，pwa在国内还是热了一下的。pwa是我们在追求webapp便捷和原生应用良好体验结合的过程中的产物，目前兼容性是最大障碍，但相信它在国内的前景还是明朗的。pwa的特性有可离线、添加到桌面（一级入口）、后台同步、服务端推送等等，这个项目的话实现了可离线和添加到桌面这两个功能。起初听闻pwa时以为会很复杂，实践后发现很简单。&lt;/p&gt;
&lt;p&gt;ps: 开发过程在控制台的Application中可调试对应内容&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165f7ec4f7179c2c~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-8&quot;&gt;workbox&lt;/h3&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ftools%2Fworkbox%2F&quot; title=&quot;https://developers.google.com/web/tools/workbox/&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;workbox&lt;/a&gt; 是pwa的一个工具集合，围绕它的还有一些列工具，如 workbox-cli、gulp-workbox、workbox-webpack-plagin 等等，workbox本身相当于&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fprimers%2Fservice-workers%2F&quot; title=&quot;https://developers.google.com/web/fundamentals/primers/service-workers/&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;service worker&lt;/a&gt;的一个框架，封装了各种api，和缓存策略，可以让我们更加便捷的使用service worker。vue-cli3.0集成的是workbox-webpack-plagin，我们可以通过vue.config.js的pwa配置项进行配置
首先，在vue.config.js文件中的进行配置，更详细的&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue-cli%2Ftree%2Fdev%2Fpackages%2F%2540vue%2Fcli-plugin-pwa&quot; title=&quot;https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;配置项&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;// vue.config.js

module.exports = {
  pwa: {
    // 一些基础配置
    name: &lt;span class=&quot;hljs-string&quot;&gt;&#39;Browsing-Exp&#39;&lt;/span&gt;,
    themeColor: &lt;span class=&quot;hljs-string&quot;&gt;&#39;#6476DB&#39;&lt;/span&gt;,
    msTileColor: &lt;span class=&quot;hljs-string&quot;&gt;&#39;#000000&#39;&lt;/span&gt;,
    appleMobileWebAppCapable: &lt;span class=&quot;hljs-string&quot;&gt;&#39;yes&#39;&lt;/span&gt;,
    appleMobileWebAppStatusBarStyle: &lt;span class=&quot;hljs-string&quot;&gt;&#39;black&#39;&lt;/span&gt;,

/*
* 两个模式，GenerateSW（默认）和 InjectManifest
* GenerateSW 在我们build项目时候，每次都会新建一个service worker文件
* InjectManifest 可以让我们编辑一个自定义的service worker文件，实现更多的功能，并且可以
* 拿到预缓存列表
*/
    workboxPluginMode: &lt;span class=&quot;hljs-string&quot;&gt;&#39;InjectManifest&#39;&lt;/span&gt;,
    workboxOptions: {
      // 自定义的service worker文件的位置
      swSrc: &lt;span class=&quot;hljs-string&quot;&gt;&#39;src/service-worker.js&#39;&lt;/span&gt;,
      // ...other Workbox options...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们需要在src文件目录下面新建一个service-worker.js，这里拿此项目做例子，workbox的常用接口有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;workbox.precaching 对静态支援进行缓存&lt;/li&gt;
&lt;li&gt;workbox.routing 进行路由控制&lt;/li&gt;
&lt;li&gt;workbox.strategies 提供缓存策略&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更详细的 &lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ftools%2Fworkbox%2Fmodules%2Fworkbox-webpack-plugin&quot; title=&quot;https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;接口和配置教程&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;// src/service-worker.js

// 设置相应缓存的名字的前缀和后缀
workbox.core.setCacheNameDetails({
  prefix: &lt;span class=&quot;hljs-string&quot;&gt;&#39;browse-exp&#39;&lt;/span&gt;,
  suffix: &lt;span class=&quot;hljs-string&quot;&gt;&#39;v1.0.0&#39;&lt;/span&gt;,
});
// 让我们的service worker尽快的得到更新和获取页面的控制权
workbox.skipWaiting();
workbox.clientsClaim();

/*
* vue-cli3.0通过workbox-webpack-plagin 来实现相关功能，我们需要加入
* 以下语句来获取预缓存列表和预缓存他们，也就是打包项目后生产的html，js，css等* 静态文件
*/
workbox.precaching.precacheAndRoute(self.__precacheManifest || []);

// 对我们请求的数据进行缓存，这里采用 networkFirst 策略
workbox.routing.registerRoute(
  new RegExp(&lt;span class=&quot;hljs-string&quot;&gt;&#39;.*experiments\?.*&#39;&lt;/span&gt;), 
  workbox.strategies.networkFirst()
);
workbox.routing.registerRoute(
  new RegExp(&lt;span class=&quot;hljs-string&quot;&gt;&#39;.*experiments/\\d&#39;&lt;/span&gt;),
  workbox.strategies.networkFirst()  
)
workbox.routing.registerRoute(
  new RegExp(&lt;span class=&quot;hljs-string&quot;&gt;&#39;.*experiment_types.*&#39;&lt;/span&gt;),
  workbox.strategies.networkFirst()
)

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这里，首先通过&lt;code&gt;workbox.precaching.precacheAndRoute&lt;/code&gt;配置app shell的预缓存，然后就是通过&lt;code&gt;workbox.routing.registerRoute&lt;/code&gt;对请求数据的缓存，因为对于请求的数据有一定的实时性要求，所以采用网络优先策略 networkFirst ，这里随便提一下相关的策略：&lt;/p&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-9&quot;&gt;networkFirst&lt;/h4&gt;
&lt;p&gt;网络优先策略，优先尝试通过网络请求来获取数据，拿到数据后将数据返回给用户，并更新缓存，获取数据失败就使用缓存中的数据。&lt;/p&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-10&quot;&gt;cacheFirst&lt;/h4&gt;
&lt;p&gt;缓存优先策略，优先获取缓存中的资源，如果缓存中没有相关资源，那么就发起网络请求。&lt;/p&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-11&quot;&gt;networkOnly&lt;/h4&gt;
&lt;p&gt;顾名思义，只使用网络请求获取的资源&lt;/p&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-12&quot;&gt;cacheOnly&lt;/h4&gt;
&lt;p&gt;顾名思义，只使用缓存中的资源&lt;/p&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-13&quot;&gt;stateWhileRevalidate&lt;/h4&gt;
&lt;p&gt;此策略会直接返回缓存中的资源，确保获取资源的速度，然后再发起网络请求获取数据去更新缓存中的资源。如果缓存中没有对应资源的话就会发起网络请求，并缓存资源。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-14&quot;&gt;如何查看效果呢&lt;/h3&gt;
&lt;p&gt;这些配置可以让我们的得以在离线环境下运行，但是这些配置都是相对于打包出来的项目文件的，也就是dist文件里的内容。我们在开发过程的dev模式是体验不到效果的，我们怎么查看效果呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方案1：编写一个后台服务，我们可以通过node.js等编写一个后台服务去访问我们的应用，service worker本来需要在https环境下运行，但是如果是本地 localhost 环境的话，service worker可以在http协议上运行。&lt;/li&gt;
&lt;li&gt;方案2：借助google提供的chrome扩展应用&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Fweb-server-for-chrome%2Fofhbbkphhbklhfoeikjpcbhemlocgigb&quot; title=&quot;https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;Web Server for Chrome&lt;/a&gt;为我们的应用启动一个服务，比较灵活，所以我采用了这种方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-15&quot;&gt;Web Server for Chrome&lt;/h4&gt;
&lt;p&gt;点击&lt;code&gt;choose foloer&lt;/code&gt;选择我们的dist文件夹，勾选&lt;code&gt;Automatically show index.html&lt;/code&gt;开启服务，我们就可以通过下面的链接访问应用了，通过勾选&lt;code&gt;Accessible on local network&lt;/code&gt;还可以生成另一个地址，可以让我们在手机端访问应用。
&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;webserver1&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165f7ec5691f72fb~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;webserver2&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165f7ec583c890fa~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-16&quot;&gt;manifest.json 网络应用清单&lt;/h3&gt;
&lt;p&gt;manifest.json 提供了将webapp 添加到设备主屏幕的功能，更详细的&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fweb-app-manifest%2F&quot; title=&quot;https://developers.google.com/web/fundamentals/web-app-manifest/&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;配置内容&lt;/a&gt;在此查看。我们可以通过它给我们的应用设置图标，启动动画，背景颜色等等。它在我们项目的public下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs JSON&quot; lang=&quot;JSON&quot;&gt;// public/manifest.json
// 最基本的配置内容

{
  &quot;name&quot;: &quot;浏览我们的实验吧！&quot;,
  &quot;short_name&quot;: &quot;BrowseExp&quot;,
  &quot;icons&quot;: [
    {
      &quot;src&quot;: &quot;/img/icons/icon-192x192.png&quot;,
      &quot;sizes&quot;: &quot;192x192&quot;,
      &quot;type&quot;: &quot;image/png&quot;
    },
    {
      &quot;src&quot;: &quot;/img/icons/icon-512x512.png&quot;,
      &quot;sizes&quot;: &quot;512x512&quot;,
      &quot;type&quot;: &quot;image/png&quot;
    }
  ],
  &quot;start_url&quot;: &quot;/index.html&quot;,
  &quot;display&quot;: &quot;standalone&quot;,
  &quot;background_color&quot;: &quot;#000000&quot;,
  &quot;theme_color&quot;: &quot;#4DBA87&quot;
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当浏览器（支持此功能的浏览器）检测到目录中的manifest.json文件时，就会读取其中的内容。在适当的时机弹出询问框，询问是否将应用添加到桌面。注意它不会在第一次访问就弹出，而是发现用户在一定时间内多次访问该网站时才会弹出。在开发过程中我们可以点击Application -&amp;gt; Manifest -&amp;gt; Add to homescreen 触发弹框弹出。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-17&quot;&gt;移动端其他小问题&lt;/h2&gt;
&lt;p&gt;作为移动端web app，我们需要解决一些常见的小问题，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;各浏览器间样式统一问题&lt;/li&gt;
&lt;li&gt;移动端点击300ms延迟问题&lt;/li&gt;
&lt;li&gt;点透事件&lt;/li&gt;
&lt;li&gt;rem的运用&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-18&quot;&gt;1.各浏览器间样式统一问题&lt;/h4&gt;
&lt;p&gt;常见做法就是引入&lt;code&gt;normalize.css&lt;/code&gt;重置我们设备的默认样式，使得各浏览器的默认样式高度一致，避免我们的布局出现意想不到的情况。&lt;/p&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-19&quot;&gt;2.点击300ms延迟和点透事件&lt;/h4&gt;
&lt;p&gt;因为我们的移动端的浏览器需要判断用户是否想要双击放大，所以会有一个300ms的延迟来查看用户是否双击屏幕；点透事件就是当我们混用touch和click事件的时候，在touch事件响应后，如果该元素隐藏掉，那么300ms后同一位置的底层元素的click事件就会被触发。对于它们常用的解决方法就是引入 &lt;code&gt;fastclick.js&lt;/code&gt;，这个库的原理就是：修改浏览器的touch事件来模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。让前端开发人员可以以熟悉的click来书写代码&lt;/p&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-20&quot;&gt;3.rem的运用&lt;/h4&gt;
&lt;p&gt;移动端我们常常会使用到rem来进行响应式的布局，我们通常会将&lt;code&gt;html&lt;/code&gt;的&lt;code&gt;font-size&lt;/code&gt;设置为 &lt;code&gt;62.5%&lt;/code&gt;，那么我们的 1rem = 10px，便于我们的单位转换。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-21&quot;&gt;项目部署&lt;/h2&gt;
&lt;p&gt;开发完毕后，就需要把我们的项目部署到自己的服务器上面去&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-22&quot;&gt;编写一个服务&lt;/h3&gt;
&lt;p&gt;首先我们编写一个后端服务，让我们可以访问到项目的index.html文件，这里采用express起个服务。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;// browse-exp.js
const fs = require(&lt;span class=&quot;hljs-string&quot;&gt;&#39;fs&#39;&lt;/span&gt;)
const path = require(&lt;span class=&quot;hljs-string&quot;&gt;&#39;path&#39;&lt;/span&gt;)
const express = require(&lt;span class=&quot;hljs-string&quot;&gt;&#39;express&#39;&lt;/span&gt;)

const app = express();

app.use(express.static(path.resolve(__dirname, &lt;span class=&quot;hljs-string&quot;&gt;&#39;./dist&#39;&lt;/span&gt;)))
app.get(&lt;span class=&quot;hljs-string&quot;&gt;&#39;*&#39;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(req, res) {
  const html = fs.readFileSync(path.resolve(__dirname, &lt;span class=&quot;hljs-string&quot;&gt;&#39;./dist/index.html&#39;&lt;/span&gt;), &lt;span class=&quot;hljs-string&quot;&gt;&#39;utf-8&#39;&lt;/span&gt;)
  res.send(html)
})

app.listen(3002, &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;() {
  console.log(&lt;span class=&quot;hljs-string&quot;&gt;&#39;server listening on port 3002!&#39;&lt;/span&gt;)
})

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后将项目通过比如ftp等工具上传到服务器，我用的服务器是nginx，它的特点就是轻量级，高并发，可配置反向代理。然后需要配置个代理将我们对服务器的访问代理到该项目。在&lt;code&gt;etc/nginx/conf.d&lt;/code&gt;目录下创建我们的配置文件 &lt;code&gt;holyzheng-top-3002.conf&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# etc/nginx/conf.d/holyzheng-top-3002.conf&lt;/span&gt;

&lt;span class=&quot;hljs-comment&quot;&gt;# 实例，代表我们的应用&lt;/span&gt;
upstream browseexp {
  server 127.0.0.1:3002; 
}
&lt;span class=&quot;hljs-comment&quot;&gt;# 将以http协议对我们项目的访问转到https协议&lt;/span&gt;
server {
  listen 80; &lt;span class=&quot;hljs-comment&quot;&gt;# http监听的端口&lt;/span&gt;
  server_name browseexp.holyzheng.top; &lt;span class=&quot;hljs-comment&quot;&gt;# 我要使用的ip域名&lt;/span&gt;
  error_page 405 =200 @405; &lt;span class=&quot;hljs-comment&quot;&gt;# 允许对静态资源进行POST请求&lt;/span&gt;
  location @405 {
    proxy_pass http://browseexp;
  }
  rewrite ^(.*) https://&lt;span class=&quot;hljs-variable&quot;&gt;$host&lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$1&lt;/span&gt; permanent;
}

&lt;span class=&quot;hljs-comment&quot;&gt;# 配置代理，将对域名browseexp.holyzheng.top的访问代理到服务端的127.0.0.1:3002&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;# 也就是我们的应用&lt;/span&gt;
server {
  listen 443;
  server_name browseexp.holyzheng.top;
&lt;span class=&quot;hljs-comment&quot;&gt;# 跟证书有关的配置，在申请证书的时候会有提示这部分配置&lt;/span&gt;
  ssl on;
  ssl_certificate /etc/nginx/cert/1538045542271.pem;
  ssl_certificate_key /etc/nginx/cert/1538045542271.key;
  ssl_session_timeout 5m;
  ssl_protocols SSLv2 SSLv3 TLSv1;
  ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
  ssl_prefer_server_ciphers on;

  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-variable&quot;&gt;$ssl_protocol&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;) { &lt;span class=&quot;hljs-comment&quot;&gt;# 判断用户是否输入协议&lt;/span&gt;
    rewrite ^(.*) https://&lt;span class=&quot;hljs-variable&quot;&gt;$host&lt;/span&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$1&lt;/span&gt; permanent;
  }

  location / {
    proxy_set_header X-Real-IP &lt;span class=&quot;hljs-variable&quot;&gt;$remote_addr&lt;/span&gt;;
    proxy_set_header X-Forward-For &lt;span class=&quot;hljs-variable&quot;&gt;$proxy_add_x_forwarded_for&lt;/span&gt;;

    proxy_set_header Host &lt;span class=&quot;hljs-variable&quot;&gt;$http_host&lt;/span&gt;;
    proxy_set_header X-Nginx-Proxy &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;

    proxy_pass http://browseexp; &lt;span class=&quot;hljs-comment&quot;&gt;# 要代理的实例&lt;/span&gt;
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样我们就可以通过对于域名来访问了来访问该项目了。这里给出对应二维码，可以进行访问查看：&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;qrcore&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165f7ec5c5b7377c~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;下面是在安卓端UC浏览器访问的结果（UC对pwa的支持十分好），在几次访问我们的应用后就弹出了相关的提示，点击“好的”就可以添加到主屏幕了。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;pwademo1&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165f7ec5c3d79026~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-23&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;我非常享受尝试新事物（自己没做过）的这个过程，这次记录下来并分享给大家，希望对大家有帮助，如果大家看后有什么补充或意见的话，欢迎评论区提出。项目地址：&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FHolyZheng%2FBrowseExp&quot; title=&quot;https://github.com/HolyZheng/BrowseExp&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;browse-Exp&lt;/a&gt;&lt;/p&gt;
</description><link>https://juejin.cn/post/6844903682618687496</link><guid isPermaLink="false">https://juejin.cn/post/6844903682618687496</guid><pubDate>Thu, 20 Sep 2018 17:02:55 GMT</pubDate><author>holyZhengs</author><category>前端</category><category>Vue.js</category><category>TypeScript</category><category>PWA</category><category>服务器</category></item><item><title>Javascript装饰器的妙用</title><description>&lt;p&gt;最近新开了一个Node项目，采用TypeScript来开发，在数据库及路由管理方面用了不少的装饰器，发觉这的确是一个好东西。&lt;br&gt;
装饰器是一个还处于草案中的特性，目前木有直接支持该语法的环境，但是可以通过 babel 之类的进行转换为旧语法来实现效果，所以在TypeScript中，可以放心的使用&lt;code&gt;@Decorator&lt;/code&gt;。&lt;/p&gt;

&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;什么是装饰器&lt;/h2&gt;
&lt;p&gt;装饰器是对类、函数、属性之类的一种装饰，可以针对其添加一些额外的行为。&lt;br&gt;
通俗的理解可以认为就是在原有代码外层包装了一层处理逻辑。&lt;br&gt;
个人认为装饰器是一种解决方案，而并非是狭义的&lt;code&gt;@Decorator&lt;/code&gt;，后者仅仅是一个语法糖罢了。&lt;/p&gt;
&lt;p&gt;装饰器在身边的例子随处可见，一个简单的例子，水龙头上边的起泡器就是一个装饰器，在装上以后就会把空气混入水流中，掺杂很多泡泡在水里。&lt;br&gt;
但是起泡器安装与否对水龙头本身并没有什么影响，即使拆掉起泡器，也会照样工作，水龙头的作用在于阀门的控制，至于水中掺不掺杂气泡则不是水龙头需要关心的。&lt;/p&gt;
&lt;p&gt;所以，对于装饰器，可以简单地理解为是非侵入式的行为修改。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;为什么要用装饰器&lt;/h2&gt;
&lt;p&gt;可能有些时候，我们会对传入参数的类型判断、对返回值的排序、过滤，对函数添加节流、防抖或其他的功能性代码，基于多个类的继承，各种各样的与函数逻辑本身无关的、重复性的代码。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;函数中的作用&lt;/h3&gt;
&lt;p&gt;可以想像一下，我们有一个工具类，提供了一个获取数据的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Model1&lt;/span&gt; &lt;/span&gt;{
  getData() {
    &lt;span class=&quot;hljs-comment&quot;&gt;// 此处省略获取数据的逻辑&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [{
      &lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,
      &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&#39;Niko&#39;&lt;/span&gt;
    }, {
      &lt;span class=&quot;hljs-attr&quot;&gt;id&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,
      &lt;span class=&quot;hljs-attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&#39;Bellic&#39;&lt;/span&gt;
    }]
  }
}

&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Model1().getData())     &lt;span class=&quot;hljs-comment&quot;&gt;// [ { id: 1, name: &#39;Niko&#39;}, { id: 2, name: &#39;Bellic&#39; } ]&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(Model1.prototype.getData()) &lt;span class=&quot;hljs-comment&quot;&gt;// [ { id: 1, name: &#39;Niko&#39;}, { id: 2, name: &#39;Bellic&#39; } ]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在我们想要添加一个功能，记录该函数执行的耗时。&lt;br&gt;
因为这个函数被很多人使用，在调用方添加耗时统计逻辑是不可取的，所以我们要在&lt;code&gt;Model1&lt;/code&gt;中进行修改：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs diff&quot; lang=&quot;diff&quot;&gt;class Model1 {
  getData() {
&lt;span class=&quot;hljs-addition&quot;&gt;+   let start = new Date().valueOf()&lt;/span&gt;
&lt;span class=&quot;hljs-addition&quot;&gt;+   try {&lt;/span&gt;
      // 此处省略获取数据的逻辑
      return [{
        id: 1,
        name: &#39;Niko&#39;
      }, {
        id: 2,
        name: &#39;Bellic&#39;
      }]
&lt;span class=&quot;hljs-addition&quot;&gt;+   } finally {&lt;/span&gt;
&lt;span class=&quot;hljs-addition&quot;&gt;+     let end = new Date().valueOf()&lt;/span&gt;
&lt;span class=&quot;hljs-addition&quot;&gt;+     console.log(`start: ${start} end: ${end} consume: ${end - start}`)&lt;/span&gt;
&lt;span class=&quot;hljs-addition&quot;&gt;+   }&lt;/span&gt;
  }
}

// start: XXX end: XXX consume: XXX
console.log(new Model1().getData())     // [ { id: 1, name: &#39;Niko&#39;}, { id: 2, name: &#39;Bellic&#39; } ]
// start: XXX end: XXX consume: XXX
console.log(Model1.prototype.getData()) // [ { id: 1, name: &#39;Niko&#39;}, { id: 2, name: &#39;Bellic&#39; } ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样在调用方法后我们就可以在控制台看到耗时的输出了。&lt;br&gt;
但是这样直接修改原函数代码有以下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;统计耗时的相关代码与函数本身逻辑并无一点关系，影响到了对原函数本身的理解，对函数结构造成了破坏性的修改&lt;/li&gt;
&lt;li&gt;如果后期还有更多类似的函数需要添加统计耗时的代码，在每个函数中都添加这样的代码显然是低效的，维护成本太高&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，为了让统计耗时的逻辑变得更加灵活，我们将创建一个新的工具函数，用来包装需要设置统计耗时的函数。&lt;br&gt;
通过将&lt;code&gt;Class&lt;/code&gt;与目标函数的&lt;code&gt;name&lt;/code&gt;传递到函数中，实现了通用的耗时统计：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;wrap&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;Model, key&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-comment&quot;&gt;// 获取Class对应的原型&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; target = Model.prototype

  &lt;span class=&quot;hljs-comment&quot;&gt;// 获取函数对应的描述符&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; descriptor = &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.getOwnPropertyDescriptor(target, key)

  &lt;span class=&quot;hljs-comment&quot;&gt;// 生成新的函数，添加耗时统计逻辑&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; log = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;...arg&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; start = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;().valueOf()
    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; descriptor.value.apply(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, arg) &lt;span class=&quot;hljs-comment&quot;&gt;// 调用之前的函数&lt;/span&gt;
    } &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {
      &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; end = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;().valueOf()
      &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-string&quot;&gt;`start: &lt;span class=&quot;hljs-subst&quot;&gt;${start}&lt;/span&gt; end: &lt;span class=&quot;hljs-subst&quot;&gt;${end}&lt;/span&gt; consume: &lt;span class=&quot;hljs-subst&quot;&gt;${end - start}&lt;/span&gt;`&lt;/span&gt;)
    }
  }

  &lt;span class=&quot;hljs-comment&quot;&gt;// 将修改后的函数重新定义到原型链上&lt;/span&gt;
  &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(target, key, {
    ...descriptor,
    &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: log      &lt;span class=&quot;hljs-comment&quot;&gt;// 覆盖描述符重的value&lt;/span&gt;
  })
}

wrap(Model1, &lt;span class=&quot;hljs-string&quot;&gt;&#39;getData&#39;&lt;/span&gt;)
wrap(Model2, &lt;span class=&quot;hljs-string&quot;&gt;&#39;getData&#39;&lt;/span&gt;)

&lt;span class=&quot;hljs-comment&quot;&gt;// start: XXX end: XXX consume: XXX&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Model1().getData())     &lt;span class=&quot;hljs-comment&quot;&gt;// [ { id: 1, name: &#39;Niko&#39;}, { id: 2, name: &#39;Bellic&#39; } ]&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// start: XXX end: XXX consume: XXX&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(Model2.prototype.getData()) &lt;span class=&quot;hljs-comment&quot;&gt;// [ { id: 1, name: &#39;Niko&#39;}, { id: 2, name: &#39;Bellic&#39; } ]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来，我们想控制其中一个&lt;code&gt;Model&lt;/code&gt;的函数不可被其他人修改覆盖，所以要添加一些新的逻辑：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;wrap&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;Model, key&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-comment&quot;&gt;// 获取Class对应的原型&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; target = Model.prototype

  &lt;span class=&quot;hljs-comment&quot;&gt;// 获取函数对应的描述符&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; descriptor = &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.getOwnPropertyDescriptor(target, key)

  &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(target, key, {
    ...descriptor,
    &lt;span class=&quot;hljs-attr&quot;&gt;writable&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;      &lt;span class=&quot;hljs-comment&quot;&gt;// 设置属性不可被修改&lt;/span&gt;
  })
}

wrap(Model1, &lt;span class=&quot;hljs-string&quot;&gt;&#39;getData&#39;&lt;/span&gt;)

Model1.prototype.getData = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// 无效&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出，两个&lt;code&gt;wrap&lt;/code&gt;函数中有不少重复的地方，而修改程序行为的逻辑，实际上依赖的是&lt;code&gt;Object.defineProperty&lt;/code&gt;中传递的三个参数。&lt;br&gt;
所以，我们针对&lt;code&gt;wrap&lt;/code&gt;在进行一次修改，将其变为一个通用类的转换：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;wrap&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;decorator&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;Model, key&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; target = Model.prototype
    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; dscriptor = &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.getOwnPropertyDescriptor(target, key)

    decorator(target, key, descriptor)
  }
}

&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; log = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;target, key, descriptor&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-comment&quot;&gt;// 将修改后的函数重新定义到原型链上&lt;/span&gt;
  &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(target, key, {
    ...descriptor,
    &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;...arg&lt;/span&gt;) &lt;/span&gt;{
      &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; start = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;().valueOf()
      &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; descriptor.value.apply(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, arg) &lt;span class=&quot;hljs-comment&quot;&gt;// 调用之前的函数&lt;/span&gt;
      } &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {
        &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; end = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;().valueOf()
        &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-string&quot;&gt;`start: &lt;span class=&quot;hljs-subst&quot;&gt;${start}&lt;/span&gt; end: &lt;span class=&quot;hljs-subst&quot;&gt;${end}&lt;/span&gt; consume: &lt;span class=&quot;hljs-subst&quot;&gt;${end - start}&lt;/span&gt;`&lt;/span&gt;)
      }
    }
  })
}

&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; seal = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;target, key, descriptor&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(target, key, {
    ...descriptor,
    &lt;span class=&quot;hljs-attr&quot;&gt;writable&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;
  })
}

&lt;span class=&quot;hljs-comment&quot;&gt;// 参数的转换处理&lt;/span&gt;
log = wrap(log)
seal = warp(seal)

&lt;span class=&quot;hljs-comment&quot;&gt;// 添加耗时统计&lt;/span&gt;
log(Model1, &lt;span class=&quot;hljs-string&quot;&gt;&#39;getData&#39;&lt;/span&gt;)
log(Model2, &lt;span class=&quot;hljs-string&quot;&gt;&#39;getData&#39;&lt;/span&gt;)

&lt;span class=&quot;hljs-comment&quot;&gt;// 设置属性不可被修改&lt;/span&gt;
seal(Model1, &lt;span class=&quot;hljs-string&quot;&gt;&#39;getData&#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到了这一步以后，我们就可以称&lt;code&gt;log&lt;/code&gt;和&lt;code&gt;seal&lt;/code&gt;为装饰器了，可以很方便的让我们对一些函数添加行为。&lt;br&gt;
而拆分出来的这些功能可以用于未来可能会有需要的地方，而不用重新开发一遍相同的逻辑。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;Class 中的作用&lt;/h3&gt;
&lt;p&gt;就像上边提到了，现阶段在JS中继承多个&lt;code&gt;Class&lt;/code&gt;是一件头疼的事情，没有直接的语法能够继承多个 Class。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;{ say () { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; } }
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;B&lt;/span&gt; &lt;/span&gt;{ hi () { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; } }
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;B&lt;/span&gt; &lt;/span&gt;{}        &lt;span class=&quot;hljs-comment&quot;&gt;// Error&lt;/span&gt;
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;B&lt;/span&gt; &lt;/span&gt;{} &lt;span class=&quot;hljs-comment&quot;&gt;// Error&lt;/span&gt;

&lt;span class=&quot;hljs-comment&quot;&gt;// 这样才是可以的&lt;/span&gt;
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;C&lt;/span&gt; &lt;/span&gt;{}
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; key &lt;span class=&quot;hljs-keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.getOwnPropertyNames(A.prototype)) {
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (key === &lt;span class=&quot;hljs-string&quot;&gt;&#39;constructor&#39;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;
  &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(C.prototype, key, &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.getOwnPropertyDescriptor(A.prototype, key))
}
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; key &lt;span class=&quot;hljs-keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.getOwnPropertyNames(B.prototype)) {
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (key === &lt;span class=&quot;hljs-string&quot;&gt;&#39;constructor&#39;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;
  &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(C.prototype, key, &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.getOwnPropertyDescriptor(B.prototype, key))
}

&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; c = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; C()
&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(c.say(), c.hi()) &lt;span class=&quot;hljs-comment&quot;&gt;// 1, 2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以，在&lt;code&gt;React&lt;/code&gt;中就有了一个&lt;code&gt;mixin&lt;/code&gt;的概念，用来将多个&lt;code&gt;Class&lt;/code&gt;的功能复制到一个新的&lt;code&gt;Class&lt;/code&gt;上。&lt;br&gt;
大致思路就是上边列出来的，但是这个&lt;code&gt;mixin&lt;/code&gt;是&lt;code&gt;React&lt;/code&gt;中内置的一个操作，我们可以将其转换为更接近装饰器的实现。&lt;br&gt;
在不修改原&lt;code&gt;Class&lt;/code&gt;的情况下，将其他&lt;code&gt;Class&lt;/code&gt;的属性复制过来：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;mixin&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;constructor&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;...args&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; arg &lt;span class=&quot;hljs-keyword&quot;&gt;of&lt;/span&gt; args) {
      &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; key &lt;span class=&quot;hljs-keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.getOwnPropertyNames(arg.prototype)) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (key === &lt;span class=&quot;hljs-string&quot;&gt;&#39;constructor&#39;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// 跳过构造函数&lt;/span&gt;
        &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(&lt;span class=&quot;hljs-keyword&quot;&gt;constructor&lt;/span&gt;.prototype, key, Object.getOwnPropertyDescriptor(arg.prototype, key))
      }
    }
  }
}

mixin(C)(A, B)

let c = new C()
console.log(c.say(), c.hi()) // 1, 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上，就是装饰器在函数、&lt;code&gt;Class&lt;/code&gt;上的实现方法（至少目前是的），但是草案中还有一颗特别甜的语法糖，也就是&lt;code&gt;@Decorator&lt;/code&gt;了。&lt;br&gt;
能够帮你省去很多繁琐的步骤来用上装饰器。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;@Decorator的使用方法&lt;/h2&gt;
&lt;p&gt;草案中的装饰器、或者可以说是TS实现的装饰器，将上边的两种进一步地封装，将其拆分成为更细的装饰器应用，目前支持以下几处使用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Class&lt;/li&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;li&gt;get set访问器&lt;/li&gt;
&lt;li&gt;实例属性、静态函数及属性&lt;/li&gt;
&lt;li&gt;函数参数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;@Decorator的语法规定比较简单，就是通过&lt;code&gt;@&lt;/code&gt;符号后边跟一个装饰器函数的引用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;@tag
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;{ 
  @method
  hi () {}
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;tag&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;constructor&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-keyword&quot;&gt;constructor&lt;/span&gt; === A) // true
}

function method(target) {
  &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(target.constructor === A, target === A.prototype) &lt;span class=&quot;hljs-comment&quot;&gt;// true, true&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数&lt;code&gt;tag&lt;/code&gt;与&lt;code&gt;method&lt;/code&gt;会在&lt;code&gt;class A&lt;/code&gt;定义的时候执行。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;@Decorator 在 Class 中的使用&lt;/h3&gt;
&lt;p&gt;该装饰器会在class定义前调用，如果函数有返回值，则会认为是一个新的构造函数来替代之前的构造函数。&lt;/p&gt;
&lt;p&gt;函数接收一个参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;constructor 之前的构造函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以针对原有的构造函数进行一些改造:&lt;/p&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-6&quot;&gt;新增一些属性&lt;/h4&gt;
&lt;p&gt;如果想要新增一些属性之类的，有两种方案可以选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个新的&lt;code&gt;class&lt;/code&gt;继承自原有&lt;code&gt;class&lt;/code&gt;，并添加属性&lt;/li&gt;
&lt;li&gt;针对当前&lt;code&gt;class&lt;/code&gt;进行修改&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后者的适用范围更窄一些，更接近mixin的处理方式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;@name
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;{
  sayHi() {
    &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-string&quot;&gt;`My name is: &lt;span class=&quot;hljs-subst&quot;&gt;${&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.name}&lt;/span&gt;`&lt;/span&gt;)
  }
}

&lt;span class=&quot;hljs-comment&quot;&gt;// 创建一个继承自Person的匿名类&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// 直接返回并替换原有的构造函数&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;name&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;constructor&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;constructor&lt;/span&gt; &lt;/span&gt;{
    name = &lt;span class=&quot;hljs-string&quot;&gt;&#39;Niko&#39;&lt;/span&gt;
  }
}

&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Person().sayHi()
&lt;/code&gt;&lt;/pre&gt;&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-7&quot;&gt;修改原有属性的描述符&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;@seal
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;{
  sayHi() {}
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;seal&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;constructor&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; descriptor = &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.getOwnPropertyDescriptor(&lt;span class=&quot;hljs-keyword&quot;&gt;constructor&lt;/span&gt;.prototype, &#39;sayHi&#39;)
  Object.defineProperty(&lt;span class=&quot;hljs-keyword&quot;&gt;constructor&lt;/span&gt;.prototype, &#39;sayHi&#39;, {
    ...descriptor,
    &lt;span class=&quot;hljs-attr&quot;&gt;writable&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;
  })
}

Person.prototype.sayHi = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// 无效&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-8&quot;&gt;使用闭包来增强装饰器的功能&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;在TS文档中被称为装饰器工厂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为&lt;code&gt;@&lt;/code&gt;符号后边跟的是一个函数的引用，所以对于mixin的实现，我们可以很轻易的使用闭包来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;{ say() { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; } }
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;B&lt;/span&gt; &lt;/span&gt;{ hi() { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; } }

@mixin(A, B)
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;C&lt;/span&gt; &lt;/span&gt;{ }

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;mixin&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;...args&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-comment&quot;&gt;// 调用函数返回装饰器实际应用的函数&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;constructor&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; arg &lt;span class=&quot;hljs-keyword&quot;&gt;of&lt;/span&gt; args) {
      &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; key &lt;span class=&quot;hljs-keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.getOwnPropertyNames(arg.prototype)) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (key === &lt;span class=&quot;hljs-string&quot;&gt;&#39;constructor&#39;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// 跳过构造函数&lt;/span&gt;
        &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(&lt;span class=&quot;hljs-keyword&quot;&gt;constructor&lt;/span&gt;.prototype, key, Object.getOwnPropertyDescriptor(arg.prototype, key))
      }
    }
  }
}

let c = new C()
console.log(c.say(), c.hi()) // 1, 2
&lt;/code&gt;&lt;/pre&gt;&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-9&quot;&gt;多个装饰器的应用&lt;/h4&gt;
&lt;p&gt;装饰器是可以同时应用多个的（不然也就失去了最初的意义）。&lt;br&gt;
用法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;@decorator1
@decorator2
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;/span&gt;{ }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行的顺序为&lt;code&gt;decorator2&lt;/code&gt; -&amp;gt; &lt;code&gt;decorator1&lt;/code&gt;，离&lt;code&gt;class&lt;/code&gt;定义最近的先执行。&lt;br&gt;
可以想像成函数嵌套的形式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;decorator1(decorator2(&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;/span&gt;{}))
&lt;/code&gt;&lt;/pre&gt;&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-10&quot;&gt;@Decorator 在 Class 成员中的使用&lt;/h3&gt;
&lt;p&gt;类成员上的 @Decorator 应该是应用最为广泛的一处了，函数，属性，&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;访问器，这几处都可以认为是类成员。&lt;br&gt;
在TS文档中被分为了&lt;code&gt;Method Decorator&lt;/code&gt;、&lt;code&gt;Accessor Decorator&lt;/code&gt;和&lt;code&gt;Property Decorator&lt;/code&gt;，实际上如出一辙。&lt;/p&gt;
&lt;p&gt;关于这类装饰器，会接收如下三个参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果装饰器挂载于静态成员上，则会返回构造函数，如果挂载于实例成员上则会返回类的原型&lt;/li&gt;
&lt;li&gt;装饰器挂载的成员名称&lt;/li&gt;
&lt;li&gt;成员的描述符，也就是&lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt;的返回值&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Property Decorator&lt;/code&gt;不会返回第三个参数，但是可以自己手动获取&lt;br&gt;
前提是静态成员，而非实例成员，因为装饰器都是运行在类创建时，而实例成员是在实例化一个类的时候才会执行的，所以没有办法获取对应的descriptor&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-11&quot;&gt;静态成员与实例成员在返回值上的区别&lt;/h4&gt;
&lt;p&gt;可以稍微明确一下，静态成员与实例成员的区别：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Model&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&quot;hljs-comment&quot;&gt;// 实例成员&lt;/span&gt;
  method1 () {}
  method2 = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {}

  &lt;span class=&quot;hljs-comment&quot;&gt;// 静态成员&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; method3 () {}
  &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; method4 = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;method1&lt;/code&gt;和&lt;code&gt;method2&lt;/code&gt;是实例成员，&lt;code&gt;method1&lt;/code&gt;存在于&lt;code&gt;prototype&lt;/code&gt;之上，而&lt;code&gt;method2&lt;/code&gt;只在实例化对象以后才有。&lt;br&gt;
作为静态成员的&lt;code&gt;method3&lt;/code&gt;和&lt;code&gt;method4&lt;/code&gt;，两者的区别在于是否可枚举描述符的设置，所以可以简单地认为，上述代码转换为ES5版本后是这样子的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Model&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-comment&quot;&gt;// 成员仅在实例化时赋值&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.method2 = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{}
}

&lt;span class=&quot;hljs-comment&quot;&gt;// 成员被定义在原型链上&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(Model.prototype, &lt;span class=&quot;hljs-string&quot;&gt;&#39;method1&#39;&lt;/span&gt;, {
  &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{}, 
  &lt;span class=&quot;hljs-attr&quot;&gt;writable&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, 
  &lt;span class=&quot;hljs-attr&quot;&gt;enumerable&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;,  &lt;span class=&quot;hljs-comment&quot;&gt;// 设置不可被枚举&lt;/span&gt;
  configurable: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;
})

&lt;span class=&quot;hljs-comment&quot;&gt;// 成员被定义在构造函数上，且是默认的可被枚举&lt;/span&gt;
Model.method4 = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{}

&lt;span class=&quot;hljs-comment&quot;&gt;// 成员被定义在构造函数上&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(Model, &lt;span class=&quot;hljs-string&quot;&gt;&#39;method3&#39;&lt;/span&gt;, {
  &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{}, 
  &lt;span class=&quot;hljs-attr&quot;&gt;writable&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, 
  &lt;span class=&quot;hljs-attr&quot;&gt;enumerable&lt;/span&gt;: &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;,  &lt;span class=&quot;hljs-comment&quot;&gt;// 设置不可被枚举&lt;/span&gt;
  configurable: &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出，只有&lt;code&gt;method2&lt;/code&gt;是在实例化时才赋值的，一个不存在的属性是不会有&lt;code&gt;descriptor&lt;/code&gt;的，所以这就是为什么TS在针对&lt;code&gt;Property Decorator&lt;/code&gt;不传递第三个参数的原因，至于为什么静态成员也没有传递&lt;code&gt;descriptor&lt;/code&gt;，目前没有找到合理的解释，但是如果明确的要使用，是可以手动获取的。&lt;/p&gt;
&lt;p&gt;就像上述的示例，我们针对四个成员都添加了装饰器以后，&lt;code&gt;method1&lt;/code&gt;和&lt;code&gt;method2&lt;/code&gt;第一个参数就是&lt;code&gt;Model.prototype&lt;/code&gt;，而&lt;code&gt;method3&lt;/code&gt;和&lt;code&gt;method4&lt;/code&gt;的第一个参数就是&lt;code&gt;Model&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Model&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&quot;hljs-comment&quot;&gt;// 实例成员&lt;/span&gt;
  @instance
  method1 () {}
  @instance
  method2 = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {}

  &lt;span class=&quot;hljs-comment&quot;&gt;// 静态成员&lt;/span&gt;
  @&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; method3 () {}
  @&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; method4 = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {}
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;instance&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;target&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(target.constructor === Model)
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;static&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;target&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(target === Model)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-12&quot;&gt;函数，访问器，和属性装饰器三者之间的区别&lt;/h3&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-13&quot;&gt;函数&lt;/h4&gt;
&lt;p&gt;首先是函数，函数装饰器的返回值会默认作为属性的&lt;code&gt;value&lt;/code&gt;描述符存在，如果返回值为&lt;code&gt;undefined&lt;/code&gt;则会忽略，使用之前的&lt;code&gt;descriptor&lt;/code&gt;引用作为函数的描述符。&lt;br&gt;
所以针对我们最开始的统计耗时的逻辑可以这么来做：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Model&lt;/span&gt; &lt;/span&gt;{
  @log1
  getData1() {}
  @log2
  getData2() {}
}

&lt;span class=&quot;hljs-comment&quot;&gt;// 方案一，返回新的value描述符&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;log1&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;tag, name, descriptor&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {
    ...descriptor,
    value(...args) {
      &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; start = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;().valueOf()
      &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; descriptor.value.apply(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, args)
      } &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {
        &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; end = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;().valueOf()
        &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-string&quot;&gt;`start: &lt;span class=&quot;hljs-subst&quot;&gt;${start}&lt;/span&gt; end: &lt;span class=&quot;hljs-subst&quot;&gt;${end}&lt;/span&gt; consume: &lt;span class=&quot;hljs-subst&quot;&gt;${end - start}&lt;/span&gt;`&lt;/span&gt;)
      }
    }
  }
}

&lt;span class=&quot;hljs-comment&quot;&gt;// 方案二、修改现有描述符&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;log2&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;tag, name, descriptor&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; func = descriptor.value &lt;span class=&quot;hljs-comment&quot;&gt;// 先获取之前的函数&lt;/span&gt;

  &lt;span class=&quot;hljs-comment&quot;&gt;// 修改对应的value&lt;/span&gt;
  descriptor.value = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;...args&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; start = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;().valueOf()
    &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; func.apply(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, args)
    } &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {
      &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; end = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;().valueOf()
      &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-string&quot;&gt;`start: &lt;span class=&quot;hljs-subst&quot;&gt;${start}&lt;/span&gt; end: &lt;span class=&quot;hljs-subst&quot;&gt;${end}&lt;/span&gt; consume: &lt;span class=&quot;hljs-subst&quot;&gt;${end - start}&lt;/span&gt;`&lt;/span&gt;)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-14&quot;&gt;访问器&lt;/h4&gt;
&lt;p&gt;访问器就是添加有&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;前缀的函数，用于控制属性的赋值及取值操作，在使用上与函数没有什么区别，甚至在返回值的处理上也没有什么区别。&lt;br&gt;
只不过我们需要按照规定设置对应的&lt;code&gt;get&lt;/code&gt;或者&lt;code&gt;set&lt;/code&gt;描述符罢了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Modal&lt;/span&gt; &lt;/span&gt;{
  _name = &lt;span class=&quot;hljs-string&quot;&gt;&#39;Niko&#39;&lt;/span&gt;

  @prefix
  get name() { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;._name }
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;prefix&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;target, name, descriptor&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {
    ...descriptor,
    get () {
      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;`wrap_&lt;span class=&quot;hljs-subst&quot;&gt;${&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;._name}&lt;/span&gt;`&lt;/span&gt;
    }
  }
}

&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Modal().name) &lt;span class=&quot;hljs-comment&quot;&gt;// wrap_Niko&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-15&quot;&gt;属性&lt;/h4&gt;
&lt;p&gt;对于属性的装饰器，是没有返回&lt;code&gt;descriptor&lt;/code&gt;的，并且装饰器函数的返回值也会被忽略掉，如果我们想要修改某一个静态属性，则需要自己获取&lt;code&gt;descriptor&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Modal&lt;/span&gt; &lt;/span&gt;{
  @prefix
  &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; name1 = &lt;span class=&quot;hljs-string&quot;&gt;&#39;Niko&#39;&lt;/span&gt;
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;prefix&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;target, name&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; descriptor = &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.getOwnPropertyDescriptor(target, name)

  &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.defineProperty(target, name, {
    ...descriptor,
    &lt;span class=&quot;hljs-attr&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;`wrap_&lt;span class=&quot;hljs-subst&quot;&gt;${descriptor.value}&lt;/span&gt;`&lt;/span&gt;
  })
  
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; target
}

&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(Modal.name1) &lt;span class=&quot;hljs-comment&quot;&gt;// wrap_Niko&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于一个实例的属性，则没有直接修改的方案，不过我们可以结合着一些其他装饰器来曲线救国。&lt;/p&gt;
&lt;p&gt;比如，我们有一个类，会传入姓名和年龄作为初始化的参数，然后我们要针对这两个参数设置对应的格式校验：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; validateConf = {} &lt;span class=&quot;hljs-comment&quot;&gt;// 存储校验信息&lt;/span&gt;

@validator
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;{
  @validate(&lt;span class=&quot;hljs-string&quot;&gt;&#39;string&#39;&lt;/span&gt;)
  name
  @validate(&lt;span class=&quot;hljs-string&quot;&gt;&#39;number&#39;&lt;/span&gt;)
  age

  &lt;span class=&quot;hljs-keyword&quot;&gt;constructor&lt;/span&gt;(name, age) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.name = name
    &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.age = age
  }
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;validator&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;constructor&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;constructor&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;constructor&lt;/span&gt;(...args) {
      &lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt;(...args)

      &lt;span class=&quot;hljs-comment&quot;&gt;// 遍历所有的校验信息进行验证&lt;/span&gt;
      &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; [key, type] &lt;span class=&quot;hljs-keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.entries(validateConf)) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;[key] !== type) &lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Error&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;`&lt;span class=&quot;hljs-subst&quot;&gt;${key}&lt;/span&gt; must be &lt;span class=&quot;hljs-subst&quot;&gt;${type}&lt;/span&gt;`&lt;/span&gt;)
      }
    }
  }
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;validate&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;type&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;target, name, descriptor&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;hljs-comment&quot;&gt;// 向全局对象中传入要校验的属性名及类型&lt;/span&gt;
    validateConf[name] = type
  }
}

&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;hljs-string&quot;&gt;&#39;Niko&#39;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&#39;18&#39;&lt;/span&gt;)  &lt;span class=&quot;hljs-comment&quot;&gt;// throw new error: [age must be number]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先，在类上边添加装饰器&lt;code&gt;@validator&lt;/code&gt;，然后在需要校验的两个参数上添加&lt;code&gt;@validate&lt;/code&gt;装饰器，两个装饰器用来向一个全局对象传入信息，来记录哪些属性是需要进行校验的。&lt;br&gt;
然后在&lt;code&gt;validator&lt;/code&gt;中继承原有的类对象，并在实例化之后遍历刚才设置的所有校验信息进行验证，如果发现有类型错误的，直接抛出异常。&lt;br&gt;
这个类型验证的操作对于原&lt;code&gt;Class&lt;/code&gt;来说几乎是无感知的。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-16&quot;&gt;函数参数装饰器&lt;/h3&gt;
&lt;p&gt;最后，还有一个用于函数参数的装饰器，这个装饰器也是像实例属性一样的，没有办法单独使用，毕竟函数是在运行时调用的，而无论是何种装饰器，都是在声明类时（可以认为是伪编译期）调用的。&lt;/p&gt;
&lt;p&gt;函数参数装饰器会接收三个参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类似上述的操作，类的原型或者类的构造函数&lt;/li&gt;
&lt;li&gt;参数所处的函数名称&lt;/li&gt;
&lt;li&gt;参数在函数中形参中的位置（函数签名中的第几个参数）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个简单的示例，我们可以结合着函数装饰器来完成对函数参数的类型转换：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; parseConf = {}
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Modal&lt;/span&gt; &lt;/span&gt;{
  @parseFunc
  addOne(@parse(&lt;span class=&quot;hljs-string&quot;&gt;&#39;number&#39;&lt;/span&gt;) num) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; num + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
  }
}

&lt;span class=&quot;hljs-comment&quot;&gt;// 在函数调用前执行格式化操作&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;parseFunc&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;target, name, descriptor&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {
    ...descriptor,
    value (...arg) {
      &lt;span class=&quot;hljs-comment&quot;&gt;// 获取格式化配置&lt;/span&gt;
      &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; [index, type] &lt;span class=&quot;hljs-keyword&quot;&gt;of&lt;/span&gt; parseConf) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;switch&lt;/span&gt; (type) {
          &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;number&#39;&lt;/span&gt;:  arg[index] = &lt;span class=&quot;hljs-built_in&quot;&gt;Number&lt;/span&gt;(arg[index])             &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;
          &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;string&#39;&lt;/span&gt;:  arg[index] = &lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;(arg[index])             &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;
          &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;boolean&#39;&lt;/span&gt;: arg[index] = &lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;(arg[index]) === &lt;span class=&quot;hljs-string&quot;&gt;&#39;true&#39;&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;
        }
      }

      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; descriptor.value.apply(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, arg)
    }
  }
}

&lt;span class=&quot;hljs-comment&quot;&gt;// 向全局对象中添加对应的格式化信息&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;parse&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;type&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;target, name, index&lt;/span&gt;) &lt;/span&gt;{
    parseConf[index] = type
  }
}

&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Modal().addOne(&lt;span class=&quot;hljs-string&quot;&gt;&#39;10&#39;&lt;/span&gt;)) &lt;span class=&quot;hljs-comment&quot;&gt;// 11&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-17&quot;&gt;使用装饰器实现一个有趣的Koa封装&lt;/h2&gt;
&lt;p&gt;比如在写Node接口时，可能是用的&lt;code&gt;koa&lt;/code&gt;或者&lt;code&gt;express&lt;/code&gt;，一般来说可能要处理很多的请求参数，有来自&lt;code&gt;headers&lt;/code&gt;的，有来自&lt;code&gt;body&lt;/code&gt;的，甚至有来自&lt;code&gt;query&lt;/code&gt;、&lt;code&gt;cookie&lt;/code&gt;的。&lt;br&gt;
所以很有可能在&lt;code&gt;router&lt;/code&gt;的开头数行都是这样的操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;router.get(&lt;span class=&quot;hljs-string&quot;&gt;&#39;/&#39;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;async&lt;/span&gt; (ctx, next) =&amp;gt; {
  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; id = ctx.query.id
  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; uid = ctx.cookies.get(&lt;span class=&quot;hljs-string&quot;&gt;&#39;uid&#39;&lt;/span&gt;)
  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; device = ctx.header[&lt;span class=&quot;hljs-string&quot;&gt;&#39;device&#39;&lt;/span&gt;]
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以及如果我们有大量的接口，可能就会有大量的&lt;code&gt;router.get&lt;/code&gt;、&lt;code&gt;router.post&lt;/code&gt;。&lt;br&gt;
以及如果要针对模块进行分类，可能还会有大量的&lt;code&gt;new Router&lt;/code&gt;的操作。&lt;/p&gt;
&lt;p&gt;这些代码都是与业务逻辑本身无关的，所以我们应该尽可能的简化这些代码的占比，而使用装饰器就能够帮助我们达到这个目的。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-18&quot;&gt;装饰器的准备&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 首先，我们要创建几个用来存储信息的全局List&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; routerList      = []
&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; controllerList  = []
&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; parseList       = []
&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; paramList       = []

&lt;span class=&quot;hljs-comment&quot;&gt;// 虽说我们要有一个能够创建Router实例的装饰器&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// 但是并不会直接去创建，而是在装饰器执行的时候进行一次注册&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Router&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;basename = &lt;span class=&quot;hljs-string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;constrcutor&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {
    routerList.push({
      constrcutor,
      basename
    })
  }
}

&lt;span class=&quot;hljs-comment&quot;&gt;// 然后我们在创建对应的Get Post请求监听的装饰器&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// 同样的，我们并不打算去修改他的任何属性，只是为了获取函数的引用&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Method&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;type&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;path&lt;/span&gt;) =&amp;gt;&lt;/span&gt; (target, name, descriptor) =&amp;gt; {
    controllerList.push({
      target,
      type,
      path,
      &lt;span class=&quot;hljs-attr&quot;&gt;method&lt;/span&gt;: name,
      &lt;span class=&quot;hljs-attr&quot;&gt;controller&lt;/span&gt;: descriptor.value
    })
  }
}

&lt;span class=&quot;hljs-comment&quot;&gt;// 接下来我们还需要用来格式化参数的装饰器&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Parse&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;type&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;target, name, index&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {
    parseList.push({
      target,
      type,
      &lt;span class=&quot;hljs-attr&quot;&gt;method&lt;/span&gt;: name,
      index
    })
  }
}

&lt;span class=&quot;hljs-comment&quot;&gt;// 以及最后我们要处理的各种参数的获取&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Param&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;position&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;key&lt;/span&gt;) =&amp;gt;&lt;/span&gt; (target, name, index) =&amp;gt; {
    paramList.push({
      target,
      key,
      position,
      &lt;span class=&quot;hljs-attr&quot;&gt;method&lt;/span&gt;: name,
      index
    })
  }
}

&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Body   = Param(&lt;span class=&quot;hljs-string&quot;&gt;&#39;body&#39;&lt;/span&gt;)
&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Header = Param(&lt;span class=&quot;hljs-string&quot;&gt;&#39;header&#39;&lt;/span&gt;)
&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Cookie = Param(&lt;span class=&quot;hljs-string&quot;&gt;&#39;cookie&#39;&lt;/span&gt;)
&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Query  = Param(&lt;span class=&quot;hljs-string&quot;&gt;&#39;query&#39;&lt;/span&gt;)
&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Get    = Method(&lt;span class=&quot;hljs-string&quot;&gt;&#39;get&#39;&lt;/span&gt;)
&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; Post   = Method(&lt;span class=&quot;hljs-string&quot;&gt;&#39;post&#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-19&quot;&gt;Koa服务的处理&lt;/h3&gt;
&lt;p&gt;上边是创建了所有需要用到的装饰器，但是也仅仅是把我们所需要的各种信息存了起来，而怎么利用这些装饰器则是下一步需要做的事情了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; routers = []

&lt;span class=&quot;hljs-comment&quot;&gt;// 遍历所有添加了装饰器的Class，并创建对应的Router对象&lt;/span&gt;
routerList.forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; { basename, constrcutor } = item
  &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; router = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Router({
    &lt;span class=&quot;hljs-attr&quot;&gt;prefix&lt;/span&gt;: basename
  })

  controllerList
    .filter(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;i&lt;/span&gt; =&amp;gt;&lt;/span&gt; i.target === constrcutor.prototype)
    .forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;controller&lt;/span&gt; =&amp;gt;&lt;/span&gt; {
      router[controller.type](controller.path, &lt;span class=&quot;hljs-keyword&quot;&gt;async&lt;/span&gt; (ctx, next) =&amp;gt; {
        &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; args = []
        &lt;span class=&quot;hljs-comment&quot;&gt;// 获取当前函数对应的参数获取&lt;/span&gt;
        paramList
          .filter( &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;param&lt;/span&gt; =&amp;gt;&lt;/span&gt; param.target === constrcutor.prototype &amp;amp;&amp;amp; param.method === controller.method )
          .map(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;param&lt;/span&gt; =&amp;gt;&lt;/span&gt; {
            &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; { index, key } = param
            &lt;span class=&quot;hljs-keyword&quot;&gt;switch&lt;/span&gt; (param.position) {
              &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;body&#39;&lt;/span&gt;:    args[index] = ctx.request.body[key] &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;
              &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;header&#39;&lt;/span&gt;:  args[index] = ctx.headers[key]      &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;
              &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;cookie&#39;&lt;/span&gt;:  args[index] = ctx.cookies.get(key)  &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;
              &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;query&#39;&lt;/span&gt;:   args[index] = ctx.query[key]        &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;
            }
          })

        &lt;span class=&quot;hljs-comment&quot;&gt;// 获取当前函数对应的参数格式化&lt;/span&gt;
        parseList
          .filter( &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;parse&lt;/span&gt; =&amp;gt;&lt;/span&gt; parse.target === constrcutor.prototype &amp;amp;&amp;amp; parse.method === controller.method )
          .map(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;parse&lt;/span&gt; =&amp;gt;&lt;/span&gt; {
            &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; { index } = parse
            &lt;span class=&quot;hljs-keyword&quot;&gt;switch&lt;/span&gt; (parse.type) {
              &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;number&#39;&lt;/span&gt;:  args[index] = &lt;span class=&quot;hljs-built_in&quot;&gt;Number&lt;/span&gt;(args[index])             &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;
              &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;string&#39;&lt;/span&gt;:  args[index] = &lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;(args[index])             &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;
              &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;boolean&#39;&lt;/span&gt;: args[index] = &lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;(args[index]) === &lt;span class=&quot;hljs-string&quot;&gt;&#39;true&#39;&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;
            }
          })

        &lt;span class=&quot;hljs-comment&quot;&gt;// 调用实际的函数，处理业务逻辑&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; results = controller.controller(...args)

        ctx.body = results
      })
    })

  routers.push(router.routes())
})

&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; app = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Koa()

app.use(bodyParse())
app.use(compose(routers))

app.listen(&lt;span class=&quot;hljs-number&quot;&gt;12306&lt;/span&gt;, () =&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-string&quot;&gt;&#39;server run as http://127.0.0.1:12306&#39;&lt;/span&gt;))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上边的代码就已经搭建出来了一个Koa的封装，以及包含了对各种装饰器的处理，接下来就是这些装饰器的实际应用了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; { Router, Get, Query, Parse } &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;../decorators&quot;&lt;/span&gt;

@Router(&lt;span class=&quot;hljs-string&quot;&gt;&#39;&#39;&lt;/span&gt;)
&lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;/span&gt;{
  @Get(&lt;span class=&quot;hljs-string&quot;&gt;&#39;/&#39;&lt;/span&gt;)
  index (@Parse(&lt;span class=&quot;hljs-string&quot;&gt;&#39;number&#39;&lt;/span&gt;) @Query(&lt;span class=&quot;hljs-string&quot;&gt;&#39;id&#39;&lt;/span&gt;) id: number) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {
      &lt;span class=&quot;hljs-attr&quot;&gt;code&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;,
      id,
      &lt;span class=&quot;hljs-attr&quot;&gt;type&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;typeof&lt;/span&gt; id
    }
  }

  @Post(&lt;span class=&quot;hljs-string&quot;&gt;&#39;/detail&#39;&lt;/span&gt;)
  detail (
    @Parse(&lt;span class=&quot;hljs-string&quot;&gt;&#39;number&#39;&lt;/span&gt;) @Query(&lt;span class=&quot;hljs-string&quot;&gt;&#39;id&#39;&lt;/span&gt;) id: number, 
    @Parse(&lt;span class=&quot;hljs-string&quot;&gt;&#39;number&#39;&lt;/span&gt;) @Body(&lt;span class=&quot;hljs-string&quot;&gt;&#39;age&#39;&lt;/span&gt;) age: number
  ) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {
      &lt;span class=&quot;hljs-attr&quot;&gt;code&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;,
      &lt;span class=&quot;hljs-attr&quot;&gt;age&lt;/span&gt;: age + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很轻易的就实现了一个&lt;code&gt;router&lt;/code&gt;的创建，路径、method的处理，包括各种参数的获取，类型转换。&lt;br&gt;
将各种非业务逻辑相关的代码统统交由装饰器来做，而函数本身只负责处理自身逻辑即可。&lt;br&gt;
这里有完整的代码：&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FJiasm%2Fnotebook%2Ftree%2Fmaster%2Flabs%2Fdemo%2Ftypescript%2Fkoa-decorators&quot; title=&quot;https://github.com/Jiasm/notebook/tree/master/labs/demo/typescript/koa-decorators&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;GitHub&lt;/a&gt;。安装依赖后&lt;code&gt;npm start&lt;/code&gt;即可看到效果。&lt;/p&gt;
&lt;p&gt;这样开发带来的好处就是，让代码可读性变得更高，在函数中更专注的做自己应该做的事情。&lt;br&gt;
而且装饰器本身如果名字起的足够好的好，也是在一定程度上可以当作文档注释来看待了（Java中有个类似的玩意儿叫做注解）。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-20&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;合理利用装饰器可以极大的提高开发效率，对一些非逻辑相关的代码进行封装提炼能够帮助我们快速完成重复性的工作，节省时间。&lt;br&gt;
但是糖再好吃，也不要吃太多，容易坏牙齿的，同样的滥用装饰器也会使代码本身逻辑变得扑朔迷离，如果确定一段代码不会在其他地方用到，或者一个函数的核心逻辑就是这些代码，那么就没有必要将它取出来作为一个装饰器来存在。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-21&quot;&gt;参考资料&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Fdecorators.html&quot; title=&quot;https://www.typescriptlang.org/docs/handbook/decorators.html&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;typescript | decorators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftypestack%2Frouting-controllers&quot; title=&quot;https://github.com/typestack/routing-controllers&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;koa示例的原版，简化代码便于举例&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-22&quot;&gt;One more thing&lt;/h3&gt;
&lt;p&gt;我司现在大量招人咯，前端、Node方向都有HC&lt;br&gt;
公司名：&lt;strong&gt;Blued&lt;/strong&gt;，坐标帝都朝阳双井&lt;br&gt;
主要技术栈是React，也会有机会玩ReactNative和Electron&lt;br&gt;
Node方向8.x版本+koa 新项目会以TS为主&lt;br&gt;
有兴趣的小伙伴可以联系我详谈：&lt;br&gt;
email: jiashunming@blued.com&lt;br&gt;
wechat: github_jiasm&lt;/p&gt;
</description><link>https://juejin.cn/post/6844903635168526343</link><guid isPermaLink="false">https://juejin.cn/post/6844903635168526343</guid><pubDate>Mon, 09 Jul 2018 01:28:14 GMT</pubDate><author>Jiasm</author><category>前端</category><category>Node.js</category><category>JavaScript</category><category>koa</category></item><item><title>React源码分析 - 事件机制</title><description>&lt;p&gt;React的事件机制还是很好玩的，其中模拟事件传递和利用document委托大部分事件的想法比较有意思。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;事件机制流程图&lt;/h3&gt;
&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img alt=&quot;event-react&quot; src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/2/26/161cdbf9593d78f9~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;代码分析&lt;/h3&gt;
&lt;p&gt;（代码仅包含涉及事件参数的部分）&lt;/p&gt;
&lt;p&gt;_updateDOMProperties是事件参数处理的入口，只要注意enqueuePutListener这个方法就好了，这是注册事件的入口函数。registrationNameModules变量保存事件类型和对应的方法的映射的一个对象，如图：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/2/26/161cdbf95a27460e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; alt=&quot;registrationnamemodules&quot; width=&quot;539&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;
&lt;/p&gt;
&lt;p&gt;这些映射的初始化的地方在《React源码分析 - 组件初次渲染》解释过了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;_updateDOMProperties: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;lastProps, nextProps, transaction&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; propKey;
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; styleName;
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; styleUpdates;
  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (propKey &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; lastProps) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;) {
      &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;;
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (registrationNameModules.hasOwnProperty(propKey)) {
      &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (lastProps[propKey]) {
        &lt;span class=&quot;hljs-comment&quot;&gt;// Only call deleteListener if there was a listener previously or&lt;/span&gt;
        &lt;span class=&quot;hljs-comment&quot;&gt;// else willDeleteListener gets called when there wasn&#39;t actually a&lt;/span&gt;
        &lt;span class=&quot;hljs-comment&quot;&gt;// listener (e.g., onClick={null})&lt;/span&gt;
        deleteListener(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, propKey);
      }
    }
  }
  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (propKey &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; nextProps) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; nextProp = nextProps[propKey];
    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; lastProp = propKey === STYLE ? &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;._previousStyleCopy : lastProps != &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt; ? lastProps[propKey] : &lt;span class=&quot;hljs-literal&quot;&gt;undefined&lt;/span&gt;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; lastProp == &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;) {
      &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;;
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (registrationNameModules.hasOwnProperty(propKey)) { &lt;span class=&quot;hljs-comment&quot;&gt;// 处理事件参数。&lt;/span&gt;
      &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (nextProp) {
        enqueuePutListener(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, propKey, nextProp, transaction); &lt;span class=&quot;hljs-comment&quot;&gt;// 注册事件，委托到属于的document上&lt;/span&gt;
      } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (lastProp) {
        deleteListener(&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;, propKey);
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;enqueuePutListener&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;listenTo&lt;/li&gt;
&lt;li&gt;putListener&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;enqueuePutListener&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;inst, registrationName, listener, transaction&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; containerInfo = inst._nativeContainerInfo;
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; doc = containerInfo._ownerDocument; &lt;span class=&quot;hljs-comment&quot;&gt;// 大部分的事件都被到对应的document上&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!doc) { &lt;span class=&quot;hljs-comment&quot;&gt;// ssr&lt;/span&gt;
    &lt;span class=&quot;hljs-comment&quot;&gt;// Server rendering.&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;;
  }
  listenTo(registrationName, doc);
  transaction.getReactMountReady().enqueue(putListener, {
    &lt;span class=&quot;hljs-attr&quot;&gt;inst&lt;/span&gt;: inst,
    &lt;span class=&quot;hljs-attr&quot;&gt;registrationName&lt;/span&gt;: registrationName,
    &lt;span class=&quot;hljs-attr&quot;&gt;listener&lt;/span&gt;: listener
  });
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;listenTo&lt;/strong&gt;是将事件委托到document的方法，大部分事件是委托到document上的。但是因为document上能够catch的事件类型的限制(&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fwww.w3.org%2FTR%2F2000%2FREC-DOM-Level-2-Events-20001113%2Fevents.html%23Events-DocumentEvent&quot; title=&quot;https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-DocumentEvent&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;Document Object Model Events&lt;/a&gt;)，不是所有的事件类型都委托到document，少部分是直接委托到元素本身上的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;putListener&lt;/strong&gt;将对应的类型的事件、事件的目标对象和事件触发时执行的方法添加到listenerBank对象中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;listenTo: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;registrationName, contentDocumentHandle&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; mountAt = contentDocumentHandle;
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; isListening = getListeningForDocument(mountAt);
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; topLevelTypes = EventConstants.topLevelTypes;
  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; dependencies.length; i++) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; dependency = dependencies[i];
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!(isListening.hasOwnProperty(dependency) &amp;amp;&amp;amp; isListening[dependency])) {
      &lt;span class=&quot;hljs-comment&quot;&gt;// 先判断先几个需要特殊处理的事件，主要都是兼容性的原因。&lt;/span&gt;
      &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (...) {
        ......
      } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (topEventMapping.hasOwnProperty(dependency)) {
        ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
      }
      isListening[dependency] = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;
    }
  }
}

&lt;span class=&quot;hljs-comment&quot;&gt;// 冒泡阶段的触发的事件的委托&lt;/span&gt;
trapBubbledEvent: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;topLevelType, handlerBaseName, handle&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
},

&lt;span class=&quot;hljs-comment&quot;&gt;// 捕获阶段的触发的事件的委托&lt;/span&gt;
trapCapturedEvent: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;topLevelType, handlerBaseName, handle&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
},

&lt;span class=&quot;hljs-attr&quot;&gt;trapBubbledEvent&lt;/span&gt;: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;topLevelType, handlerBaseName, handle&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;, topLevelType));
},

&lt;span class=&quot;hljs-attr&quot;&gt;trapCapturedEvent&lt;/span&gt;: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;topLevelType, handlerBaseName, handle&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;, topLevelType));
},

&lt;span class=&quot;hljs-attr&quot;&gt;listen&lt;/span&gt;: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;listen&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;target, eventType, callback&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (target.addEventListener) {
    target.addEventListener(eventType, callback, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);
  }
},

&lt;span class=&quot;hljs-attr&quot;&gt;capture&lt;/span&gt;: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;capture&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;target, eventType, callback&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (target.addEventListener) {
    target.addEventListener(eventType, callback, &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);
  }
},
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重点在于所有的委托的事件的回调函数都是ReactEventListener.dispatchEvent。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;dispatchEvent: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;topLevelType, nativeEvent&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-comment&quot;&gt;// bookKeeping的初始化使用了react在源码中用到的对象池的方法来避免多余的垃圾回收。&lt;/span&gt;
  &lt;span class=&quot;hljs-comment&quot;&gt;// bookKeeping的作用看ta的定义就知道了，就是一个用来保存过程中会使用到的变量的对象。&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
  &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
  } &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {
    TopLevelCallbackBookKeeping.release(bookKeeping);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;handleTopLevelImpl方法遍历事件触发对象以及其的父级元素（事件传递），对每个元素执行_handleTopLevel方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;handleTopLevelImpl&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;bookKeeping&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; ancestor = targetInst;
  &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt; {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor &amp;amp;&amp;amp; findParent(ancestor);
  } &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (ancestor);

  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;handleTopLevel根据事件对象以及触发的事件类型提取出所有需要被执行的事件以及对应的回调函数，统一由runEventQueueInBatch执行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;handleTopLevel: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;topLevelType, targetInst, nativeEvent, nativeEventTarget&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventQueueInBatch(events);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;extractEvents方法调用了对应的plugin的extractEvents方法来获取对应的plugin类型的需要执行的事件，然后accumulateInto到一起。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;extractEvents: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;topLevelType, targetInst, nativeEvent, nativeEventTarget&lt;/span&gt;) &lt;/span&gt;{
   &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; events;
   &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; plugins = EventPluginRegistry.plugins;
   &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; plugins.length; i++) {
     &lt;span class=&quot;hljs-comment&quot;&gt;// Not every plugin in the ordering may be loaded at runtime.&lt;/span&gt;
     &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; possiblePlugin = plugins[i];
     &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (possiblePlugin) {
       &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
       &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (extractedEvents) {
         events = accumulateInto(events, extractedEvents);
       }
     }
   }
   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; events;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;plugin的extractEvents方法中的有意思的地方在于 &lt;strong&gt;EventPropagators.accumulateTwoPhaseDispatches(event)&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;EventPropagators.accumulateTwoPhaseDispatches中模拟了事件传递的过程即：capture -&amp;gt; target -&amp;gt; bubble 的过程，将这个路径上的所有的符合事件类型的回调函数以及对应的元素按照事件传递的顺序返回。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/2/26/161cdbf95a3f8121~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;
&lt;/p&gt;
&lt;p&gt;（图片来自&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fwww.w3.org%2FTR%2FDOM-Level-3-Events%2F%23event-flow&quot; title=&quot;https://www.w3.org/TR/DOM-Level-3-Events/#event-flow&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;Event dispatch and DOM event flow&lt;/a&gt;）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;traverseTwoPhase&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;inst, fn, arg&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; path = [];
  &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (inst) {
    path.push(inst);
    inst = inst._nativeParent;
  }
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i;
  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (i = path.length; i-- &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;) {
    fn(path[i], &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;, arg);
  }
  &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; path.length; i++) {
    fn(path[i], &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, arg);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;traverseTwoPhase方法模拟了事件传递的过程并且获取对应的回调函数和事件对象保存在react合成的event对象的_dispatchListeners和_dispatchInstances上&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;accumulateDirectionalDispatches&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;inst, upwards, event&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; listener = listenerAtPhase(inst, event, phase);
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (listener) {
    &lt;span class=&quot;hljs-comment&quot;&gt;// event._dispatchListeners结果就是这个event在event flow的过程中会触发那些listenter的callback【按照event flow的顺序push到一个数组中了】&lt;/span&gt;
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询listener和对应的inst使用的是事件的类型以及_rootNodeID，listenerBank中保存了对应一个类型下元素的回调函数：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/2/26/161cdbf95a22ace2~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png&quot; alt=&quot;listenerBank&quot; width=&quot;200&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer&quot;&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;listenerAtPhase&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;inst, event, propagationPhase&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; getListener(inst, registrationName);
}

getListener: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;inst, registrationName&lt;/span&gt;) &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; bankForRegistrationName = listenerBank[registrationName];
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; bankForRegistrationName &amp;amp;&amp;amp; bankForRegistrationName[inst._rootNodeID];
  },
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于listenerBank内容的生成由之前说的第二个主要方法putListener完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;putListener&lt;/strong&gt; 使用事务的方式统一在ReactMountReady阶段执行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;putListener: &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;inst, registrationName, listener&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
  bankForRegistrationName[inst._rootNodeID] = listener;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在extractEvents了对应触发的事件类型的events后通过runEventQueueInBatch(events)将所有的合成事件放到事件队列里面，第二步是逐个执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javascript&quot; lang=&quot;javascript&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;runEventQueueInBatch&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;events&lt;/span&gt;) &lt;/span&gt;{
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue(&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;);
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;executeDispatchesInOrder&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;event, simulated&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; dispatchListeners = event._dispatchListeners;
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; dispatchInstances = event._dispatchInstances;
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span class=&quot;hljs-string&quot;&gt;&#39;production&#39;&lt;/span&gt;) {
    validateEventDispatches(event);
  }
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;Array&lt;/span&gt;.isArray(dispatchListeners)) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; dispatchListeners.length; i++) {
      &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (event.isPropagationStopped()) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;;
      }
      &lt;span class=&quot;hljs-comment&quot;&gt;// Listeners and Instances are two parallel arrays that are always in sync.&lt;/span&gt;
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;
  event._dispatchInstances = &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;executeDispatch&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;event, simulated, listener, inst&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; type = event.type || &lt;span class=&quot;hljs-string&quot;&gt;&#39;unknown-event&#39;&lt;/span&gt;;
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
  } &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;;
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;invokeGuardedCallback&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;name, func, a, b&lt;/span&gt;) &lt;/span&gt;{
  &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; func(a, b);
  } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (x) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (caughtError === &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;) {
      caughtError = x;
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;undefined&lt;/span&gt;;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;统一的分发函数dispatchEvent。&lt;/li&gt;
&lt;li&gt;React的事件对象是合成对象(SyntheticEvent)。&lt;/li&gt;
&lt;li&gt;几乎所有的事件都委托到document，达到性能优化的目的。&lt;/li&gt;
&lt;li&gt;合成事件与原生事件混用要注意React的事件基本都是委托到document。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考资料&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Fzhenhua-lee.github.io%2Freact%2Freact-event.html&quot; title=&quot;http://zhenhua-lee.github.io/react/react-event.html&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;React源码解读系列 – 事件机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fwww.w3.org%2FTR%2FDOM-Level-3-Events%2F%23ui-events-intro&quot; title=&quot;https://www.w3.org/TR/DOM-Level-3-Events/#ui-events-intro&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;UI Events&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fwww.w3.org%2FTR%2F2000%2FREC-DOM-Level-2-Events-20001113%2Fevents.html%23Events-EventTarget&quot; title=&quot;https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;Document Object Model Events&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><link>https://juejin.cn/post/6844903566801534990</link><guid isPermaLink="false">https://juejin.cn/post/6844903566801534990</guid><pubDate>Sun, 25 Feb 2018 16:16:45 GMT</pubDate><author>鼓延</author><category>前端</category><category>React.js</category><category>源码</category></item><item><title>VueJS 组件编码规范</title><description>&lt;p&gt;原文地址：&lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fpablohpsilva%2Fvuejs-component-style-guide%2Fblob%2Fmaster%2FREADME-CN.md%2523%2525E7%25259B%2525AE%2525E5%2525BD%252595&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=https%3A//github.com/pablohpsilva/vuejs-component-style-guide/blob/master/README-CN.md%23%25E7%259B%25AE%25E5%25BD%2595&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;pablohpsilva/vuejs-component-style-guide&lt;i&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 data-id=&quot;heading-0&quot;&gt;目标&lt;/h2&gt;
&lt;p&gt;本规范提供了一种统一的编码规范来编写 &lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2Fvuejs.org%2F&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=http%3A//vuejs.org/&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;Vue.js&lt;i&gt;&lt;/i&gt;&lt;/a&gt; 代码。这使得代码具有如下的特性：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;其它开发者或是团队成员更容易阅读和理解。&lt;/li&gt;
    &lt;li&gt;IDEs 更容易理解代码，从而提供高亮、格式化等辅助功能&lt;/li&gt;
    &lt;li&gt;更容易使用现有的工具&lt;/li&gt;
    &lt;li&gt;更容易实现缓存以及代码包的分拆&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本指南为 &lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fvoorhoede&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=https%3A//github.com/voorhoede&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;De Voorhoede&lt;i&gt;&lt;/i&gt;&lt;/a&gt; 参考 &lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fvoorhoede%2Friotjs-style-guide&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=https%3A//github.com/voorhoede/riotjs-style-guide&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;RiotJS 编码规范&lt;i&gt;&lt;/i&gt;&lt;/a&gt; 而写。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-1&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;
    &lt;li&gt;基于模块开发&lt;/li&gt;
    &lt;li&gt;vue 组件命名&lt;/li&gt;
    &lt;li&gt;组件表达式简单化&lt;/li&gt;
    &lt;li&gt;组件 props 原子化&lt;/li&gt;
    &lt;li&gt;验证组件的 props&lt;/li&gt;
    &lt;li&gt;将 this 赋值给 component 变量&lt;/li&gt;
    &lt;li&gt;组件结构化&lt;/li&gt;
    &lt;li&gt;组件事件命名&lt;/li&gt;
    &lt;li&gt;避免 this.$parent&lt;/li&gt;
    &lt;li&gt;谨慎使用 this.$refs&lt;/li&gt;
    &lt;li&gt;使用组件名作为样式作用域空间&lt;/li&gt;
    &lt;li&gt;提供组件 API 文档&lt;/li&gt;
    &lt;li&gt;提供组件 demo&lt;/li&gt;
    &lt;li&gt;对组件文件进行代码校验&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 data-id=&quot;heading-2&quot;&gt;基于模块开发&lt;/h2&gt;
&lt;p&gt;始终基于模块的方式来构建你的 app，每一个子模块只做一件事情。&lt;/p&gt;
&lt;p&gt;Vue.js 的设计初衷就是帮助开发者更好的开发界面模块。一个模块是应用程序中独立的一个部分。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-3&quot;&gt;怎么做？&lt;/h3&gt;
&lt;p&gt;每一个 Vue 组件(等同于模块)首先必须专注于解决一个单一的问题，&lt;em&gt;独立的&lt;/em&gt;, &lt;em&gt;可复用的&lt;/em&gt;, &lt;em&gt;微小的&lt;/em&gt; and &lt;em&gt;可测试的&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;如果你的组件做了太多的事或是变得臃肿，请将其拆分成更小的组件并保持单一的原则。一般来说，尽量保证每一个文件的代码行数不要超过 100 行。也请保证组件可独立的运行。比较好的做法是增加一个单独的 demo 示例。&lt;/p&gt;
&lt;p&gt;Vue 组件命名&lt;br&gt;&lt;/p&gt;
&lt;p&gt;组件的命名需遵从以下原则：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;有意义的: 不过于具体，也不过于抽象&lt;/li&gt;
    &lt;li&gt;简短: 2 到 3 个单词&lt;/li&gt;
    &lt;li&gt;具有可读性: 以便于沟通交流&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时还需要注意：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;必须符合自定义元素规范: &lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fwww.w3.org%2FTR%2Fcustom-elements%2F%2523concepts&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=https%3A//www.w3.org/TR/custom-elements/%23concepts&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;使用连字符&lt;i&gt;&lt;/i&gt;&lt;/a&gt;分隔单词，切勿使用保留字。&lt;/li&gt;
    &lt;li&gt;app- 前缀作为命名空间: 如果非常通用的话可使用一个单词来命名，这样可以方便于其它项目里复用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 data-id=&quot;heading-4&quot;&gt;为什么？&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;组件是通过组件名来调用的。所以组件名必须简短、富有含义并且具有可读性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 data-id=&quot;heading-5&quot;&gt;如何做？&lt;/h3&gt;&lt;br&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;!-- 推荐 --&amp;gt;
&amp;lt;app-header&amp;gt;&amp;lt;/app-header&amp;gt;
&amp;lt;user-list&amp;gt;&amp;lt;/user-list&amp;gt;
&amp;lt;range-slider&amp;gt;&amp;lt;/range-slider&amp;gt;

&amp;lt;!-- 避免 --&amp;gt;
&amp;lt;btn-group&amp;gt;&amp;lt;/btn-group&amp;gt; &amp;lt;!-- 虽然简短但是可读性差. 使用 `button-group` 替代 --&amp;gt;
&amp;lt;ui-slider&amp;gt;&amp;lt;/ui-slider&amp;gt; &amp;lt;!-- ui 前缀太过于宽泛，在这里意义不明确 --&amp;gt;
&amp;lt;slider&amp;gt;&amp;lt;/slider&amp;gt; &amp;lt;!-- 与自定义元素规范不兼容 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;组件表达式简单化&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Vue.js 的表达式是 100% 的 Javascript 表达式。这使得其功能性很强大，但也带来潜在的复杂性。因此，你应该尽量保持表达式的简单化。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-6&quot;&gt;为什么？&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;复杂的行内表达式难以阅读。&lt;/li&gt;
    &lt;li&gt;行内表达式是不能够通用的，这可能会导致重复编码的问题。&lt;/li&gt;
    &lt;li&gt;IDE 基本上不能识别行内表达式语法，所以使用行内表达式 IDE 不能提供自动补全和语法校验功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 data-id=&quot;heading-7&quot;&gt;怎么做？&lt;/h3&gt;
&lt;p&gt;如果你发现写了太多复杂并难以阅读的行内表达式，那么可以使用 method 或是 computed 属性来替代其功能。&lt;/p&gt;&lt;br&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;!-- 推荐 --&amp;gt;
&amp;lt;template&amp;gt;
    &amp;lt;h1&amp;gt;
        {{ `${year}-${month}` }}
    &amp;lt;/h1&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
  export default {
    computed: {
      month() {
        return this.twoDigits((new Date()).getUTCMonth() + 1);
      },
      year() {
        return (new Date()).getUTCFullYear();
      }
    },
    methods: {
      twoDigits(num) {
        return (&#39;0&#39; + num).slice(-2);
      }
    },
  };
&amp;lt;/script&amp;gt;

&amp;lt;!-- 避免 --&amp;gt;
&amp;lt;template&amp;gt;
    &amp;lt;h1&amp;gt;
        {{ `${(new Date()).getUTCFullYear()}-${(&#39;0&#39; + ((new Date()).getUTCMonth()+1)).slice(-2)}` }}
    &amp;lt;/h1&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;组件 props 原子化&lt;br&gt;&lt;/p&gt;
&lt;p&gt;虽然 Vue.js 支持传递复杂的 JavaScript 对象通过 props 属性，但是你应该尽可能的使用原始类型的数据。尽量只使用&lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FPrimitive&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Glossary/Primitive&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;JavaScript 原始类型&lt;i&gt;&lt;/i&gt;&lt;/a&gt;(字符串、数字、布尔值) 和 函数。尽量避免复杂的对象。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-8&quot;&gt;为什么？&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;使得组件 API 清晰直观&lt;/li&gt;
    &lt;li&gt;只使用原始类型和函数作为 props 使得组件的 API 更接近于 HTML(5) 原生元素。&lt;/li&gt;
    &lt;li&gt;其它开发者更好的理解每一个 prop 的含义，作用&lt;/li&gt;
    &lt;li&gt;传递过于复杂的对象使得我们不能够清楚的知道哪些属性或方法被自定义组件使用，这使得代码难以重构和维护。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 data-id=&quot;heading-9&quot;&gt;怎么做？&lt;/h3&gt;
&lt;p&gt;组件的每一个属性单独使用一个 props，并且使用函数或是原始类型的值。&lt;/p&gt;&lt;br&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;!-- 推荐 --&amp;gt;
&amp;lt;range-slider
  :values=&quot;[10, 20]&quot;
  min=&quot;0&quot;
  max=&quot;100&quot;
  step=&quot;5&quot;
  :on-slide=&quot;updateInputs&quot;
  :on-end=&quot;updateResults&quot;&amp;gt;
&amp;lt;/range-slider&amp;gt;

&amp;lt;!-- 避免 --&amp;gt;
&amp;lt;range-slider :config=&quot;complexConfigObject&quot;&amp;gt;&amp;lt;/range-slider&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 data-id=&quot;heading-10&quot;&gt;验证组件的 props&lt;/h2&gt;
&lt;p&gt;在 Vue.js 中，组件的 props 即 API，一个稳定并可预测的 API 会使得你的组件更容易被其他开发者使用。&lt;/p&gt;
&lt;p&gt;组件 props 通过自定义标签的属性来传递。属性的值可以是 Vue.js 字符串(:attr=&quot;value&quot; 或 v-bind:attr=&quot;value&quot;)或是不传。你需要保证组件的 props 能应对不同的情况。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-11&quot;&gt;为什么？&lt;/h3&gt;
&lt;p&gt;验证组件 props 可以保证你的组件永远是可用的(防御性编程)。即使其他开发者并未按照你预想的方法使用时也不会出错。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-12&quot;&gt;怎么做？&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;提供默认值&lt;/li&gt;
    &lt;li&gt;使用 type 属性&lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2Fvuejs.org%2Fv2%2Fguide%2Fcomponents.html%2523Prop-Validation&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=http%3A//vuejs.org/v2/guide/components.html%23Prop-Validation&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;校验类型&lt;i&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;使用 props 之前先检查该 prop 是否存在&lt;/li&gt;
&lt;/ul&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;input type=&quot;range&quot; v-model=&quot;value&quot; :max=&quot;max&quot; :min=&quot;min&quot;&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
  export default {
    props: {
      max: {
        type: Number, // 这里添加了数字类型的校验
        default() { return 10; },
      },
      min: {
        type: Number,
        default() { return 0; },
      },
      value: {
        type: Number,
        default() { return 4; },
      },
    },
  };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;
&lt;h2 data-id=&quot;heading-13&quot;&gt;将 this 赋值给 component 变量(&lt;/h2&gt;
&lt;p&gt;在 Vue.js 组件上下文中，this指向了组件实例。因此当你切换到了不同的上下文时，要确保 this 指向一个可用的 component 变量。&lt;/p&gt;
&lt;p&gt;换句话说，不要在编写这样的代码 const self = this; ，而是应该直接使用变量 component。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-14&quot;&gt;为什么？&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;将组件 this 赋值给变量 component可用让开发者清楚的知道任何一个被使用的地方，它代表的是组件实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 data-id=&quot;heading-15&quot;&gt;怎么做？&lt;/h3&gt;&lt;br&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
export default {
  methods: {
    hello() {
      return &#39;hello&#39;;
    },
    printHello() {
      console.log(this.hello());
    },
  },
};
&amp;lt;/script&amp;gt;

&amp;lt;!-- 避免 --&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
export default {
  methods: {
    hello() {
      return &#39;hello&#39;;
    },
    printHello() {
      const self = this; // 没有必要
      console.log(self.hello());
    },
  },
};
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;
&lt;h2 data-id=&quot;heading-16&quot;&gt;组件结构化&lt;/h2&gt;
&lt;p&gt;按照一定的结构组织，使得组件便于理解。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-17&quot;&gt;为什么？&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;导出一个清晰、组织有序的组件，使得代码易于阅读和理解。同时也便于标准化。&lt;/li&gt;
    &lt;li&gt;按首字母排序属性，data, computed, watches 和 methods 使得属性便于查找。&lt;/li&gt;
    &lt;li&gt;合理组织，使得组件易于阅读。(name; extends; props, data and computed; components; watch and methods; lifecycle methods, 等.);&lt;/li&gt;
    &lt;li&gt;使用 name 属性。借助于&lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fchrome.google.com%2Fwebstore%2Fdetail%2Fvuejs-devtools%2Fnhdogjmejiglipccpnnnanhbledajbpd%253Fhl%253Den&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=https%3A//chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd%3Fhl%3Den&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;vue devtools&lt;i&gt;&lt;/i&gt;&lt;/a&gt;可以让你更方便的测试&lt;/li&gt;
    &lt;li&gt;合理的 CSS 结构，如 &lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fmedium.com%2Ftldr-tech%2Fbem-blocks-elements-and-modifiers-6b3b0af9e3ea%2523.bhnomd7gw&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=https%3A//medium.com/tldr-tech/bem-blocks-elements-and-modifiers-6b3b0af9e3ea%23.bhnomd7gw&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;BEM&lt;i&gt;&lt;/i&gt;&lt;/a&gt; 或 oo&lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Frstacruz%2Frscss&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=https%3A//github.com/rstacruz/rscss&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;css&lt;i&gt;&lt;/i&gt;&lt;/a&gt;        - &lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2Fpablohpsilva%2Fvuejs-component-style-guide%2Fblob%2Fmaster%2FREADME-CN.md%2523%2525E4%2525BD%2525BF%2525E7%252594%2525A8%2525E7%2525BB%252584%2525E4%2525BB%2525B6%2525E5%252590%25258D%2525E4%2525BD%25259C%2525E4%2525B8%2525BA%2525E6%2525A0%2525B7%2525E5%2525BC%25258F%2525E4%2525BD%25259C%2525E7%252594%2525A8%2525E5%25259F%25259F%2525E7%2525A9%2525BA%2525E9%252597%2525B4&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=https%3A//github.com/pablohpsilva/vuejs-component-style-guide/blob/master/README-CN.md%23%25E4%25BD%25BF%25E7%2594%25A8%25E7%25BB%2584%25E4%25BB%25B6%25E5%2590%258D%25E4%25BD%259C%25E4%25B8%25BA%25E6%25A0%25B7%25E5%25BC%258F%25E4%25BD%259C%25E7%2594%25A8%25E5%259F%259F%25E7%25A9%25BA%25E9%2597%25B4&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;详情?&lt;i&gt;&lt;/i&gt;&lt;/a&gt;;&lt;/li&gt;
    &lt;li&gt;使用单文件 .vue 文件格式来组件代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 data-id=&quot;heading-18&quot;&gt;怎么做？&lt;/h3&gt;
&lt;p&gt;组件结构化&lt;/p&gt;&lt;br&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;template lang=&quot;html&quot;&amp;gt;
    &amp;lt;div class=&quot;Ranger__Wrapper&quot;&amp;gt;
        &amp;lt;!-- ... --&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
  export default {
        // 不要忘记了 name 属性
    name: &#39;RangeSlider&#39;,
    // 组合其它组件
    extends: {},
    // 组件属性、变量
    props: {
            bar: {}, // 按字母顺序
            foo: {},
            fooBar: {},
        },
    // 变量
    data() {},
    computed: {},
    // 使用其它组件
    components: {},
    // 方法
    watch: {},
    methods: {},
    // 生命周期函数
    beforeCreate() {},
    mounted() {},
};
&amp;lt;/script&amp;gt;

&amp;lt;style scoped&amp;gt;
  .Ranger__Wrapper { /* ... */ }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;
&lt;h2 data-id=&quot;heading-19&quot;&gt;组件事件命名&lt;/h2&gt;
&lt;p&gt;Vue.js 提供的处理函数和表达式都是绑定在 ViewModel 上的，组件的每一个事件都应该按照一个好的命名规范来，这样可以避免不少的开发问题，具体可见如下 ** 为什么**。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-20&quot;&gt;为什么？&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;开发者可以随意给事件命名，即使是原生事件的名字，这样会带来迷惑性。&lt;/li&gt;
    &lt;li&gt;过于宽松的事件命名可能与&lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fvuejs.org%2Fv2%2Fguide%2Fcomponents.html%2523DOM-Template-Parsing-Caveats&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=https%3A//vuejs.org/v2/guide/components.html%23DOM-Template-Parsing-Caveats&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;DOM模板不兼容&lt;i&gt;&lt;/i&gt;&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 data-id=&quot;heading-21&quot;&gt;怎么做？&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;事件命名也连字符命名&lt;/li&gt;
    &lt;li&gt;一个事件的名字对应组件外的一组意义操作，如：upload-success, upload-error 以及 dropzone-upload-success, dropzone-upload-error (如果需要前缀的话)。&lt;/li&gt;
    &lt;li&gt;事件命名应该以动词(如 client-api-load) 或是 形容词(如 drive-upload-success)结尾。(&lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2FGoogleWebComponents%2Fstyle-guide%2523events&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=https%3A//github.com/GoogleWebComponents/style-guide%23events&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;出处&lt;i&gt;&lt;/i&gt;&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;br&gt;
&lt;h2 data-id=&quot;heading-22&quot;&gt;避免 this.$parent&lt;/h2&gt;
&lt;p&gt;Vue.js 支持组件嵌套，并且子组件可访问父组件的上下文。访问组件之外的上下文违反了基于模块开发的第一原则。因此你应该尽量避免使用 this.$parent。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-23&quot;&gt;为什么？&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;组件必须相互保持独立，Vue 组件也是。如果组件需要访问其父层的上下文就违反了该原则。&lt;/li&gt;
    &lt;li&gt;如果一个组件需要访问其父组件的上下文，那么该组件将不能再其它上下文中复用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 data-id=&quot;heading-24&quot;&gt;怎么做？&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;通过 props 将值传递给子组件&lt;/li&gt;
    &lt;li&gt;通过 props 传递回调函数给子组件来达到调用父组件方法的目的&lt;/li&gt;
    &lt;li&gt;通过在子组件触发事件来通知父组件&lt;/li&gt;
&lt;/ul&gt;&lt;br&gt;
&lt;h2 data-id=&quot;heading-25&quot;&gt;谨慎使用 this.$refs&lt;/h2&gt;
&lt;p&gt;Vue.js 支持通过 ref 属性来访问其它组件和 HTML 元素。并通过 this.$refs 可以得到组件或 HTML 元素的上下文。在大多数情况下，通过 this.$refs来访问其它组件的上下文是可以避免的。在使用的的时候你需要注意避免调用了不恰当的组件 API，所以应该尽量避免使用 this.$refs。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-26&quot;&gt;为什么？&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;组件必须是保持独立的，如果一个组件的 API 不能够提供所需的功能，那么这个组件在设计、实现上是有问题的。&lt;/li&gt;
    &lt;li&gt;组件的属性和事件必须足够的给大多数的组件使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 data-id=&quot;heading-27&quot;&gt;怎么做？&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;提供良好的组件 API&lt;/li&gt;
    &lt;li&gt;总是关注于组件本身的目的&lt;/li&gt;
    &lt;li&gt;拒绝定制代码。如果你在一个通用的组件内部编写特定需求的代码，那么代表这个组件的 API 不够通用，或者你可能需要一个新的组件来应对该需求&lt;/li&gt;
    &lt;li&gt;检查所有的 props 是否有缺失的，如果有提一个 issue 或是完善这个组件&lt;/li&gt;
    &lt;li&gt;检查所有的事件。子组件向父组件通信一般是通过事件来实现的，但是大多数的开发者更多的关注于 props 从忽视了这点。&lt;/li&gt;
    &lt;li&gt;Props向下传递，事件向上传递！。以此为目标升级你的组件，提供良好的 API 和 独立性。&lt;/li&gt;
    &lt;li&gt;当遇到 props 和 events 难以实现的功能时，通过 this.$refs来实现。&lt;/li&gt;
    &lt;li&gt;当需要操作 DOM 无法通过指令来做的时候可使用 this..$ref 而不是 JQuery, document.getElement* , document.queryElement。&lt;/li&gt;
&lt;/ul&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;!-- 推荐，并未使用 this.$refs --&amp;gt;
&amp;lt;range :max=&quot;max&quot;
  :min=&quot;min&quot;
  @current-value=&quot;currentValue&quot;
  :step=&quot;1&quot;&amp;gt;&amp;lt;/range&amp;gt;
&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;!-- 使用 this.$refs 的适用情况--&amp;gt;
&amp;lt;modal ref=&quot;basicModal&quot;&amp;gt;
  &amp;lt;h4&amp;gt;Basic Modal&amp;lt;/h4&amp;gt;
  &amp;lt;button class=&quot;primary&quot; @click=&quot;$refs.basicModal.close()&quot;&amp;gt;Close&amp;lt;/button&amp;gt;
&amp;lt;/modal&amp;gt;
&amp;lt;button @click=&quot;$refs.basicModal.open()&quot;&amp;gt;Open modal&amp;lt;/button&amp;gt;

&amp;lt;!-- Modal component --&amp;gt;
&amp;lt;template&amp;gt;
  &amp;lt;div v-show=&quot;active&quot;&amp;gt;
    &amp;lt;!-- ... --&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  export default {
    // ...
    data() {
        return {
            active: false,
        };
    },
    methods: {
      open() {
        this.active = true;
      },
      hide() {
        this.active = false;
      },
    },
    // ...
  };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;!-- 如果可通过 emited 来做则避免通过 this.$refs 直接访问 --&amp;gt;
&amp;lt;template&amp;gt;
  &amp;lt;range :max=&quot;max&quot;
    :min=&quot;min&quot;
    ref=&quot;range&quot;
    :step=&quot;1&quot;&amp;gt;&amp;lt;/range&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  export default {
    // ...
    methods: {
      getRangeCurrentValue() {
        return this.$refs.range.currentValue;
      },
    },
    // ...
  };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;
&lt;h2 data-id=&quot;heading-28&quot;&gt;使用组件名作为样式作用域空间&lt;/h2&gt;
&lt;p&gt;Vue.js 的组件是自定义元素，这非常适合用来作为样式的根作用域空间。可以将组件名作为 css 类的命名空间。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-29&quot;&gt;为什么？&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;给样式加上作用域空间可以避免组件样式影响外部的样式&lt;/li&gt;
    &lt;li&gt;保持模块名、目录名、样式根作用域名一样，可以很好的将其关联起来，便于开发者理解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 data-id=&quot;heading-30&quot;&gt;怎么做？&lt;/h3&gt;
&lt;p&gt;使用组件名作为样式命名的前缀，可基于 BEM 或 OOCSS 范式。同时给style标签加上 scoped 属性。加上 scoped 属性编译后会给组件的 class 自动加上唯一的前缀从而避免样式的冲突。&lt;/p&gt;&lt;br&gt; &lt;pre&gt;&lt;code&gt;&amp;lt;style scoped&amp;gt;
    /* 推荐 */
    .MyExample { }
    .MyExample li { }
    .MyExample__item { }

    /* 避免 */
    .My-Example { } /* not scoped to component or module name, not BEM compliant */
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;
&lt;h2 data-id=&quot;heading-31&quot;&gt;提供组件 API 文档&lt;/h2&gt;
&lt;p&gt;使用 Vue.js 组件的过程中会创建 Vue 组件实例，这个实例是通过自定义属性配置的。为了便于其他开发者使用该组件，对于这些自定义属性即组件API应该在 README.md 文件中进行说明。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-32&quot;&gt;为什么？&lt;/h2&gt;
&lt;ul&gt;
    &lt;li&gt;良好的文档可以让开发者比较容易的对组件有一个整体的认识，而不用去阅读组件的源码，也更方便开发者使用&lt;/li&gt;
    &lt;li&gt;组件配置属性即组件的 API，对于组件的用户来说他们更感兴趣的是 API 而不是实现原理。&lt;/li&gt;
    &lt;li&gt;正式的文档会告诉开发者组件 API 变更以及向后的兼容性情况&lt;/li&gt;
    &lt;li&gt;README.md 是标准的我们应该首先阅读的文档文件。代码托管网站 (github/bitbucket/gitlab 等) 会默认在仓库中展示 该文件作为仓库的介绍。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 data-id=&quot;heading-33&quot;&gt;怎么做？&lt;/h3&gt;
&lt;p&gt;在模块目录中添加 README.md 文件：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;range-slider/
├── range-slider.vue
├── range-slider.less
└── README.md
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 README 文件中说明模块的功能以及使用场景。对于 vue 组件来说，比较有用的描述是组件的自定义属性即 API 的描述介绍。&lt;/p&gt;
&lt;h1 data-id=&quot;heading-34&quot;&gt;Range slider&lt;/h1&gt;
&lt;h2 data-id=&quot;heading-35&quot;&gt;功能&lt;/h2&gt;
&lt;p&gt;range slider 组件可通过拖动的方式来设置一个给定范围内的数值。&lt;/p&gt;
&lt;p&gt;该模块使用 &lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2Frefreshless.com%2Fnouislider%2F&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=http%3A//refreshless.com/nouislider/&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;noUiSlider&lt;i&gt;&lt;/i&gt;&lt;/a&gt; 来实现夸浏览器和 touch 功能的支持。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-36&quot;&gt;如何使用&lt;/h2&gt;
&lt;p&gt;&amp;lt;range-slider&amp;gt; 支持如下的自定义属性：&lt;/p&gt;* attributetypedescriptionminNumber
&lt;p&gt;可拖动的最小值.maxNumber可拖动的最大值.&lt;/p&gt;
&lt;p&gt;* valuesNumber&lt;/p&gt;
&lt;p&gt;&lt;em&gt;optional，&lt;/em&gt;包含最大值和最小值的数组. 如. values=&quot;[10, 20]&quot;. Defaults to [opts.min, opts.max].&lt;/p&gt;
&lt;p&gt;* stepNumber &lt;/p&gt;
&lt;p&gt;&lt;em&gt;optional，&lt;/em&gt;增加减小的数值单位，默认为 1.&lt;/p&gt;
&lt;p&gt;* on-slideFunction &lt;/p&gt;
&lt;p&gt;&lt;em&gt;optional，&lt;/em&gt;用户拖动开始按钮或者结束按钮时的回调函数，函数接受 (values, HANDLE) 格式的参数。 如： on-slide={ updateInputs }, component.updateInputs = (values, HANDLE) =&amp;gt; { const value = values[HANDLE]; }.&lt;/p&gt;
&lt;p&gt;* on-endFunction &lt;/p&gt;
&lt;p&gt;&lt;em&gt;optional，&lt;/em&gt;当用户停止拖动时触发的回调函数，函数接受 (values, HANDLE) 格式的参数。&lt;/p&gt;
&lt;p&gt;如需要自定义 slider 的样式可参考 noUiSlider 文档&lt;/p&gt;&lt;br&gt;
&lt;h2 data-id=&quot;heading-37&quot;&gt;提供组件 demo&lt;/h2&gt;
&lt;p&gt;添加 index.html 文件作为组件的 demo 示例，并提供不同配置情况的效果，说明组件是如何使用的。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-38&quot;&gt;为什么？&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;demo 可以说明组件是独立可使用的&lt;/li&gt;
    &lt;li&gt;demo 可以让开发者预览组件的功能效果&lt;/li&gt;
    &lt;li&gt;demo 可以展示组件各种配置参数下的功能&lt;/li&gt;
&lt;/ul&gt;&lt;br&gt;
&lt;h2 data-id=&quot;heading-39&quot;&gt;对组件文件进行代码校验&lt;/h2&gt;
&lt;p&gt;代码校验可以保持代码的统一性以及追踪语法错误。.vue 文件可以通过使用 eslint-plugin-html插件来校验代码。你可以通过 vue-cli 来开始你的项目，vue-cli 默认会开启代码校验功能。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-40&quot;&gt;为什么？&lt;/h2&gt;
&lt;ul&gt;
    &lt;li&gt;保证所有的开发者使用同样的编码规范。&lt;/li&gt;
    &lt;li&gt;更早的感知到语法错误&lt;/li&gt;
    &lt;li&gt;怎么做？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了校验工具能够校验 *.vue文件，你需要将代码编写在 &amp;lt;script&amp;gt;标签中，并使组件表达式简单化，因为校验工具无法理解行内表达式，配置校验工具可以访问全局变量 vue 和组件的 props。&lt;/p&gt;
&lt;h2 data-id=&quot;heading-41&quot;&gt;ESLint&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2Feslint.org%2F&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=http%3A//eslint.org/&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;ESLint&lt;i&gt;&lt;/i&gt;&lt;/a&gt; 需要通过 &lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%253A%2F%2Fgithub.com%2FBenoitZugmeyer%2Feslint-plugin-html%2523eslint-plugin-html&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=https%3A//github.com/BenoitZugmeyer/eslint-plugin-html%23eslint-plugin-html&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;ESLint HTML 插件&lt;i&gt;&lt;/i&gt;&lt;/a&gt;来抽取组件中的代码。&lt;/p&gt;
&lt;p&gt;通过 .eslintrc 文件来配置 ESlint，这样 IED 可以更好的理解校验配置项。 ESlint，这样.&lt;/p&gt;&lt;br&gt; &lt;pre&gt;&lt;code&gt;{
  &quot;extends&quot;: &quot;eslint:recommended&quot;,
  &quot;plugins&quot;: [&quot;html&quot;],
  &quot;env&quot;: {
    &quot;browser&quot;: true
  },
  &quot;globals&quot;: {
    &quot;opts&quot;: true,
    &quot;vue&quot;: true
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行 ESLint&lt;/p&gt;&lt;br&gt; &lt;pre&gt;&lt;code&gt;eslint src/**/*.vue
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 data-id=&quot;heading-42&quot;&gt;JSHint&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://link.juejin.cn/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%253A%2F%2Fjshint.com%2F&quot; target=&quot;_blank&quot; title=&quot;http://link.zhihu.com/?target=http%3A//jshint.com/&quot; ref=&quot;nofollow noopener noreferrer&quot;&gt;JSHint&lt;i&gt;&lt;/i&gt;&lt;/a&gt; 可以解析 HTML (使用 --extra-ext命令参数) 和 抽取代码（使用 --extract=auto命令参数).&lt;/p&gt;
&lt;p&gt;通过 .jshintrc 文件来配置 ESlint，这样 IED 可以更好的理解校验配置项。&lt;/p&gt;&lt;br&gt; &lt;pre&gt;&lt;code&gt;{
  &quot;browser&quot;: true,
  &quot;predef&quot;: [&quot;opts&quot;, &quot;vue&quot;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行 JSHint&lt;/p&gt;&lt;br&gt; &lt;pre&gt;&lt;code&gt;jshint --config modules/.jshintrc --extra-ext=html --extract=auto modules/
&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;
&lt;p&gt;注：JSHint 不接受 vue 扩展名的文件，只支持 html。&lt;/p&gt; </description><link>https://juejin.cn/post/6844903466465230861</link><guid isPermaLink="false">https://juejin.cn/post/6844903466465230861</guid><pubDate>Thu, 09 Mar 2017 03:19:39 GMT</pubDate><author>杨小福</author><category>前端</category><category>Vue.js</category></item></channel></rss>