<?xml version="1.0" encoding="UTF-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Go语言中文网 - 每日一学</title><link>https://studygolang.com/go/daily</link><atom:link href="http://rss.wudifeixue.com/studygolang/go/daily" rel="self" type="application/rss+xml"></atom:link><description>Go语言中文网 - 每日一学 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)</description><generator>RSSHub</generator><webMaster>i@diygod.me (DIYgod)</webMaster><language>en</language><lastBuildDate>Wed, 19 Mar 2025 21:29:45 GMT</lastBuildDate><ttl>5</ttl><item><title>[完结40周]物联网/嵌入式全能工程师（提薪优选)</title><description>&lt;p&gt;/s/1Vjj7o_p8sL9e2NJ_wGTXwg 提取码：u1v9&lt;/p&gt;
&lt;p&gt;一、前言
随着科技的不断进步和行业的高速发展，物联网嵌入式技术成为了当今的热门领域。许多人都看到了这个行业的发展机遇，并产生了转行学习嵌入式技术的想法。然而，由于自身对嵌入式技术的不了解，许多人会存在一些顾虑和疑惑，不知道自己是否适合学习嵌入式。&lt;/p&gt;
&lt;p&gt;其实，要判断是否从事一个行业，不管你是科班出身，还是零基础小白转行，最理想的工作莫过于能将你的兴趣、专业技能和市场需求三合一。但大部分同学很难这么幸运的找到真正三合一的工作，那么在择业的时候至少看看即将进入的这个行业如何，自己是否具备行业所需技能，是否能在养活自己的前提下可持续地发展。&lt;/p&gt;
&lt;p&gt;而判断一个行业是否值得进入，这个技能是否值得学习，可以通过它的行业发展趋势、市场需求，以及岗位需求来判断；如果这个答案是肯定的话，就是第二步，思考自己有哪些优势，能否直接入行，抑或是自学，或者是借助培训机构来学习成长。&lt;/p&gt;
&lt;p&gt;首先，物联网开发的范畴比较大，涉及到的领域涵盖嵌入式技术+传感技术+通信技术，行业岗位多，就业面广，嵌入式开发工程师，物联网开发工程师、单片机开发、C/C++开发、Zigbee开发、QT开发、Linux驱动开发等，而且通过查看传统的嵌入式相关岗位的招聘需求都不难看出，这些岗位中普遍会涉及到C语言或者C++、Linux系统编程、协议、ARM、STM32、GPIO、FreeRTOS等技术，这些知识的全面了解和掌握，是嵌入式入行的基础。&lt;/p&gt;
&lt;p&gt;而物联网开发是源于传统嵌入式的，物联网开发是云端一体，数据上云以及智能化处理。嵌入式是物联网开发的技术底座，是物联网中的一部分，嵌入式更多的是专注于硬件设备的内部控制和功能，而物联网关注的是设备之间的互联，以及联网之后这些传感器采集到的数据的处理和后期的应用。所以物联网相关的岗位则普遍要求了解和掌握ZigBee通信、蓝牙通信、Wi-Fi通信、NB-IoT、QT数据库编程、QT多线程编程、QT网络编程、边缘计算、云平台等相关的技术。&lt;/p&gt;
&lt;p&gt;从行业和岗位的需求大家可以看到，目前大部分市场上传统的嵌入式工程师，从事基础开发工作的的确不少，但是真正有经验，知识面广，且具备物联网开发能力的嵌入式工作者就非常稀缺。因此市场上不同层次的开发人员和其薪资，也是呈金字塔型的。如果想要在物联网行业发展得更好，则需要不断深耕，提高解决问题的能力，不断地累积行业的相关经验。所以想要入行的同学，在认准行业后，必须要保持持续学习和持续发展的态度及思想准备，没有其他捷径可走。&lt;/p&gt;
&lt;p&gt;二、对于小白：不知道嵌入式整个体系？学什么？顺序是什么？可以找什么工作？可以往什么方向发展？前景如何？查阅大量资料进行下面的整理，看完可能你心中就会有答案!
学习路线
下面是基本的入门路线：可以在此基础上从发展方向和技术类型进行扩展
第一步：电路知识
7星：数字电路技术、模拟电路技术、电路
6星：数据库、数据结构、操作系统
5星：计算机网络、计算机组成原理
4星：数字信号处理、数字集成电路设计
3星：电磁场、微机原理、RFID无线通信技术
2星：电子线路设计、计算机体系结构
1星：高等数学、线性代数、离散数学&lt;/p&gt;
&lt;p&gt;第二步：PCB&lt;/p&gt;
&lt;p&gt;第三步：C/C++、QT、OpenCV、Git&lt;/p&gt;
&lt;p&gt;第四步：Linux基础shell编程——&amp;gt;Linux 系统编程——&amp;gt;Linux 网络编程&lt;/p&gt;
&lt;p&gt;第五步：CC2530单片机——&amp;gt;51单片机——&amp;gt;STM32单片机——&amp;gt;（RTOS）&lt;/p&gt;
&lt;p&gt;三、关于嵌入式学习总结
1、了解嵌入式系统的基础知识学习嵌入式系统的第一步是建立对其基础知识的理解。嵌入式系统是指嵌入在其他设备或系统中的计算机系统，通常具有特定的功能和任务。这些系统通常包括处理器、存储器、输入/输出接口以及操作系统等组件。因此，学习者需要掌握计算机体系结构、嵌入式软件开发、传感器与执行器等基础知识。&lt;/p&gt;
&lt;p&gt;2、学习嵌入式系统的编程语言和工具在学习嵌入式系统时，掌握相关的编程语言和开发工具是至关重要的。常用的嵌入式系统编程语言包括C、C++和汇编语言。此外，熟悉与嵌入式系统开发相关的集成开发环境（IDE）、调试工具和模拟器也是必不可少的。例如，Arduino、Raspberry Pi等平台提供了丰富的资源和工具，可以帮助学习者快速入门嵌入式系统开发。&lt;/p&gt;
&lt;p&gt;3、深入了解嵌入式系统的硬件设计除了软件开发，学习者还应该深入了解嵌入式系统的硬件设计。这包括掌握电子电路设计、PCB设计、传感器与执行器的选择与接口等内容。通过学习硬件设计，学习者可以更好地理解嵌入式系统的工作原理，从而能够更好地进行系统调试和优化。&lt;/p&gt;
&lt;p&gt;4、实践项目和案例分析在学习嵌入式系统的过程中，实践是非常重要的一环。学习者可以通过完成各种项目和案例分析来巩固所学知识。这些项目可以包括从简单的LED控制到复杂的无人机控制系统等。通过实践项目，学习者不仅可以提高自己的编程能力，还可以锻炼解决问题的能力和团队合作能力。&lt;/p&gt;
&lt;p&gt;5、探索嵌入式系统在物联网中的应用最后，学习者还应该深入探索嵌入式系统在物联网中的应用。物联网涉及的领域非常广泛，包括智能家居、智能医疗、智能交通等。了解不同领域的应用场景和需求，可以帮助学习者更好地理解嵌入式系统的设计与开发。&lt;/p&gt;
&lt;p&gt;6、参与开源项目
参与开源项目不仅可以提升你的技能，还可以让你了解团队合作和项目管理：
贡献代码：为开源项目贡献代码，提升编程能力。通过实际参与项目，你可以学习到更多的编程技巧和最佳实践。
文档编写：参与项目文档的编写，提高技术写作能力。文档是项目的重要组成部分，良好的文档可以帮助他人理解和使用你的项目。
社区交流：与项目成员交流，学习他们的经验和最佳实践。社区是学习的重要资源，通过交流你可以获得宝贵的知识和建议&lt;/p&gt;
&lt;p&gt;7、持续学习
阅读技术博客和论坛：&lt;a href=&quot;http://xn--embedded-jo1o.com/&quot;&gt;如Embedded.com&lt;/a&gt;、EEWeb等。这些资源可以帮助你了解行业的最新动态和技术趋势。
参加研讨会和会议：如嵌入式系统大会、电子展等。这些活动可以让你接触到最新的技术和产品，以及行业内的专家和领袖&lt;/p&gt;
</description><link>https://studygolang.com/topics/17759</link><guid isPermaLink="false">https://studygolang.com/topics/17759</guid><pubDate>Mon, 10 Feb 2025 08:33:10 GMT</pubDate><author>kuaidelasiLIGUANGYAO</author><category>每日一学</category></item><item><title>OpenGL渲染引擎-设计与实践教程</title><description>&lt;p&gt;学习地址1：&lt;a href=&quot;https://pan.baidu.com/s/1xcTWd283zJ9bXCs2kYG-BA&quot;&gt;https://pan.baidu.com/s/1xcTWd283zJ9bXCs2kYG-BA&lt;/a&gt; 提取码: 7t5p
学习地址2：&lt;a href=&quot;https://share.weiyun.com/ZgSMB098&quot;&gt;https://share.weiyun.com/ZgSMB098&lt;/a&gt; 密码：in4rmz&lt;/p&gt;
&lt;p&gt;Qt 对 OpenGL 的支持是内建的，也就是说，只要你的 Qt 版本支持 OpenGL，你就可以在你的 Qt 应用程序中使用 OpenGL，无需额外安装 OpenGL。&lt;/p&gt;
&lt;p&gt;然而，要在你的 Qt 应用程序中使用 OpenGL，你的系统需要有一个支持 OpenGL 的图形驱动。这通常意味着你需要在你的系统上安装一个支持 OpenGL 的图形卡驱动。大多数现代的桌面系统（包括 Windows、macOS 和大多数 Linux 发行版）都自带了支持 OpenGL 的图形驱动，所以你通常不需要手动安装。&lt;/p&gt;
&lt;p&gt;如果你的系统没有支持 OpenGL 的图形驱动，或者你的图形驱动不支持你需要的 OpenGL 版本，你可能需要手动安装一个新的图形驱动。这通常涉及到从你的图形卡制造商的网站下载驱动程序，并按照他们的指示进行安装。&lt;/p&gt;
&lt;p&gt;请注意，虽然 Qt 支持 OpenGL，但并不是所有的 Qt 功能都需要 OpenGL。大多数 Qt 功能（包括 Qt Widgets 和 Qt Quick 2D）都可以在没有 OpenGL 的系统上运行。只有一些特定的功能（如 Qt Quick 3D 和一些 Qt 3D 功能）需要 OpenGL。&lt;/p&gt;
&lt;p&gt;一、Vulkan和OpenGL区别
Vulkan和OpenGL区别，Vulkan与OpenGL相比，可以更详细的向显卡描述你的应用程序打算做什么，从而可以获得更好的性能和更小的驱动开销。Vulkan的设计理念与Direct3D 12和Metal基本类似，但Vulkan作为OpenGL的替代者，它设计之初就是为了跨平台实现的，可以同时在Windows、Linux和Android开发。甚至在Mac OS系统上，Khronos也提供了Vulkan的SDK，虽然这个SDK底层其实是使用MoltenVK实现的。&lt;/p&gt;
&lt;p&gt;Vulkan的最大任务不是竞争DirectX，而是取代OpenGL，所以重点要看和后者的对比。在高分辨率、高画质、需要GPU发挥的时候，Vulkan、OpenGL的速度基本差不多，但是随着分辨率的降低，CPU越来越重要，Vulkan逐渐体现了出来，尤其是看看GTX 980 Ti，最多可以领先OpenGL 33％之多！&lt;/p&gt;
&lt;p&gt;二、OpenGL对象
我们可以把OpenGL对象理解成一个状态的集合，它负责管理它下属的所有状态。当然，除了状态，OpenGL对象还会存储其他数据。注意。这些状态和上述context中的状态并不重合，只有在把一个OpenGL对象绑定到context上时，OpenGL对象的各种状态才会映射到context的状态。因此，这时如果我们改变了context的状态，那么也会影响这个对象，而相反地，依赖这些context状态的函数也会使用存储在这个对象上的数据。
因此，OpenGL对象的绑定既可能是为了修改该对象的状态（大多数对象需要绑定到context上才可以改变它的状态），也可能是为了让context渲染时使用它的状态。&lt;/p&gt;
&lt;p&gt;三、OpenGL的工作方式
首先，OpenGL一开始最难理解的部分我觉得在于创建整个程序上。虽然我已经有一些图形学基础，但是拿到OpenGL的时候完全是懵逼的，因为完全不知道其程序的运作方式。
所以在这里，我觉得最先需要解释的就是OpenGL的整体工作方式：
OpenGL是一个状态机，因此，其工作方式来自于上下文环境的切换，或者说是设定当前上下文环境(Context)。因此，不论是创建的shader，还是VAO，VBO，都是需要创建之后绑定进入当前上下文的。&lt;/p&gt;
&lt;p&gt;四、学习OpenGL常见难点：
难点1：不知道如何将单个例子，结合成一个完整的渲染引擎
难点2：不能把Shader和CPU的流程联立在一起，不知道某个资源/数据，是从哪里来的。就算知道他是什么时候送到GPU的，也不知道GPU如何定位某个资源/数据。
难点3：难以建立起并行计算的思维方式
难点4：难以理解各种模板如何在多个批次之间发生作用。不能具象的去理解混合，测试的过程。不能够理解，FrameBuffer的真正含义。
难点5：难以建立起空间想象，不知道矩阵变换，如何将顶点，或其他数据，变换到不同的空间进行统一计算。
难点6：难以理解从Vertex到Fragment是如何过度的。&lt;/p&gt;
&lt;p&gt;五、构建OpenGL程序
1、在项目的根目录下创建build mkdir build cd build
2、执行cmake指令，指定要构建的文件系统和使用的编译器 cmake .. -G Ninja -D CMAKE_C_COMPILER=clang -D CMAKE_CXX_COMPILER=clang++
3、执行ninja ninja 编译完成之后就可以在build目录下找到可执行程序了，能够正常运行就说明OpenGL的开发环境搭建完成。&lt;/p&gt;
</description><link>https://studygolang.com/topics/17495</link><guid isPermaLink="false">https://studygolang.com/topics/17495</guid><pubDate>Mon, 03 Jun 2024 06:37:31 GMT</pubDate><author>kaudmandsLIGUANGYAO</author><category>每日一学</category></item><item><title>Playwright+Python自动化测试课程</title><description>&lt;p&gt;资料地址1：&lt;a href=&quot;https://pan.baidu.com/s/1RB23Y6IwUaGP7cb8MfwWlQ&quot;&gt;https://pan.baidu.com/s/1RB23Y6IwUaGP7cb8MfwWlQ&lt;/a&gt; 提取码: ubdv
资料地址2：&lt;a href=&quot;https://share.weiyun.com/TUBYPTvw&quot;&gt;https://share.weiyun.com/TUBYPTvw&lt;/a&gt; 密码：mjg5i4&lt;/p&gt;
&lt;p&gt;日常工作中，我们不可能避免得使用浏览器来完成一些工作，Python 也有不少浏览器自动化的工具，我用过 selenium、splinter、playwright，最终还是选择了微软的 playwright，之所以选择它，是因为它可以自动安装浏览器，不需要手动下载浏览器的驱动程序，比如 chromedriver，这样写出来的自动化工具很容易移植到其他系统中运行。
Playwright 可通过单个 API 自动执行 Chromium，Firefox 和 WebKit浏览器，支持无头浏览器（headless），Linux、macOS、Windows 下均可以使用，Playwright提供的自动化技术是绿色的，功能强大，稳定且速度快。你可以充分发挥空间，想象它可以实现什么样的功能。&lt;/p&gt;
&lt;p&gt;一、Playwright 是什么？
微软在 2020 年初开源的新一代自动化测试工具，它的功能类似于 Selenium、Pyppeteer 等，都可以驱动浏览器进行各种自动化操作。它的功能也非常强大，对市面上的主流浏览器都提供了支持，API 功能简洁又强大。虽然诞生比较晚，但是现在发展得非常火热。 Playwright 支持大部分的语言，Node.js,Python,Java,.net，并且支持谷歌，火狐浏览器，WebKit，对于移动端也支持，可以在 Windows、Linux、MacOs 等机器上运行。脚本执行支持同步或者异步的方式。Playwright是一个开源的自动化测试工具,用于测试网页应用。它可以操控Chromium(用于Chrome、Edge等)、Firefox和WebKit(用于Safari)等主流浏览器,使我们能在不同浏览器中执行自动化测试。&lt;/p&gt;
&lt;p&gt;二、Playwright相对于Selenium的优势
在介绍Playwright的安装与Python集成之前，让我们先了解一下Playwright相对于传统的自动化测试工具Selenium的优势所在。
1.1 跨浏览器支持
Playwright支持多种主流浏览器，包括Chrome、Firefox和WebKit（用于Safari），而Selenium在一段时间内对新版本的浏览器支持可能会滞后。&lt;/p&gt;
&lt;p&gt;1.2 更快的执行速度
Playwright以其快速的执行速度著称，它能够在多个浏览器上同时执行测试，从而大大减少了测试的执行时间。相比之下，Selenium在执行速度方面可能会慢一些。&lt;/p&gt;
&lt;p&gt;1.3 更稳定的选择器
Playwright使用了更先进的选择器引擎，能够更稳定地识别页面上的元素，减少了因页面变化而导致的测试失败的可能性。而Selenium在这方面可能会更容易受到页面变化的影响。&lt;/p&gt;
&lt;p&gt;三、Playwright是跨语言支持的，支持Python、Java、Node.js、.NET
使用场景：
自动化测试工程师，可用于Web开发中的各种自动化测试；
爬虫工程师，当接口中有加密参数（包括url加密参数、请求头加密参数、cookie加密参数）或者返回数据也是经过加密的，如果加密逻辑太过复杂暂时无法找出，我们可采用自动化的方式获取经过网站渲染过的源码，抓取需要的数据即可；
开发工程师，可与其他项目结合来使用，比如docker、github/gitlab等&lt;/p&gt;
&lt;p&gt;四、为什么选择 Playwright？
Playwright 的优势
1、Selenium 需要通过 WebDriver 操作浏览器；Playwright 通过开发者工具与浏览器交互，安装简洁，不需要安装各种 Driver。
2、Playwright 几乎支持所有语言，且不依赖于各种 Driver，通过调用内置浏览器所以启动速度更快。
3、Selenium 基于 HTTP 协议（单向通讯），Playwright 基于 Websocket（双向通讯）可自动获取浏览器实际情况。
4、Playwright 为自动等待，而在 Selenium 中经常需要写 sleep 去作为一个等待，保证程序正常运行。等待元素出现（定位元素时，自动等待30s，等待时间可以自定义，单位毫秒）等待事件发生&lt;/p&gt;
</description><link>https://studygolang.com/topics/17447</link><guid isPermaLink="false">https://studygolang.com/topics/17447</guid><pubDate>Mon, 20 May 2024 09:00:31 GMT</pubDate><author>kaudmandsLIGUANGYAO</author><category>每日一学</category></item><item><title>2024新考纲-系统架构设计师（软考高级） 一站式通关课程</title><description>&lt;p&gt;2024新考纲-系统架构设计师（软考高级） 一站式通关课程
参考资料地址1：&lt;a href=&quot;https://pan.baidu.com/s/1pg7G8olYu6zDFvnl65TrcA&quot;&gt;https://pan.baidu.com/s/1pg7G8olYu6zDFvnl65TrcA&lt;/a&gt; 提取码：meh4
参考资料地址2：&lt;a href=&quot;https://pan.baidu.com/s/1IZobXGCn8YLfe3K_gy1Smg&quot;&gt;https://pan.baidu.com/s/1IZobXGCn8YLfe3K_gy1Smg&lt;/a&gt; 提取码：74fn&lt;/p&gt;
&lt;p&gt;一、什么是系统架构设计师
系统架构设计师，属于计算机技术与软件（高级）专业技术资格。考试合格人员能够根据系统需求规格说明书，结合应用领域和技术发展的实际情况，考虑有关约束条件，设计正确、合理的软件架构，确保系统架构具有良好的特性；能够对项目的系统架构进行描述、分析、设计与评估；能够按照相关标准编写相应的设计文档；能够与系统分析师、项目管理师相互协作、配合工作；具有高级工程师的实际工作能力和业务水平。&lt;/p&gt;
&lt;p&gt;二、系统架构的概述
自1946年世界上第一台计算机诞生，对人类的计算工具产生了革命性变革。冯诺依曼提出了计算机由运算器，控制器，存储器，输入和输出设备五部分组成，计算机的内部采用二进制。
计算机是全球信息化发展的核心载体，随着各种基础技术突飞猛进的发展，信息系统的规模越来越大、复杂程度越来越高、系统的结构显得越来越重要。如果在搭建系统时未能设计出优良的结构，势必对系统的可靠性、安全性、可移植性、可扩展性、可用性和可维护性等方面产生重大影响。
因此，系统架构（System Architecture）是系统的一种整体的高层次的结构表示，是系统的骨架和根基，也决定了系统的健壮性和生命周期的长短。
系统架构设计师是承担系统架构设计的核心角色，他不仅是连接用户需求和系统进一步设计与实现的桥梁，也是系统开发早期阶段质量保证的关键角色。随着系统规模和复杂性的提升，系统架构设计师在整个项目研制中的主导地位愈加重要。
可以说，系统架构师就是项目的总设计师，他是一个既需要掌控整体又需要洞悉局部瓶颈，并依据具体的业务场景给出解决方案的总体设计人员;他要确认和评估系统需求，给出开发规范，搭建系统实现的核心构架，并澄清技术细节、扫清主要难点的技术人员;他要掌握技术团队的能力需要，给出项目管理方法，采用合适生命周期模型，具备以自身为核心形成团队的能力，并在项目进度计划和经费分配等方面开展评估，以预防项目风险。&lt;/p&gt;
&lt;p&gt;三、系统架构设计师考试时间
2024年开始系统架构设计师和系统分析师一年都有两次考试机会，分别在上半年和下半年。这样的考试时间安排，对于技术同学来说，是一个好消息。因为这样的时间安排，可以让你有更多的机会来备考，而不是像以前一样，一年只有一次考试机会，错过了就要等一年。
2024年上半年系统架构设计师报名时间是 3 月 18 日，考试时间极大概率是5月25日。&lt;/p&gt;
&lt;p&gt;四、考试难度大吗
不要被考试难度吓到，从难度上来说并不是一门难道很高的考试，但是每年的通过率可能只有15%左右。个人认为，究其原因因为架构作为一门分三科单独划线的考试（各科满分75，45分通过），很多应试者因为复习时间分配不当，导致某些科目复习不到位，从而单科线未过，满盘皆输，非常可惜。因此我从个人角度分享两个应试技巧。一个是以【真题为纲】【书本为辅】，二是【学会总结】。&lt;/p&gt;
&lt;p&gt;五、系统架构设计师常见的考试内容包括哪些
系统架构设计师常见的考试内容包括:
计算机网络和通信知识:涵盖网络协议、路由、交换、传输控制协议/因特网协议(TCP/IP)、网络安全等。
数据库知识:包括关系型数据库管理系统(RDBMS)、:非关系型数据库、数据建模、数据仓库等。
操作系统知识:涉及操作系统原理、进程管理、内存管理、文件系统等
软件工程知识:包括软件开发过程、软件设计原则、软件测试、软件质量保证等
架构设计知识:包括系统设计原则、架构设计模式、系统性能优化、系统安全等
此外，考试内容可能还包括项目管理、商业分析、人工智能、云计算等方面的知识。根据考试的级别和范围，考试内容也会有所不同。&lt;/p&gt;
&lt;p&gt;六、关于系统架构设计师就业
系统架构设计师的就业前景非常乐观。随着信息技术的发展，特别是云计算、大数据、人工智能等技术的普及，企业对信息系统的依赖程度日益加深，对系统架构设计师的需求也随之增加。无论是大型企业还是小型公司，无论是传统行业还是新兴领域，都需要专业的系统架构设计师来负责设计和管理其信息系统。此外，由于信息技术领域的快速发展，系统架构设计师需要不断学习和更新自己的知识体系，以跟上技术潮流，满足企业对于复杂系统架构设计的需求。
系统架构设计师的职业发展路径也是多元化的。他们可以选择在专业技术路径上深造成为技术领袖或行业专家，也可以转向管理岗位，利用技术背景和架构设计经验带领团队完成项目，或者成为独立的咨询顾问，为多家企业提供系统架构设计和优化服务。随着中国企业走出去的步伐加快，具备国际化视野的系统架构设计师将更受欢迎，他们需要了解国内外最新的技术动态和行业标准，并能够与不同文化背景的团队成员有效沟通。&lt;/p&gt;
</description><link>https://studygolang.com/topics/17277</link><guid isPermaLink="false">https://studygolang.com/topics/17277</guid><pubDate>Thu, 14 Mar 2024 08:04:23 GMT</pubDate><author>kaudmands</author><category>每日一学</category></item><item><title>一文带你入门汇编语言</title><description>&lt;p&gt;&amp;gt; 更好的阅读体验请点击 &amp;lt;a href=&quot;&lt;a href=&quot;https://www.yinkai.cc/post/5a98ebfa9c12a349639a92bbb9be69f5&quot;&gt;https://www.yinkai.cc/post/5a98ebfa9c12a349639a92bbb9be69f5&lt;/a&gt;&quot;&amp;gt; YinKai &#39;s Blog&amp;lt;/a&amp;gt;。
&amp;gt; 由于篇幅限制，完整内容请到博客内浏览。&lt;/p&gt;
&lt;h1&gt;简介&lt;/h1&gt;
&lt;h4&gt;我为什么要学汇编&lt;/h4&gt;
&lt;p&gt;​	因为想在寒假手写一下操作系统玩玩，所以提前学一学汇编，到时候放假就可以直接上手写了。&lt;/p&gt;
&lt;h4&gt;什么是汇编语言&lt;/h4&gt;
&lt;p&gt;​	由于处理器只能理解机器语言指令，即 0 和 1 组成的字符串。然而，机器语言对软件开发来说过于晦涩和复杂。因此，低级汇编语言是为特定的处理器系列而设计的，通过符号代码和更易于理解的形式表示各种指令。&lt;/p&gt;
&lt;h4&gt;汇编语言的优点&lt;/h4&gt;
&lt;p&gt;​	学习使用汇编语言可以让人深入了解计算机体现结构和底层硬件工作原理，提供对计算机内部操作的更详细的了解。&lt;/p&gt;
&lt;p&gt;​	我们可以收获：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更加深入了解计算机的体系结构、寄存器、指令集和内存管理&lt;/li&gt;
&lt;li&gt;了解程序是如何在计算机上执行的&lt;/li&gt;
&lt;li&gt;有助于我们编写更高效的代码，可以直接控制底层硬件资源，使你能够优化代码以提高程序的性能&lt;/li&gt;
&lt;li&gt;提高我们调试代码的能力&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;PC 硬件的基本特征&lt;/h4&gt;
&lt;p&gt;​	PC 的主要硬件由处理器、存储器和寄存器组成。寄存器是保存数据和地址的处理器组件。为了执行程序，系统将其从外部设备复制到内部存储器中。处理器负责执行程序指令。&lt;/p&gt;
&lt;p&gt;​	处理器支持以下数据大小：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单词：2 字节数据项&lt;/li&gt;
&lt;li&gt;双字：4 字节（32 位）数据项&lt;/li&gt;
&lt;li&gt;四字：8 字节（64 位）数据项&lt;/li&gt;
&lt;li&gt;段落：16 字节（128 位）区域&lt;/li&gt;
&lt;li&gt;千字节：1024 字节&lt;/li&gt;
&lt;li&gt;兆字节：1,048,576 字节&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;寻址内存中的数据&lt;/h4&gt;
&lt;p&gt;​	处理器控制指令执行的过程称为——&lt;strong&gt;执行周期&lt;/strong&gt;，它通常包含以下几个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;取指令：处理器&lt;strong&gt;从内存中读取下一条指令&lt;/strong&gt;的地址，并将指令加载到指令寄存器中&lt;/li&gt;
&lt;li&gt;译码：处理器对取得的指令进行译码，&lt;strong&gt;确定指令的操作类型和操作数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;执行：处理器执行指令的操作，可能涉及算术运算、逻辑运算、数据传输等&lt;/li&gt;
&lt;li&gt;写回：将执行结果写回到寄存器或内存中，更新存储器或寄存器内容&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	在计算机中，处理器在访问内存时以字节为单位进行操作。考虑一个十六进制数 0725H，它需要两个字节的内存来存储。其中，高位字节或最高有效字节为 07，低位字节为 25.&lt;/p&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;​	需要注意的是，处理器以相反的字节顺序存储数据，即低位字节存储在低内存地址中，高位字节存储在高内存地址中。因此，当处理器将值 0725H 从寄存器传输到内存时，它首先将 25 传输到较低的内存地址，然后将  07 传输到下一个内存地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/Register-Memory.png&quot; alt=&quot;Register-Memory.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	当处理器从内存获取数字数据到寄存器时，它会再次反转字节。这个过程中，有两种内存地址形式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;**绝对地址：**这是具体位置的直接引用，表示数据存储在内存的特定地址。&lt;/p&gt;
&lt;p&gt;例如：如果 x 表示内存地址，则数据 0725H 存储在 x 地址和 x + 1 地址上，分别对应低位字节 25 和高位字节 07.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**段地址（或偏移量）：**这是具有偏移值的内存段的起始地址。段地址与偏移量相结合，给出了实际的内存地址。&lt;/p&gt;
&lt;p&gt;例如：如果有一个段地址 y，那么 x 表示内存中的偏移地址。在这种情况下，数据 0725H 存储在地址 y:x 和 y:x+1 上，分别对应低位字节 25 和 高位字节 07.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h1&gt;安装和环境设置&lt;/h1&gt;
&lt;p&gt;​	在学习过程中，我们需要使用 NASM 汇编器，因为它免费、有据可查，并且可以在 Linux 和 Windows 上使用&lt;/p&gt;
&lt;p&gt;​	首先要验证是否已安装 NASM，可以使用下面的方法验证：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开 Linux 终端&lt;/li&gt;
&lt;li&gt;输入 whereis nasm 并按 Enter&lt;/li&gt;
&lt;li&gt;如果已安装会出现类似 &lt;code&gt;nasm: /usr/bin/nasm&lt;/code&gt; 的行，否则只能看到 &lt;code&gt;nasm:&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	如果没有安装，就需要安装 NASM。&lt;/p&gt;
&lt;p&gt;​	我的机器是 centos7 的虚拟机，我是直接在命令行中进行安装的，安装步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开终端并以 root 用户身份登录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行以下命令更新 yum 软件包列表：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;yum update
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行以下命令安装 NASM：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;yum install nasm
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过程中的询问，输入 y 并按 Enter 键继续&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待安装完成后，使用以下命令验证是否成功安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nasm -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;基本语法&lt;/h1&gt;
&lt;p&gt;汇编程序可以分为三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据部分（data section）&lt;/li&gt;
&lt;li&gt;未初始化数据部分（bss section）&lt;/li&gt;
&lt;li&gt;文本部分（text section）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;data 部分&lt;/h4&gt;
&lt;p&gt;​	数据部分通常用于存储程序中需要初始化的数据。这可以包括常量、变量和其他静态数据。这个部分的数据在程序运行之前被初始化，并且在整个程序的执行过程中保持不变。&lt;/p&gt;
&lt;p&gt;​	声明数据部分的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;section .data
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;bss 部分&lt;/h4&gt;
&lt;p&gt;​	未初始化数据部分用于存储程序中未初始化的全局和静态变量。与数据部分不同，bss 部分的变量在程序加载时不会被初始化，而是在运行时由系统初始化为零或空值。这样可以节省可执行文件的大小，因为在文件中只需要记录这些变量的名称和大小，而不需要存储它们的实际值。&lt;/p&gt;
&lt;p&gt;​	声明 bss 部分的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;section .bss
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;text 部分&lt;/h4&gt;
&lt;p&gt;​	文本部分包含程序的实际代码。这是程序的主要执行部分，包括机器指令和指令的地址。在这个部分，汇编程序将源代码翻译成机器可执行的指令，使得计算机能够按照特定的算法执行相应的操作。&lt;/p&gt;
&lt;p&gt;​	声明 文本部分的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;section .text
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;注释&lt;/h4&gt;
&lt;p&gt;​	汇编语言中的注释以分号&lt;code&gt;;&lt;/code&gt;开头。注释可以独立一行存在，也可以与指令在同一行。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;; This is a line of comments
add eax, ebx ; adds ebx to eax
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;汇编语言语句&lt;/h4&gt;
&lt;p&gt;​	汇编语言程序由三种类型的语句组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可执行指令&lt;/strong&gt;：告诉处理器要执行的操作，每条指令包括操作码和操作数&lt;/li&gt;
&lt;li&gt;**汇编器指令或伪操作：**用于影响汇编过程的方面，它们不会生成机器语言指令&lt;/li&gt;
&lt;li&gt;**宏：**一种文本替换机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;汇编语言语句的语法&lt;/h4&gt;
&lt;p&gt;​	汇编语言语句每行输入一个语句，每个语句都遵循以下格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;[label]    mnemonic    [operands]    [;comment]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	方括号中的字段是可选的。&lt;/p&gt;
&lt;p&gt;​	基本指令由两部分组成，第一部分是哟啊执行的指令名词（或助记符），第二部分是命令的操作数或参数。&lt;/p&gt;
&lt;p&gt;​	以下是一些典型汇编语言语句的示例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MOV指令（数据传送）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;MOV AX, 42       ; 将值42存储到寄存器AX中
MOV BX, AX       ; 将寄存器AX的值传送到寄存器BX中
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ADD和SUB指令（加法和减法）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;ADD AX, BX       ; 将寄存器AX和BX中的值相加，并将结果存储在AX中
SUB CX, 10       ; 从寄存器CX中减去值10，并将结果存储在CX中
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CMP和JMP指令（比较和跳转）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;CMP AX, BX       ; 比较寄存器AX和BX的值
JE  label        ; 如果相等，则跳转到标签label处
JG  another_label ; 如果大于，则跳转到另一个标签another_label处
JL  target_label         ; 如果小于，跳转到目标标签
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;INC和DEC指令（递增和递减）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;INC SI           ; 将寄存器SI中的值递增1
DEC CX           ; 将寄存器CX中的值递减1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LOOP指令（循环）：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;MOV CX, 5        ; 设置循环计数器CX的初始值为5
loop_start:      ; 循环开始标签
   ; 循环体代码
   DEC CX        ; 循环计数器递减1 
   JNZ loop_start; 如果计数器不为零，则跳转到循环开始标签
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;汇编中的 Hello World 程序&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;section .data
    msg db &#39;Hello, world!&#39;, 0xa  ; 要打印的字符串，0xa 是换行符
    len equ $ - msg     ; 字符串的长度

section .text
    global _start     ; 必须为链接器（ld）声明的全局入口点
    
_start:             ; 告诉链接器入口点
    ; write message to stdout
    mov eax, 4       ; 系统调用号（sys_write）
    mov ebx, 1       ; 文件描述符（标准输出）
    mov ecx, msg     ; 要写入的消息
    mov edx, len     ; 消息的长度
    int 0x80         ; 调用内核
    
    ; exit the program
    mov eax, 1       ; 系统调用号（sys_exit）
    xor ebx, ebx     ; 返回码为0
    int 0x80         ; 调用内核
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的代码被编译并执行后，会输出如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Hello, world！
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;在 NASM 中编译和链接汇编程序&lt;/h4&gt;
&lt;p&gt;​	为了能让上面的程序运行起来，我们需要按下面的步骤编译和链接上述程序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用文本编译器输入上述代码并将其保存为 hello.asm，后续的操作都在该目录下进行&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;nasm -f elf hello.asm&lt;/code&gt; 编译汇编程序
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-f elf：&lt;/code&gt;这是 NASM 的一个选项，用于指定生成的目标文件的格式。在这里，&lt;code&gt;elf&lt;/code&gt; 表示目标文件将采用 ELF（Executable and Linkable Format）格式。&lt;/li&gt;
&lt;li&gt;ELF 是一种通用的二进制文件格式，用于可执行文件、目标文件和共享库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果程序没有问题，就会程序名为 hello.o 的程序目标文件&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;ld -m elf_i386 -s -o hello hello.o&lt;/code&gt; 命令，链接目标文件并创建名为 hello 的可执行文件
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ld&lt;/code&gt;: 这是链接器的命令。链接器的作用是将多个目标文件链接在一起，解析符号引用，生成最终的可执行文件。在执行该命令时，链接器会将系统库和其他必要运行时库链接到目标文件 &lt;code&gt;hello.o&lt;/code&gt; 中。我们的代码中由于程序只是在标准输出上打印一条消息，因此系统库中的一些 I/O 相关的函数可能被链接进来，以便程序能够正确地执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-m elf_i386&lt;/code&gt;: 这个选项告诉链接器使用 ELF (Executable and Linkable Format) 文件格式，并且生成 32 位 x86 架构的可执行文件。&lt;code&gt;elf_i386&lt;/code&gt; 表示生成的可执行文件是面向 32 位 x86 架构的 ELF 文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt;: 这个选项用于剥离（strip）可执行文件中的符号表信息。符号表包含了程序中定义的各种符号（如变量、函数名等）的信息。在生产环境中，剥离符号表可以减小可执行文件的大小，但同时也会使得可执行文件不易调试。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o hello&lt;/code&gt;: 这个选项指定生成的可执行文件的输出名称为 &lt;code&gt;hello&lt;/code&gt;。&lt;code&gt;-o&lt;/code&gt; 是指定输出文件的选项，后面跟着输出文件的名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hello.o&lt;/code&gt;: 这是输入的目标文件，它是由 NASM 编译器生成的，包含了汇编代码的机器代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最后通过 &lt;code&gt;./hello&lt;/code&gt; 执行程序&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;内存段&lt;/h1&gt;
&lt;p&gt;​	上面讨论的汇编程序的三个部分，也代码各种内存段。&lt;/p&gt;
&lt;p&gt;​	有趣的是，如果将 section 关键字替换为 segment，将会得到相同的结果，这是因为对于汇编器而言，这两个关键字在某些上下文中是可以互相使用的，这两个关键字都是为了告诉汇编器下面的代码是代码段。&lt;/p&gt;
&lt;h4&gt;内存段&lt;/h4&gt;
&lt;p&gt;​	在分段内存模型中，系统内存被划分为不同的独立段组，每个段组由位于段寄存器中的指针引用。&lt;/p&gt;
&lt;p&gt;​	每个段用于包含特定类其型的数据。其中一个段用于包含指令代码，另一个段用于存储数据元素，第三个段用于保存程序堆栈。&lt;/p&gt;
&lt;p&gt;​	这种划分使得程序可以更灵活地管理内存，有选择地引用不同类型的数据和指令，从而更有效地执行各种计算任务。&lt;/p&gt;
&lt;p&gt;​	因此，我们可以将各种内存段指定为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**数据段：**由 &lt;strong&gt;.data&lt;/strong&gt; 部分和 &lt;strong&gt;.bss&lt;/strong&gt; 部分表示。 .data 部分用于声明内存区域，其中为程序存储数据元素，该部分在数据元素声明后无法扩展，并且在整个程序中保持静态。.bss 部分也是一个静态内存部分，其中包含稍后在程序中声明的数据的缓冲区。该缓冲区被零填充。&lt;/li&gt;
&lt;li&gt;**代码段：**它由 &lt;strong&gt;.text&lt;/strong&gt; 部分表示。这定义了内存中存储指令代码的区域。这也是一个固定区域。&lt;/li&gt;
&lt;li&gt;**堆栈：**该段包含传递给程序内的函数和过程的数据值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;寄存器&lt;/h1&gt;
&lt;p&gt;​	处理器操作主要涉及对数据的处理，而数据通常存储在内存中。然而，内存访问可能会降低处理器速度，因为它需要通过控制总线发送请求并进行复杂的内存访问。&lt;/p&gt;
&lt;p&gt;​	为了提高速度，处理器包含一些内部存储位置，称为寄存器。&lt;/p&gt;
&lt;h4&gt;处理器寄存器&lt;/h4&gt;
&lt;p&gt;​	IA-32架构中包含 10 个 32 位和 6 个 16 位的处理器寄存器，主要分为三类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;**通用寄存器：**通用寄存器用于存储临时数据，进行算术、逻辑运算等操作。&lt;/li&gt;
&lt;li&gt;**控制寄存器：**控制寄存器用于控制和反映处理器的状态。&lt;/li&gt;
&lt;li&gt;**段寄存器：**段寄存器用于存储各个段的起始地址，实现内存访问和管理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	通用寄存器进一步可以分为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据寄存器&lt;/li&gt;
&lt;li&gt;指针寄存器&lt;/li&gt;
&lt;li&gt;索引寄存器&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;数据寄存器&lt;/h4&gt;
&lt;p&gt;​	在IA-32架构中，有四个32位的数据寄存器，分别是EAX、EBX、ECX、EDX。这些寄存器可以按照不同的位数划分为更小的寄存器，具体如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为完整的32位数据寄存器：EAX、EBX、ECX、EDX。&lt;/li&gt;
&lt;li&gt;32 位寄存器的下半部分可用作四个 16 位数据寄存器：AX、BX、CX 和 DX。&lt;/li&gt;
&lt;li&gt;上述4个16位寄存器的下半部分和上半部分可以用作8个8位数据寄存器：AH、AL、BH、BL、CH、CL、DH和 DL 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	一些数据寄存器在算术运算中具有特定用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AX：&lt;/strong&gt; 主累加器，用于输入/输出和大多数算术指令。例如，在乘法运算中，根据操作数的大小将一个操作数存储在EAX或AX或AL寄存器中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BX：&lt;/strong&gt; 被称为基址寄存器，用于索引寻址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CX：&lt;/strong&gt; 被称为计数寄存器，与ECX一样，存储迭代操作中的循环计数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DX：&lt;/strong&gt; 数据寄存器，用于输入/输出操作，与AX寄存器和DX一起使用，用于涉及大值的乘法和除法运算。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;指针寄存器&lt;/h4&gt;
&lt;p&gt;​	指针寄存器是指 32 位的 EIP、ESP 和 EBP 寄存器以及相应的 16 位 右部分 IP、SP 和 BP。&lt;/p&gt;
&lt;p&gt;​	指针寄存器可以分为三类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;**指令指针（IP）：**16 位 IP 寄存器存储下一条要执行的指令的偏移地址。 IP 与 CS 寄存器（代码段）（如CS : IP）关联，给出了代码段中当前指令的完整地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堆栈指针（SP）：&lt;/strong&gt; 16 位 SP 寄存器提供程序堆栈内的偏移值。 SP 与 SS 寄存器（堆栈段）（SS:SP）相关，指的是程序堆栈中数据或地址的当前位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基址指针（BP）：&lt;/strong&gt; 16 位 BP 寄存器主要帮助引用传递给子程序的参数变量。 SS 寄存器中的地址与 BP 中的偏移量相结合，得到参数的位置。 BP 还可以与 DI、SI（索引寄存器） 组合作为基址寄存器进行特殊寻址。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;索引寄存器&lt;/h4&gt;
&lt;p&gt;​	索引寄存器包括32位的 ESI 和 EDI 以及它们的 16 位最右边的部分。SI 和 DI 通常用于索引寻址，并有时用于执行加法和减法操作。这两个索引指针分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;来源索引 (SI)：&lt;/strong&gt; 用作字符串操作的源索引。在字符串处理中，SI通常用于指向源字符串的当前位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的地索引 (DI)：&lt;/strong&gt; 用作字符串操作的目标索引。DI通常用于指向目标字符串的当前位置，特别是在字符串复制等操作中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;控制寄存器&lt;/h4&gt;
&lt;p&gt;​	控制寄存器包括 32 位指令指针寄存器和 32 位标志寄存器，用于管理程序的执行流程和状态。其中的常见标志位有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;溢出标志 (OF)：&lt;/strong&gt; 表示有符号算术运算后数据的高位（最左位）是否溢出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;方向标志 (DF)：&lt;/strong&gt; 确定移动或比较字符串数据的左或右方向。DF为0时，字符串操作从左到右；DF为1时，字符串操作从右到左。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;中断标志 (IF)：&lt;/strong&gt; 决定是否忽略或处理外部中断，如键盘输入。IF为0时禁用外部中断，为1时启用中断。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;陷阱标志 (TF)：&lt;/strong&gt; 允许将处理器设置为单步模式，以便一次执行一条指令，常用于调试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;符号标志 (SF)：&lt;/strong&gt; 显示算术运算结果的符号，由最左边位的高位表示。SF为0表示正结果，为1表示负结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;零标志 (ZF)：&lt;/strong&gt; 表示算术或比较运算的结果是否为零。ZF为1表示零结果，为0表示非零结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;辅助进位标志 (AF)：&lt;/strong&gt; 包含算术运算后从位 3 到位 4 的进位，用于特殊的算术操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;奇偶校验标志 (PF)：&lt;/strong&gt; 表示算术运算结果中1位的总数，用于奇偶校验。PF为1表示奇数个1位，为0表示偶数个1位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进位标志 (CF)：&lt;/strong&gt; 包含算术运算后从高位（最左边）的进位，也存储shift或rotate操作的最后一位内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;段寄存器&lt;/h4&gt;
&lt;p&gt;​	段在计算机内存中是为了组织和管理存储空间而引入的概念。在汇编编程中，处理器通过段寄存器来访问内存位置。以下是关于段的主要信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;代码段（CS）：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;包含要执行的指令的区域。&lt;/li&gt;
&lt;li&gt;由 16 位代码段寄存器（CS 寄存器）存储代码段的起始地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据段（DS）：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;包含数据、常量和工作区的区域。&lt;/li&gt;
&lt;li&gt;由 16 位数据段寄存器（DS 寄存器）存储数据段的起始地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堆栈段（SS）：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;包含过程或子例程的数据和返回地址，实现为堆栈数据结构。&lt;/li&gt;
&lt;li&gt;由16位堆栈段寄存器（SS 寄存器）存储堆栈的起始地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他段寄存器：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;额外段（ES）：&lt;/strong&gt; 提供额外的段来存储数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FS 和 GS：&lt;/strong&gt; 提供额外的段用于特定目的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	在汇编编程中，程序需要访问内存位置。段内的所有内存位置都相对于段的起始地址。段从可被 16 整除的地址开始，因此所有这类内存地址中最右边的十六进制数字通常是 0。为了引用段中的任何内存位置，处理器将段寄存器中的段地址与该位置的偏移值组合起来。&lt;/p&gt;
&lt;h4&gt;示例&lt;/h4&gt;
&lt;p&gt;​	下面的程序会在代码中输出 9 个连续的星号。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;section	.text
   global _start	 ;必须为链接器声明（gcc）
	
_start:	         ;告诉链接器入口点
   mov	edx,len  ;消息长度
   mov	ecx,msg  ;要写入的消息
   mov	ebx,1    ;文件描述符（stdout）
   mov	eax,4    ;系统调用号（sys_write）
   int	0x80     ;调用内核
	
   mov	edx,9    ;消息长度
   mov	ecx,s2   ;要写入的消息
   mov	ebx,1    ;文件描述符（stdout）
   mov	eax,4    ;系统调用号（sys_write）
   int	0x80     ;调用内核
	
   mov	eax,1    ;系统调用号（sys_exit）
   int	0x80     ;调用内核
	
section	.data
msg db &#39;Displaying 9 stars&#39;,0xa ;一条消息
len equ $ - msg  ;消息的长度
s2 times 9 db &#39;*&#39; ;9个星号
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	我们使用以下命令进行编译和执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nasm -f elf nine_stars.asm 
ld -m elf_i386 -s -o nine_stars nine_stars.o
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	输出结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Displaying 9 stars
*********
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;系统调用&lt;/h1&gt;
&lt;p&gt;​	系统调用是用户空间和内核空间之间接口的 API。我们之前已经使用过了 sys_write 和 sys_exit 这两个系统调用，分别用于写入屏幕和退出程序。&lt;/p&gt;
&lt;h4&gt;Linux 系统调用&lt;/h4&gt;
&lt;p&gt;​	我们在汇编程序中使用系统调用，需要按照如下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将系统调用号放入 EAX 寄存器中；&lt;/li&gt;
&lt;li&gt;将系统调用的参数存储在 EBX、ECX 等寄存器中&lt;/li&gt;
&lt;li&gt;调用相关中断（0x80），然后执行 EAX 中的系统调用号对应的程序&lt;/li&gt;
&lt;li&gt;结果通常返回 EAX 寄存器中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	可以存储系统调用参数的存储器有 基址寄存器 EBX、计数寄存器 ECX、数据寄存器 EDX、源索引寄存器 ESI、目标索引寄存器 EDI、基址指针寄存器 EBP。&lt;/p&gt;
&lt;p&gt;​	下面给大家演示一下几个示例：&lt;/p&gt;
&lt;p&gt;​	（1）使用 sys_exit：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;mov eax, 1 ; 系统调用号 sys_exit
int 0x80   ; 调用内核
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	（2）使用 sys_write：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;mov edx, 4		; 消息长度
mov ecx, msg	; 要写入的消息
mov ebx, 1		; 文件描述符
mov eax, 4		; 系统调用号
int 0x80		; 调用内核
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;常见系统调用&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;%eax&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Name&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;%ebx&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;%ecx&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;%edx&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;%esx&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;%edi&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;sys_exit&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;int&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;2&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;sys_fork&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;struct pt_regs&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;3&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;sys_read&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;unsigned int&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;char *&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;size_t&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;sys_write&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;unsigned int&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;const char *&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;size_t&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;sys_open&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;const char *&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;int&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;int&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;6&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;sys_close&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;unsigned int&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;示例&lt;/h4&gt;
&lt;p&gt;​	下面举一个复杂一点的例子，包含了之前我们讲过的 data、bss、text 三个部分，也希望通过这个例子，加深一下大家对 data 部分和 bss 部分的区别&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;section .data                           ; 数据段
   userMsg db &#39;请输入一个数字： &#39;        ; 提示用户输入数字的消息
   lenUserMsg equ $-userMsg             ; 消息的长度
   dispMsg db &#39;您输入的是： &#39;
   lenDispMsg equ $-dispMsg                 

section .bss           ; 未初始化的数据
   num resb 5            ; 用于存储用户输入的变量，5字节

section .text          ; 代码段
   global _start        ; 声明程序入口点

_start:                ; 程序入口
   ; 输出提示消息 &#39;请输入一个数字： &#39;
   mov eax, 4
   mov ebx, 1
   mov ecx, userMsg
   mov edx, lenUserMsg
   int 80h
   ; 读取并存储用户输入
   mov eax, 3
   mov ebx, 2
   mov ecx, num  
   mov edx, 5          ; 读取5字节的信息（数字和符号，1字节）
   int 80h	
   ; 输出消息 &#39;您输入的是： &#39;
   mov eax, 4
   mov ebx, 1
   mov ecx, dispMsg
   mov edx, lenDispMsg
   int 80h  
   ; 输出用户输入的数字
   mov eax, 4
   mov ebx, 1
   mov ecx, num
   mov edx, 5
   int 80h  
   ; 退出程序
   mov eax, 1
   mov ebx, 0
   int 80h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	同样，我们需要通过下述命令来编译运行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nasm -f elf get_num.asm 				# 将汇编程序编译成机器码
ld -m elf_i386 -s -o get_num get_num.o	# 将目标文件和其他必要的文件组合成可执行文件
./get_num 								# 运行可执行文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	输出结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;请输入一个数字： 
123
您输入的是： 123
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;寻址模式&lt;/h1&gt;
&lt;p&gt;​	下面来介绍一个汇编语言中三种基本寻址方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;寄存器寻址&lt;/li&gt;
&lt;li&gt;立即寻址&lt;/li&gt;
&lt;li&gt;内存寻址&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;寄存器寻址&lt;/h4&gt;
&lt;p&gt;​	寄存器寻址模式，其中操作数直接存储在寄存器中，而不涉及内存。这种寻址模式在处理数据时提供了高效的速度，因为它是直接从寄存器中读取或向寄存器中写入数据，而无需涉及到主存储器。&lt;/p&gt;
&lt;p&gt;​	在此模式下，根据指令的不同，寄存器可能是第一个操作数，也有可能是第二个操作数，或者两个操作数都是，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;MOV DX, TAX_RATE
MOV COUNT, CX
MOV EAX, EBX
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;立即寻址&lt;/h4&gt;
&lt;p&gt;​	立即寻址模式，其中一个操作数是常量或者表达式，而不是从内存中获取的。&lt;/p&gt;
&lt;p&gt;​	我们可以通过这种方式定义变量、更改变量值、赋值等操作，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;BYTE_VALUE DB 150
ADD BYTE_VALUE, 65
MOV AX, 45H
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;直接内存寻址&lt;/h4&gt;
&lt;p&gt;​	直接内存寻址用于操作内存中的数据。在该模式下，偏移值直接指定为指令的一部分，通常由变量名指示。这种寻址方式涉及两个操作：定位内存位置和执行操作。&lt;/p&gt;
&lt;p&gt;​	举例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;ADD BYTE_VALUE DL	; 将寄存器 DL 中的值加到内存位置 BYTE_VALUE 的字节值上
MOV BX, WORD_VALUE	; 将内存中的操作数直接赋值给 BX 寄存器
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	上述两种情况下，汇编器会维护一个符号表，其中存储了程序中所使用的所有变量的偏移值，这些偏移值用于在运行时计算实际的内存地址。这种方式使用了一种简单而直接的方法来引用内存中的数据，但相对寄存器寻址或间接寻址来说，它可能导致访问效率稍低。&lt;/p&gt;
&lt;h4&gt;直接偏移寻址&lt;/h4&gt;
&lt;p&gt;​	直接偏移寻址是一种在汇编语言中用于访问数据表的寻址模式。通过使用算术运算符，你直接可以直接计算或指定相对于数据表起始地址的偏移量，从而访问表格中的特定数据。&lt;/p&gt;
&lt;p&gt;​	我们先定义以下数据表，以供我们后续的操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;BYTE_TABLE DB 14, 15, 22, 23
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	然后我们可以通过索引和偏移量的方式操作数据表中的数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;MOV CL, BYTE_TABLE[2]	; 元素索引方式
MOV CL, BYTE_TABLE + 2	; 偏移量方式
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;间接内存寻址&lt;/h4&gt;
&lt;p&gt;​	间接内存寻址是一种利用计算机的段:偏移寻址能力的寻址模式。通常，基址寄存器（例如 EBX、EBP，或简写为 BX、BP）和索引寄存器（DI、SI）被包含在方括号内，用于存储器引用，从而实现对内存中数据的访问。这种寻址模式通常用于处理包含多个元素的变量，比如数组。在数组的情况下，数组的起始地址通常存储在基址寄存器中。&lt;/p&gt;
&lt;p&gt;​	通过下面的代码，演示一下如何通过间接内存寻址访问数组的不同元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;MY_TABLE TIMES 10 DW 0	; 分配了10个字，每个字2字节并初始化为0
MOV EBX, [MY_TABLE]		; 将 MY_TABLE 的有效地址存储到 EBX 寄存器中
MOV [EBX], 110			; 将值 110 存储到 MY_TABLE 的第一个有效地址
ADD EBX, 2				; EBX = EBX + 2
MOV [EBX], 123			; 将值 123 存储到 MY_TABLE 的第二个元素
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;​	用 [] 和 不用 [] 的区别？&lt;/p&gt;
&lt;p&gt;​	对于  &lt;code&gt;MOV [EBX], 110&lt;/code&gt; 和 &lt;code&gt;MOV EBX, 110&lt;/code&gt; 来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MOV [EBX], 110&lt;/code&gt;：是一条间接寻址指令，它将立即数 110 存储到 EBX 寄存器中存储的内存地址指向的位置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MOV EBX, 110&lt;/code&gt;：这是一条直接寻址指令，它将立即数 100 直接加载到 EBX 寄存器中，此时 EBX 中存储的是一个数，而不是内存地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h4&gt;MOV 指令&lt;/h4&gt;
&lt;p&gt;​	MOV 指令是 x86 汇编语言中用于将数据从一个存储空间移动到另一个存储空间的指令，它通常需要两个操作数，语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;MOV destination, source
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	MOV 指令可能有以下五种形式，register（寄存器）、immediate（立即数）、memory（内存）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;MOV register, register
MOV register, immediate
MOV memory, immediate
MOV register, memory
MOV memory, register
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;​	需要注意的是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;两个操作数的大小必须同&lt;/li&gt;
&lt;li&gt;源操作数的值是不变的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	我们上面写的代码其实是存在一些问题的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;MY_TABLE TIMES 10 DW 0	; 分配了10个字，每个字2字节并初始化为0
MOV EBX, [MY_TABLE]		; 将 MY_TABLE 的有效地址存储到 EBX 寄存器中
MOV [EBX], 110			; 将值 110 存储到 MY_TABLE 的第一个有效地址
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	由于 x86 架构中内存访问是按字节寻址的，&lt;code&gt;MOV [EBX], 110&lt;/code&gt; 这条指令可能会被解释为存储到 MY_TABLE 的第一个字节；但可能程序员的目的是存储一个整数值 110 到 MY_TABLE，并且 MY_TABLE 中的每个元素是字，那就会有歧义。&lt;/p&gt;
&lt;p&gt;​	因此，我们需要使用类型说明符来明确指令操作的数据类型和占用的字节数，于是可以像下面这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;MOV [EBX], WORD 110	 ; 将一个字（两个字节）的值 110 存储到 MY_TABLE[0] 中
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	常见的类型说明符如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型说明符&lt;/th&gt;
&lt;th&gt;寻址字节数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BYTE&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WORD&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DWORD&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;QWORD&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TBYTE&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h1&gt;变量&lt;/h1&gt;
&lt;p&gt;​	在汇编语言中，变量的定义和数据的存储通常涉及到不同的指令和规则。&lt;/p&gt;
&lt;p&gt;​	NASM 提供了不同的 define 指令，用于为变量分配存储空间。这些指令用于在数据段中保留和初始化一个或多个字节，常见的有：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;指令&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;用途&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;存储空间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;DB&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;定义 Byte&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;分配1个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;DW&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;定义 Word&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;分配2个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;DD&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;定义 Doubleword&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;分配4个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;DQ&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;定义 Quadword&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;分配8个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;DT&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;定义十个字节&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;分配10个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;​	使用示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;choice      DB &#39;y&#39;
number      DW 12345
neg_number  DW -12345
big_number  DQ 123456789
real_number1 DD 1.234
real_number2 DQ 123.456
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字符的每个字节都以其十六进制的 ASCII 值存储：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个字符都有一个对应的 ASCII 值，它是一个唯一的数值表示。例如，字母 &#39;A&#39; 的 ASCII 值是 65（十六进制为 41），而字母 &#39;B&#39; 的 ASCII 值是 66（十六进制为 42）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你在程序中定义一个字符变量，它的每个字节将被存储为对应字符的 ASCII 值的十六进制表示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;每个十进制值都会自动转换为其 16 位二进制等效值并存储为十六进制数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当你在程序中定义一个十进制值，汇编器会将其自动转换为其 16 位的二进制等效值，并以十六进制形式存储。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如，十进制值 10 会被转换为二进制值 1010，然后以十六进制形式存储为 &quot;A&quot;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理器使用小尾数字节排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;处理器采用小尾数（Little Endian）字节排序，这意味着较低有效字节（最低位字节）存储在内存中的较低地址处，而较高有效字节（最高位字节）存储在内存中的较高地址处。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如，对于十六进制值 0x12345678，在内存中的存储顺序是：78 56 34 12。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;负数将转换为其 2 的补码表示形式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在计算机中，负数通常以 2 的补码形式表示。这种表示方式使得在计算中可以统一处理加法和减法，而不需要额外的逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2 的补码表示形式是通过将正数的二进制表示取反然后加 1 得到的。例如，-5 的二进制表示是将 5 的二进制表示（0000 0101）取反得到（1111 1010），然后加 1 得到（1111 1011）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;短浮点数和长浮点数分别使用 32 位或 64 位表示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;浮点数表示采用 IEEE 754 标准，其中短浮点数（float）通常使用 32 位表示，而长浮点数（double）通常使用 64 位表示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;32 位浮点数包括符号位、8 位指数和 23 位尾数。64 位浮点数包括符号位、11 位指数和 52 位尾数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;​	下面程序演示了 define 指令的使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;section .text
        global _start

section .data
        choice db &#39;y&#39;, 0xa
        len equ $ - choice

_start:
        mov edx, len
        mov ecx, choice
        mov ebx, 1
        mov eax, 4
        int 80h

        mov eax, 1
        int 80h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	编译运行后输出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;y
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;为未初始化数据分配空间&lt;/h4&gt;
&lt;p&gt;​	在程序中，有时我们需要为一些数据保留一些存储空间，但不需要为它们初始化，而是在后续程序运行过程中被赋予实际值。&lt;/p&gt;
&lt;p&gt;​	这个时候，我们就需要用到汇编语言中的保留指令，这些指令用于在内存中分配指定大小的空间，但不对其中的数据进行初始化。&lt;/p&gt;
&lt;p&gt;​	常见的保留指令有：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RESB&lt;/td&gt;
&lt;td&gt;保留一个 Byte（一个字节）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RESW&lt;/td&gt;
&lt;td&gt;保留一个 Word（两个字节）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RESD&lt;/td&gt;
&lt;td&gt;保留一个 Doubleword（四个字节）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RESQ&lt;/td&gt;
&lt;td&gt;保留一个 Quadword（八个字节）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REST&lt;/td&gt;
&lt;td&gt;保留十个字节空间（十个字节）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;多重定义&lt;/h4&gt;
&lt;p&gt;​	一个程序可以定义多个数据定义的语句，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;choice DB &#39;y&#39;
number DW 123
bigbumber DQ 123456789
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这样定义的语句，编辑器会为这些变量分配连续的内存。&lt;/p&gt;
&lt;h4&gt;多次初始化&lt;/h4&gt;
&lt;p&gt;​	times 指令允许对同一值进行多次初始化，这样在定义数组和表示非常有用。可以使用如下语句，创建名为 stars、数据元素类型为DW 的数组，包含 9 个元素，每个初始化为 0.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;stars TIMES 9 DW 0	;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	我们重温一下上面输出 9 个 * 的汇编程序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;section .text
        global _start

section .data
        stars times 9 db &#39;*&#39;

_start:
        mov edx, 9
        mov ecx, stars
        mov ebx, 1
        mov eax, 4
        int 0x80

        mov eax, 1
        int 0x80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	同样编译运行后，会输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;*********
&lt;/code&gt;&lt;/pre&gt;
</description><link>https://studygolang.com/topics/17081</link><guid isPermaLink="false">https://studygolang.com/topics/17081</guid><pubDate>Sat, 23 Dec 2023 12:14:33 GMT</pubDate><author>oYtostarlion</author><category>每日一学</category></item><item><title>Golang引领科技前沿：探索工程师在多领域的关键角色</title><description>&lt;p&gt;&amp;gt; 关注公众号【爱发白日梦的后端】分享技术干货、读书笔记、开源项目、实战经验、高效开发工具等，您的关注将是我的更新动力！&lt;/p&gt;
&lt;p&gt;在科技行业不断演变的背景下，对熟练工程师的需求持续增长，而各种编程语言在塑造数字世界中发挥着关键作用。其中，Golang（或Go）以其高效、简单和可扩展的特性而备受推崇。Golang工程师发现自己能够胜任科技领域内多种角色。让我们深入探讨Golang工程师可以扮演的各种多样化角色。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;后端开发工程师&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Golang以其出色的性能在构建可扩展且高效的后端系统方面表现卓越。Golang工程师通常在设计、开发和维护后端基础设施方面发挥关键作用。他们致力于构建服务器端应用程序、处理数据存储和检索，并确保服务器端逻辑的平稳运行。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;微服务架构师&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;微服务架构已经成为现代软件开发的标准，而Golang特别适合这种方法。Golang工程师可以专注于设计和实现微服务，从而开发模块化且易于维护的软件系统。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;DevOps工程师&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Golang的高效性和速度使其成为编写用于DevOps流程的工具和脚本的优秀选择。Golang工程师可以贡献于自动化部署流程、基础设施供应以及监控系统，提高整个开发生命周期的效率。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;云工程师&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;随着云技术的日益普及，Golang工程师可以专攻云开发。他们致力于创建利用云服务的应用程序，确保其性能和可扩展性。Golang的并发特性使其特别适合云原生应用程序。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;分布式系统工程师&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Golang天生支持并发和并行，使其成为构建分布式系统的理想语言。Golang工程师可以贡献于分布式应用程序的开发，处理不同组件之间的通信，确保容错性和可扩展性。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;安全工程师&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Golang对简单性和可靠性的注重同样体现在安全领域。Golang工程师可以专攻安全角色，确保应用程序和系统对抗各种网络威胁。他们贡献于制定安全编码实践，并进行代码审查以识别潜在的漏洞。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Cosmos区块链开发者&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;随着区块链互操作性的日益突出，Golang工程师可以专攻与Cosmos SDK一起工作，这是一个用于构建可扩展、可互操作的区块链的框架。在这个角色中，Golang工程师贡献于Cosmos生态系统内主权区块链的开发，构建自定义模块，确保与整个网络的兼容性。他们在提升区块链系统的可扩展性、可用性和互联性方面扮演着至关重要的角色，使Golang成为Cosmos区块链开发领域不可或缺的语言。&lt;/p&gt;
&lt;h3&gt;结论&lt;/h3&gt;
&lt;p&gt;Golang工程师在科技行业内有着丰富的机会，这要归功于该语言的多才多艺和高性能。无论是构建可扩展的后端系统，设计微服务，还是为应用程序的安全做贡献，Golang工程师在塑造技术领域中发挥着关键作用。随着科技行业的不断发展，对熟练的Golang专业人才的需求有望增长，对于那些希望在这个充满活力的领域找到自己定位的人来说，这是令人兴奋的时刻。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.golangjob.cn/231218/fbc86e68675504a6853565e8a201a1f7.png&quot; alt=&quot;Snipaste_2023-12-18_23-17-00.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
</description><link>https://studygolang.com/topics/17058</link><guid isPermaLink="false">https://studygolang.com/topics/17058</guid><pubDate>Mon, 18 Dec 2023 15:15:32 GMT</pubDate><author>TimLiuDream</author><category>每日一学</category></item><item><title>选择适合微服务的编程语言</title><description>&lt;p&gt;&amp;gt; 关注公众号【爱发白日梦的后端】分享技术干货、读书笔记、开源项目、实战经验、高效开发工具等，您的关注将是我的更新动力！&lt;/p&gt;
&lt;p&gt;讨论编程语言就像是一场政治辩论。每个开发者都会过分捍卫他/她所使用的编程语言。然而，编程语言应该被看作是它们真正是的东西，即一种工作工具。每种编程语言都有特定的目的。&lt;/p&gt;
&lt;p&gt;基本上，你听说过的任何编程语言都可以用于开发微服务。你需要确定应用程序的要求和边界上下文。也许微服务执行大量的I/O操作或处理大规模的数据。&lt;/p&gt;
&lt;p&gt;Python以其易于理解的语法和快速开发的特性脱颖而出。Java提供了可靠性和强大的性能选项。Go语言的轻量级结构有助于在微服务之间进行快速通信。&lt;/p&gt;
&lt;p&gt;虽然每种语言都有其独特的优势，但最佳的语言选择取决于项目的具体需求。在这篇文章中，你将探讨微服务世界中语言的多样性，并找到确定哪种语言最适合的线索。&lt;/p&gt;
&lt;p&gt;那么，我们如何选择合适的语言呢？在选择之前，有一些参数需要分析。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;熟练度&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在软件开发的动态世界中，开发者在特定编程语言中的技能水平决定了他们在该语言中的熟练程度。熟练度不仅仅包括了对语言基本语法的了解；它还涉及理解该语言的细微差别、最佳实践和开发过程。&lt;/p&gt;
&lt;p&gt;熟练度水平不仅包括开发者编写代码的能力，还包括高级技能，如调试、代码优化和实施安全措施。开发者凭借他们对首选语言的深入了解，不仅影响他们的项目，还找到机会在广泛的技术领域提升他们的技能。熟练度在确定使用语言实施的项目的质量和有效性方面发挥着至关重要的作用，强调了每个开发者在其选择的语言中优先考虑掌握过程的重要性。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;这是选择微服务的编程语言的关键要求。当我们谈论性能时，许多要点浮现：网络通信层、访问数据库、服务器可用性等等，所有这些都是微服务的关键点。&lt;/p&gt;
&lt;p&gt;在谈论性能时，不论开发团队的技能如何，我们都必须选择正确的语言。性能涉及到类似于响应请求时代码行为的指标。当然，个人或团队的性能不包括在此度量标准中。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;开发实用性&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;对生产中的功能实现速度进行测量的要求是至关重要的，涉及到现有和潜在开发团队。应用程序开发的成功往往与代码的简洁性和可理解性有关，这对于容纳变更和引入新功能至关重要。良好的编程实践有助于理解遗留代码，而语言复杂性可能会妨碍这个过程。有些编程语言可能提供高性能，但对于新的实现可能耗时较长。在创业公司推出最小可行产品（MVP）的情景中，其中快速更新功能至关重要，实用性通常会超过性能方面的考虑。这在开发微服务并选择编程语言以提高效率时尤为重要。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;可扩展性成本&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;扩展应用程序的成本取决于两个关键因素：所选择堆栈在实现软件方面的速度，包括处理算法和请求响应，以及在应用程序的业务方面具有可扩展性的能力，考虑到应用新特性的时间和可预测性。在微服务架构中，可扩展性成本与更小、集成度较低的组件相关联。对于像在线游戏这样需要实时交互的应用程序，实时互动性的考虑至关重要，而像报纸或流媒体服务这样的说明性应用程序可能更注重处理效率而不是实时动态。了解要开发的微服务的性质对于有效地管理成本至关重要。&lt;/p&gt;
&lt;p&gt;在软件开发的动态领域中，选择Java、C#、Go、Python和JavaScript等编程语言在实施微服务架构时发挥着至关重要的作用。每种语言都有其独特的优势和劣势。Java和C#在为大规模项目提供可靠性和性能方面表现出色，但它们也带有诸如平台依赖性和社区规模等缺点。Go以其快速的编译时间和对并行编程的内置支持脱颖而出，但在语言特性和相对年轻的生态系统方面可能存在局限性。Python以其易读的语法和丰富的库支持而闪耀，尽管其性能有时可能滞后。JavaScript通过其在前端和后端都能工作的能力提供了灵活性，但其语言复杂性和偶尔的性能问题可能是挑战。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;总的来说，仔细考虑在采用微服务架构时选择的编程语言是至关重要的。每种语言都有其独特的优缺点，选择应该基于项目的需求和开发团队的专业知识。在实践中，应用程序的需求、快速开发、性能或可扩展性等因素将决定哪种语言最适合。为了取得最佳结果，团队成员了解他们在所选择语言中的能力和项目的具体需求至关重要。&lt;/p&gt;
</description><link>https://studygolang.com/topics/17041</link><guid isPermaLink="false">https://studygolang.com/topics/17041</guid><pubDate>Thu, 14 Dec 2023 13:52:16 GMT</pubDate><author>TimLiuDreamLIGUANGYAO</author><category>每日一学</category></item><item><title>[go 面试] 雪花算法与分布式ID生成</title><description>&lt;p&gt;&amp;gt; 关注公众号【爱发白日梦的后端】分享技术干货、读书笔记、开源项目、实战经验、高效开发工具等，您的关注将是我的更新动力！&lt;/p&gt;
&lt;h2&gt;生成全局唯一ID的雪花算法原理&lt;/h2&gt;
&lt;p&gt;雪花算法是一种用于生成全局唯一ID的算法，最初由Twitter开发，用于解决分布式系统中生成ID的问题。其核心思想是将一个64位的长整型ID划分成多个部分，每个部分用于表示不同的信息，确保了生成的ID在分布式环境下的唯一性。&lt;/p&gt;
&lt;h3&gt;ID结构&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;符号位（1位）&lt;/strong&gt;：始终为0，用于保证ID为正数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间戳（41位）&lt;/strong&gt;：表示生成ID的时间戳，精确到毫秒级。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作节点ID（10位）&lt;/strong&gt;：表示生成ID的机器的唯一标识。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;序列号（12位）&lt;/strong&gt;：表示在同一毫秒内生成的多个ID的序列号。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;生成步骤&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;获取当前时间戳，精确到毫秒级。&lt;/li&gt;
&lt;li&gt;如果当前时间小于上次生成ID的时间，或者在同一毫秒内生成的ID数量超过最大值，等待下一毫秒再继续生成。&lt;/li&gt;
&lt;li&gt;如果当前时间等于上次生成ID的时间，序列号自增1。&lt;/li&gt;
&lt;li&gt;如果当前时间大于上次生成ID的时间，序列号重新从0开始。&lt;/li&gt;
&lt;li&gt;将各个部分的值组合，得到最终的64位ID。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Go实现雪花算法的高并发ID生成器&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

const (
	workerBits     = 10
	sequenceBits   = 12
	workerMax      = -1 ^ (-1 &amp;amp;lt;&amp;amp;lt; workerBits)
	sequenceMask   = -1 ^ (-1 &amp;amp;lt;&amp;amp;lt; sequenceBits)
	timeShift      = workerBits + sequenceBits
	workerShift    = sequenceBits
	epoch          = 1609459200000
)

type Snowflake struct {
	mu          sync.Mutex
	lastTime    int64
	workerID    int64
	sequence    int64
}

func NewSnowflake(workerID int64) *Snowflake {
	if workerID &amp;amp;lt; 0 || workerID &amp;amp;gt; workerMax {
		panic(fmt.Sprintf(&quot;worker ID must be between 0 and %d&quot;, workerMax))
	}
	return &amp;amp;amp;Snowflake{
		lastTime: time.Now().UnixNano() / 1e6,
		workerID: workerID,
		sequence: 0,
	}
}

func (sf *Snowflake) NextID() int64 {
	sf.mu.Lock()
	defer sf.mu.Unlock()

	currentTime := time.Now().UnixNano() / 1e6

	if currentTime &amp;amp;lt; sf.lastTime {
		panic(fmt.Sprintf(&quot;clock moved backwards, refusing to generate ID for %d milliseconds&quot;, sf.lastTime-currentTime))
	}

	if currentTime == sf.lastTime {
		sf.sequence = (sf.sequence + 1) &amp;amp;amp; sequenceMask
		if sf.sequence == 0 {
			for currentTime &amp;amp;lt;= sf.lastTime {
				currentTime = time.Now().UnixNano() / 1e6
			}
		}
	} else {
		sf.sequence = 0
	}

	sf.lastTime = currentTime

	id := (currentTime-epoch)&amp;amp;lt;&amp;amp;lt;timeShift | (sf.workerID &amp;amp;lt;&amp;amp;lt; workerShift) | sf.sequence
	return id
}

func main() {
	sf := NewSnowflake(1) // 假设工作节点ID为1

	for i := 0; i &amp;amp;lt; 10; i++ {
		id := sf.NextID()
		fmt.Println(id)
		time.Sleep(time.Millisecond)
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;高并发下的唯一性和递增性保障&lt;/h2&gt;
&lt;p&gt;在高并发场景下，保障雪花算法生成的ID唯一性和递增性的关键在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;唯一性：&lt;/strong&gt; 工作节点ID的设置保证了不同节点生成的ID不会冲突。序列号的自增和位运算保证了同一毫秒内生成的ID唯一。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递增性：&lt;/strong&gt; 在同一毫秒内生成的多个ID按序列号的递增顺序排列。即使在极端情况下，同一毫秒内生成的ID数量超过了最大值，会等待下一毫秒重新开始，也保证了递增性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总体来说，雪花算法在高并发下是一个可靠的ID生成方案。它的高性能和低碰撞概率使得它在分布式系统中被广泛应用。&lt;/p&gt;
</description><link>https://studygolang.com/topics/17034</link><guid isPermaLink="false">https://studygolang.com/topics/17034</guid><pubDate>Tue, 12 Dec 2023 15:01:44 GMT</pubDate><author>TimLiuDreamLIGUANGYAO</author><category>每日一学</category></item><item><title>[go 面试] 缓存策略与应对数据库压力的良方</title><description>&lt;p&gt;&amp;gt; 关注公众号【爱发白日梦的后端】分享技术干货、读书笔记、开源项目、实战经验、高效开发工具等，您的关注将是我的更新动力！&lt;/p&gt;
&lt;p&gt;在高并发场景中，缓存是提高系统性能的关键利器。然而，缓存穿透、缓存击穿、缓存雪崩等问题可能会给系统带来严重的负担。本文将深入探讨这些问题，并提供有效的解决办法，使用 Go 语言示例代码。&lt;/p&gt;
&lt;h2&gt;1. 缓存穿透&lt;/h2&gt;
&lt;h3&gt;1.1 问题描述&lt;/h3&gt;
&lt;p&gt;缓存穿透是指每次查询都没有命中缓存，导致每次都需要去数据库中查询，可能引起数据库压力剧增。&lt;/p&gt;
&lt;h3&gt;1.2 解决办法&lt;/h3&gt;
&lt;p&gt;为不存在的数据设置缓存空值，防止频繁查询数据库。同时，为了健壮性，需要设置这些缓存空值的过期时间，以避免无效的缓存占用内存。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 示例代码
func queryDataFromCacheOrDB(key string) (string, error) {
    // 查询缓存
    data, err := cache.Get(key)
    if err == nil {
        return data, nil
    }

    // 查询数据库
    data = queryDataFromDB(key)

    // 将数据写入缓存，设置过期时间
    cache.Set(key, data, expirationTime)

    return data, nil
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2. 缓存击穿&lt;/h2&gt;
&lt;h3&gt;2.1 问题描述&lt;/h3&gt;
&lt;p&gt;在高并发情况下，大量请求同时查询同一个缓存键，若该缓存刚好失效，将导致同时有大量请求直接访问数据库，增加数据库负载。&lt;/p&gt;
&lt;h3&gt;2.2 解决办法&lt;/h3&gt;
&lt;p&gt;采用锁的机制，只有第一个获取锁的线程去请求数据库，并在数据库返回后更新缓存。其他线程在拿到锁后需要重新查询一次缓存，避免重复访问数据库。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 示例代码
func queryDataWithLock(key string) (string, error) {
    // 尝试获取锁
    if acquireLock(key) {
        defer releaseLock(key)

        // 查询缓存
        data, err := cache.Get(key)
        if err == nil {
            return data, nil
        }

        // 查询数据库
        data = queryDataFromDB(key)

        // 将数据写入缓存，设置过期时间
        cache.Set(key, data, expirationTime)

        return data, nil
    }

    // 获取锁失败，等待一段时间后重试
    time.Sleep(retryInterval)
    return queryDataWithLock(key)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3. 缓存雪崩&lt;/h2&gt;
&lt;h3&gt;3.1 问题描述&lt;/h3&gt;
&lt;p&gt;缓存中大量数据同时失效，导致大量请求直接访问后端数据库，可能引发数据库宕机。&lt;/p&gt;
&lt;h3&gt;3.2 解决办法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用集群，减少宕机几率。&lt;/li&gt;
&lt;li&gt;限流和降级，保护后端服务。&lt;/li&gt;
&lt;li&gt;设置合理的缓存过期时间，分散缓存失效时间。&lt;/li&gt;
&lt;li&gt;热点数据预加载，提前刷新缓存。&lt;/li&gt;
&lt;li&gt;添加缓存失效的随机性，防止同时失效。&lt;/li&gt;
&lt;li&gt;多级缓存，使用本地缓存和分布式缓存。&lt;/li&gt;
&lt;li&gt;实时监控和预警，及时发现异常并采取措施。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 示例代码
func queryDataFromCacheOrDBWithExpiration(key string) (string, error) {
    // 查询缓存
    data, err := cache.Get(key)
    if err == nil {
        return data, nil
    }

    // 查询数据库
    data = queryDataFromDB(key)

    // 将数据写入缓存，设置合理的过期时间
    cache.Set(key, data, calculateExpirationTime())

    return data, nil
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;4. 解决热点数据集中失效的问题&lt;/h2&gt;
&lt;h3&gt;4.1 问题描述&lt;/h3&gt;
&lt;p&gt;热点数据集中失效时，可能导致大量请求同时访问数据库，引起数据库压力激增。&lt;/p&gt;
&lt;h3&gt;4.2 解决办法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;设置不同的失效时间，分散缓存失效时机。&lt;/li&gt;
&lt;li&gt;采用加锁机制，确保只有一个线程更新缓存。&lt;/li&gt;
&lt;li&gt;永不失效，通过定时任务对即将失效的缓存进行更新和设置失效时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 示例代码
func queryHotDataFromCacheOrDB(key string) (string, error) {
    // 查询缓存
    data, err := cache.Get(key)
    if err == nil {
        return data, nil
    }

    // 尝试获取锁
    if acquireLock(key) {
        defer releaseLock(key)

        // 重新查询缓存
        data, err := cache.Get(key)
        if err == nil {
            return data, nil
        }

        // 查询数据库
        data = queryDataFromDB(key)

        // 将数据写入缓存，永不失效
        cache.Set(key, data, neverExpire)

        return data, nil
    }

    // 获取锁失败，等待一段时间后重试
    time.Sleep(retryInterval)
    return queryHotDataFromCacheOrDB(key)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过以上&lt;a href=&quot;http://baidu.com/&quot;&gt;策略&lt;/a&gt;，可以更好地应对缓存问题，保障系统的稳定性和性能。选择合适的解决方案，取决于具体的业务场景和需求。&lt;/p&gt;
</description><link>https://studygolang.com/topics/17028</link><guid isPermaLink="false">https://studygolang.com/topics/17028</guid><pubDate>Mon, 11 Dec 2023 14:44:26 GMT</pubDate><author>TimLiuDreamwzw123321</author><category>每日一学</category></item><item><title>初识分布式键值对存储etcd</title><description>&lt;p&gt;&amp;gt; 更好的阅读体验，请点击 &amp;lt;a href=&quot;&lt;a href=&quot;https://www.yinkai.cc/post/8aed7f96a55e6cbfb48ddba0188f4bb6&quot;&gt;https://www.yinkai.cc/post/8aed7f96a55e6cbfb48ddba0188f4bb6&lt;/a&gt;&quot;&amp;gt;YinKai &#39;s Blog&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;​	大家好，今天我带大家来认识一下 etcd。&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;h1&gt;一、什么是 etcd&lt;/h1&gt;
&lt;p&gt;​	etcd 是一个开源的分布式键值存储系统，主要用于构建分布式系统中那点服务发现、配置管理、分布式锁等场景。它采用 Raft 一致性算法来确保所有节点上的数据一致性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/etcd%E6%9E%B6%E6%9E%84.png&quot; alt=&quot;etcd架构&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	下面我们来讲讲 etcd 的基本架构组成要点，以及一些对应的概念：&lt;/p&gt;
&lt;h4&gt;节点&lt;/h4&gt;
&lt;p&gt;​	etcd 集群由多个节点组成。每个节点都运行着 etcd 的服务，并负责存储数据、处理客户端请求以及与其他节点通信。&lt;/p&gt;
&lt;p&gt;​	etcd 架构的节点有三种角色，分别是：Leader、Follower、候选人。&lt;/p&gt;
&lt;p&gt;​	Leader 具有唯一性，Leader 挂掉之后，会从 Follower 选择一个成为候选人，参与新一次的领导人的选举。&lt;/p&gt;
&lt;p&gt;​	在 etcd 节点基础服务中，关键组件包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**boltdb：**作为底层存储引擎，boltdb 提供了支持事务的键值存储，用于存储节点的状态和数据。这确保了数据在节点重启后依然可用。&lt;/li&gt;
&lt;li&gt;**Wal（Write-Ahead-Log）：**Wal 是 etcd 中的预写式日志，记录所有的写入操作。在实际的键值存储操作之前，etcd 将操作写入 Wal，然后再将数据谢日 boltdb。这一机制保证了数据的一致性和持久性。&lt;/li&gt;
&lt;li&gt;**gRPC Server：**etcd 节点之间和客户端节点之间的通信采用 gRPC 协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Raft 一致性算法&lt;/h4&gt;
&lt;p&gt;​	etcd 使用 Raft 算法来保证分布式中节点之间的一致性。Raft 算法将集群中的节点分为 Leader、Follower 和 Candidate 三种角色，通过选举机制选出 Leader，并由 Leader 负载处理客户端请求和更新集群中的数据。Leader 将更新操作复制到其他节点，确保所有节点数据一致性。&lt;/p&gt;
&lt;h4&gt;数据存储&lt;/h4&gt;
&lt;p&gt;​	etcd 使用键值对（Key-Value）的方式存储数据。每个节点都保存着整个集群的数据副本。数据可以通过 HTTP 或 gRPC 接口进行读写操作。etcd 的数据存储是强一致性的，即当数据提交后，所有节点上的数据都会保持一致性。&lt;/p&gt;
&lt;h4&gt;选主过程&lt;/h4&gt;
&lt;p&gt;​	当一个 etcd 集群启动时，所有节点都是 Follower 角色。通过 Raft 选主过程，集群中的节点将选举出一个 Leader。Leader 负责处理客户端的读写请求，并将更新操作同步给其他节点。Follower 负责接收 Leader 的同步请求并保持数据一致。&lt;/p&gt;
&lt;h4&gt;分布式通信&lt;/h4&gt;
&lt;p&gt;​	etcd 集群中的节点通过相互通信来维护一致性。节点之间通过心跳机制保持连接。Leader 定期发送心跳消息给 Follower，以确保节点之间通信正常。同时，Leader 将客户端的写请求同步给其他节点，确保数据的一致性。&lt;/p&gt;
&lt;h4&gt;快照&lt;/h4&gt;
&lt;p&gt;​	为了减少数据传输的开销，etcd 使用快照机制。当节点的数据过大时，etcd 将节点的状态进行快照，只保留最新的快照和后续的变更日志，以便在需要时进行恢复，之前的预写式日志就可以删除了，以此来节省磁盘空间，保持系统的性能。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​	总体而言，etcd 的基本结构就是通过这样一些机制来实现了分布式系统中的数据一致性，并通过多节点的协同工作来提供可靠、稳定、高性能的分布式键值存储服务。&lt;/p&gt;
&lt;h1&gt;二、分布式部署 etcd&lt;/h1&gt;
&lt;p&gt;​	下面我们将使用虚拟机来部署一个 etcd 集群，为了避免对我们的虚拟机造成影响，我们这里使用 docker 的方式来进行部署。&lt;/p&gt;
&lt;h4&gt;官方示例&lt;/h4&gt;
&lt;p&gt;​	打开链接 &lt;a href=&quot;https://github.com/etcd-io/etcd/releases&quot;&gt;Releases · etcd-io/etcd (github.com)&lt;/a&gt; ，我们可以看到有教我们如何使用 docker 进行部署，下面我们来看看这些命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rm -rf /tmp/etcd-data.tmp &amp;amp;amp;&amp;amp;amp; mkdir -p /tmp/etcd-data.tmp &amp;amp;amp;&amp;amp;amp; \
  docker rmi gcr.io/etcd-development/etcd:v3.5.10 || true &amp;amp;amp;&amp;amp;amp; \
  docker run \
  -p 2379:2379 \
  -p 2380:2380 \
  --mount type=bind,source=/tmp/etcd-data.tmp,destination=/etcd-data \
  --name etcd-gcr-v3.5.10 \
  gcr.io/etcd-development/etcd:v3.5.10 \
  /usr/local/bin/etcd \
  --name s1 \
  --data-dir /etcd-data \
  --listen-client-urls http://0.0.0.0:2379 \
  --advertise-client-urls http://0.0.0.0:2379 \
  --listen-peer-urls http://0.0.0.0:2380 \
  --initial-advertise-peer-urls http://0.0.0.0:2380 \
  --initial-cluster s1=http://0.0.0.0:2380 \
  --initial-cluster-token tkn \
  --initial-cluster-state new \
  --log-level info \
  --logger zap \
  --log-outputs stderr

docker exec etcd-gcr-v3.5.10 /usr/local/bin/etcd --version
docker exec etcd-gcr-v3.5.10 /usr/local/bin/etcdctl version
docker exec etcd-gcr-v3.5.10 /usr/local/bin/etcdutl version
docker exec etcd-gcr-v3.5.10 /usr/local/bin/etcdctl endpoint health
docker exec etcd-gcr-v3.5.10 /usr/local/bin/etcdctl put foo bar
docker exec etcd-gcr-v3.5.10 /usr/local/bin/etcdctl get foo
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rm -rf /tmp/etcd-data.tmp &amp;amp;amp;&amp;amp;amp; mkdir -p /tmp/etcd-data.tmp&lt;/code&gt;：删除并创建 &lt;code&gt;/tmp/etcd-data.tmp&lt;/code&gt; 目录，这是为了防止我们的目录下已经存在该目录，用于存储 etcd 的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker rmi gcr.io/etcd-development/etcd:v3.5.10 || true&lt;/code&gt;: 删除 etcd 镜像，如果不存在则不报错。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker run ...&lt;/code&gt;：启动 etcd 容器，参数如下：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-p 2379:2379&lt;/code&gt;：映射容器的 2379 端口到主机的 2379 端口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p 2380:2380&lt;/code&gt;: 映射容器的 2380 端口到主机的 2380 端口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--mount type=bind,source=/tmp/etcd-data.tmp,destination=/etcd-data&lt;/code&gt;: 将主机的 &lt;code&gt;/tmp/etcd-data.tmp&lt;/code&gt; 目录绑定到容器的 &lt;code&gt;/etcd-data&lt;/code&gt; 目录，用于持久化 etcd 的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--name etcd-gcr-v3.5.10&lt;/code&gt;: 指定容器的名称为 &lt;code&gt;etcd-gcr-v3.5.10&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gcr.io/etcd-development/etcd:v3.5.10&lt;/code&gt;: 使用 etcd 官方提供的 Docker 镜像。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/local/bin/etcd ...&lt;/code&gt;: 启动 etcd 的命令及相关参数。这里后面会做讲解。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker exec etcd-gcr-v3.5.10 /usr/local/bin/etcd --version&lt;/code&gt;: 在容器内执行 &lt;code&gt;etcd --version&lt;/code&gt; 命令，输出 etcd 的版本信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker exec etcd-gcr-v3.5.10 /usr/local/bin/etcdctl version&lt;/code&gt;: 在容器内执行 &lt;code&gt;etcdctl version&lt;/code&gt; 命令，输出 etcdctl 的版本信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker exec etcd-gcr-v3.5.10 /usr/local/bin/etcdutl version&lt;/code&gt;: 这一行命令有误，应为 &lt;code&gt;docker exec etcd-gcr-v3.5.10 /usr/local/bin/etcdutl version&lt;/code&gt;。这个命令在容器内执行 &lt;code&gt;etcdutl version&lt;/code&gt;，输出 etcdutl 的版本信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker exec etcd-gcr-v3.5.10 /usr/local/bin/etcdctl endpoint health&lt;/code&gt;: 在容器内执行 &lt;code&gt;etcdctl endpoint health&lt;/code&gt;，检查 etcd 集群的健康状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker exec etcd-gcr-v3.5.10 /usr/local/bin/etcdctl put foo bar&lt;/code&gt;: 在容器内执行 &lt;code&gt;etcdctl put foo bar&lt;/code&gt;，将键值对 &lt;code&gt;foo: bar&lt;/code&gt; 存储到 etcd 集群中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker exec etcd-gcr-v3.5.10 /usr/local/bin/etcdctl get foo&lt;/code&gt;: 在容器内执行 &lt;code&gt;etcdctl get foo&lt;/code&gt;，获取键 &lt;code&gt;foo&lt;/code&gt; 对应的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	上面只是官方给我们的使用示例，我们做一个参考就行，我们可以按照自己的方式进行部署。&lt;/p&gt;
&lt;h4&gt;开始部署&lt;/h4&gt;
&lt;h5&gt;创建容器&lt;/h5&gt;
&lt;p&gt;​	由于我们采用 docker 的方式进行部署，故第一步肯定是下载镜像。&lt;/p&gt;
&lt;p&gt;​	我们这里通过 &lt;a href=&quot;https://quay.io/repository/coreos/etcd?tab=tags&amp;amp;tag=latest&quot;&gt;coreos/etcd · Quay&lt;/a&gt; 找到我们想要的 docker 镜像，我这里下载 v3.5.5 ，选择 Docker Pull（by tag），获取到对应的下载链接。&lt;/p&gt;
&lt;p&gt;​	然后来到我们的虚拟机，执行 &lt;code&gt;docker pull quay.io/coreos/etcd:v3.5.5&lt;/code&gt; 拉取镜像，当前前提是需要在虚拟机上安装并启动 docker 服务，安装这里就不再讲解了，大家可以去查看对应的资料进行安装和启动。&lt;/p&gt;
&lt;p&gt;​	拉取完成后，我们可以通过 docker images 命令检查一下是否成功拉取到镜像：
&lt;img src=&quot;https://studygolang.com/images/images.png&quot; alt=&quot;images&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	根据我们拉取到的镜像，启动容器 &lt;code&gt;docker run -dit quay.io/coreos/etcd:v3.5.5 sh&lt;/code&gt;，通过 docker ps -a 查看容器 ID，根据进入 etcd 容器的交互模式 &lt;code&gt;docker exec -it eeb9a5e45d9e sh&lt;/code&gt;。&lt;/p&gt;
&lt;h5&gt;验证并认识参数&lt;/h5&gt;
&lt;p&gt;​	我们可以使用 etcd -h 命令检查是否能够访问 etcd 服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/etcd-h.png&quot; alt=&quot;etcd-h&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	出现上面这个界面，就说明我们的 etcd 容器已经成功创建了，刚好借着 etcd -h 这个命令我们来看一些启动 etcd 集群需要了解的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**--name：**指定 etcd 服务器的名称，以此来区分集群中不同的 etcd 节点&lt;/li&gt;
&lt;li&gt;**--data-dir：**指定 etcd 保存数据的目录，用于存储 etcd 数据库文件，包括 kv 数据和元数据&lt;/li&gt;
&lt;li&gt;**--wal-dir：**指定 etcd 预写式日志的目录，它记录了 etcd 数据库所有的变更，以确保数据的一致性和持久性&lt;/li&gt;
&lt;li&gt;**snapshot-count：**设置 etcd 触发快照的触发次数，当写入预写式日志的次数达到该值，就会生成一次快照。&lt;/li&gt;
&lt;li&gt;**listen-peer-urls：**指定 etcd 服务器监听的对等节点通信地址， 用于集群中节点之间的通信，传递心跳、日志复制等信息。端口通常为 2380，即暴露给其他节点的通信地址。&lt;/li&gt;
&lt;li&gt;**--listen-client-urls：**指定 &lt;code&gt;etcd&lt;/code&gt; 服务器监听的客户端通信地址。 用于客户端与 &lt;code&gt;etcd&lt;/code&gt; 服务器进行通信，包括查询和修改 key-value 数据等操作。通常端口为 2379，即对外提供的 etcd 服务节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--initial-advertise-peer-urls：&lt;/strong&gt; 指定 &lt;code&gt;etcd&lt;/code&gt; 服务器用于集群中通信的地址。用于告知其他节点该节点的通信地址，集群中其他节点将通过这个地址与该节点进行通信。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--initial-cluster：&lt;/strong&gt; 指定初始集群的成员信息。用于告知 &lt;code&gt;etcd&lt;/code&gt; 服务器集群中的其他节点。格式为&lt;code&gt;&amp;amp;lt;name&amp;amp;gt;=&amp;amp;lt;url&amp;amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;**--initial-cluster-state：**指定 &lt;code&gt;etcd&lt;/code&gt; 服务器在集群启动时的状态。 &#39;new&#39; 表示新的集群，&#39;existing&#39; 表示已经存在的集群。&lt;/li&gt;
&lt;li&gt;**--initial-cluster-token：**指定新创建的集群的 token。用于标识一个集群，确保不同的集群拥有不同的 token。&lt;/li&gt;
&lt;li&gt;**advertise-client-urls：**指定 &lt;code&gt;etcd&lt;/code&gt; 服务器广播给客户端的地址。用于告知客户端与 &lt;code&gt;etcd&lt;/code&gt; 服务器进行通信的地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;配置集群信息&lt;/h5&gt;
&lt;p&gt;​	认识并了解了启动集群所必备的参数和信息，我们开始配置集群信息。&lt;/p&gt;
&lt;p&gt;​	我们的集群，以同一台虚拟机使用 docker 启动 3 个不同的 etcd 服务，来模拟集群中的三个节点，并且为了展示集群的功能，所以我们再准备第四个配置文件。所以我们需要去写 4 个 etcd 节点配置文件。&lt;/p&gt;
&lt;p&gt;​	我们可以在虚拟机 root 目录下创建 etcd 文件夹，并在 etcd 文件夹里创建 etcdconf 文件夹，使用 vim etcd0.yaml 创建配置文件，配置内容如下：&lt;/p&gt;
&lt;h6&gt;etcd0.yaml&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# 节点名称
name: &quot;etcdnode0&quot;
# 数据存储目录
data-dir: &quot;/etcd-data/data&quot;
# 预写式日志存储目录
wal-dir: &quot;/etcd-data/wal&quot;
# 集群成员之间通讯使用URL
listen-peer-urls: &quot;http://0.0.0.0:2380&quot;
# 集群提供给外部客户端访问的URL，即外部客户端必须通过制定的IP加端口访问etcd
listen-client-urls: &quot;http://0.0.0.0:2379&quot;

# 集群配置
initial-advertise-peer-urls: &quot;http://192.168.235.128:2380&quot;
# 集群初始成员配置，是etcd静态部署的核心初始化配置，它说明了当前集群由哪些URLs组成，此处default为节点名称
initial-cluster: &quot;etcdnode0=http://192.168.235.128:2380,etcdnode1=http://192.168.235.128:12380,etcdnode2=http://192.168.235.128:22380&quot;
# 初始化集群状态（new 或 existing）
initial-cluster-state: &quot;new&quot;
# 引导期间etcd集群的初始集群令牌，防止不同集群之间产生交互
initial-cluster-token: &quot;etcd-cluster&quot;
# 向客户端发布的服务端节点
advertise-client-urls: &quot;http://192.168.235.128:2379&quot;
logger: &quot;zap&quot;
# 配置日志级别，仅支持 debuf、info、warn、error、panic、or fatal
log-level: &quot;warn&quot;
log-outputs:
  - &quot;stderr&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	参数的意义，我们已经在上面讲解过了，下面就讲所有的配置文件一并给大家：&lt;/p&gt;
&lt;h6&gt;etcd1.yaml&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# 节点名称
name: &quot;etcdnode1&quot;
# 数据存储目录
data-dir: &quot;/etcd-data/data&quot;
# 预写式日志存储目录
wal-dir: &quot;/etcd-data/wal&quot;
# 集群成员之间通讯使用URL
listen-peer-urls: &quot;http://0.0.0.0:12380&quot;
# 集群提供给外部客户端访问的URL，即外部客户端必须通过制定的IP加端口访问etcd
listen-client-urls: &quot;http://0.0.0.0:12379&quot;

# 集群配置
initial-advertise-peer-urls: &quot;http://192.168.235.128:12380&quot;
# 集群初始成员配置，是etcd静态部署的核心初始化配置，它说明了当前集群由哪些URLs组成，此处default为节点名称
initial-cluster: &quot;etcdnode0=http://192.168.235.128:2380,etcdnode1=http://192.168.235.128:12380,etcdnode2=http://192.168.235.128:22380&quot;
# 初始化集群状态（new 或 existing）
initial-cluster-state: &quot;new&quot;
# 引导期间etcd集群的初始集群令牌，防止不同集群之间产生交互
initial-cluster-token: &quot;etcd-cluster&quot;
# 向客户端发布的服务端节点
advertise-client-urls: &quot;http://192.168.235.128:12379&quot;
logger: &quot;zap&quot;
# 配置日志级别，仅支持 debuf、info、warn、error、panic、or fatal
log-level: &quot;warn&quot;
log-outputs:
  - &quot;stderr&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;etcd2.yaml&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;# 节点名称
name: &quot;etcdnode2&quot;
# 数据存储目录
data-dir: &quot;/etcd-data/data&quot;
# 预写式日志存储目录
wal-dir: &quot;/etcd-data/wal&quot;
# 集群成员之间通讯使用URL
listen-peer-urls: &quot;http://0.0.0.0:22380&quot;
# 集群提供给外部客户端访问的URL，即外部客户端必须通过制定的IP加端口访问etcd
listen-client-urls: &quot;http://0.0.0.0:22379&quot;

# 集群配置
initial-advertise-peer-urls: &quot;http://192.168.235.128:22380&quot;
# 集群初始成员配置，是etcd静态部署的核心初始化配置，它说明了当前集群由哪些URLs组成，此处default为节点名称
initial-cluster: &quot;etcdnode0=http://192.168.235.128:2380,etcdnode1=http://192.168.235.128:12380,etcdnode2=http://192.168.235.128:22380&quot;
# 初始化集群状态（new 或 existing）
initial-cluster-state: &quot;new&quot;
# 引导期间etcd集群的初始集群令牌，防止不同集群之间产生交互
initial-cluster-token: &quot;etcd-cluster&quot;
# 向客户端发布的服务端节点
advertise-client-urls: &quot;http://192.168.235.128:22379&quot;
logger: &quot;zap&quot;
# 配置日志级别，仅支持 debuf、info、warn、error、panic、or fatal
log-level: &quot;warn&quot;
log-outputs:
  - &quot;stderr&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;etcd3.yaml&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# 节点名称
name: &quot;etcdnode3&quot;
# 数据存储目录
data-dir: &quot;/etcd-data/data&quot;
# 预写式日志存储目录
wal-dir: &quot;/etcd-data/wal&quot;
# 集群成员之间通讯使用URL
listen-peer-urls: &quot;http://0.0.0.0:32380&quot;
# 集群提供给外部客户端访问的URL，即外部客户端必须通过制定的IP加端口访问etcd
listen-client-urls: &quot;http://0.0.0.0:32379&quot;

# 集群配置
initial-advertise-peer-urls: &quot;http://192.168.235.128:32380&quot;
# 集群初始成员配置，是etcd静态部署的核心初始化配置，它说明了当前集群由哪些URLs组成，此处default为节点名称
initial-cluster: &quot;etcdnode0=http://192.168.235.128:2380,etcdnode1=http://192.168.235.128:12380,etcdnode2=http://192.168.235.128:22380,etcdnode3=http://192.168.235.128:32380&quot;
# 初始化集群状态（new 或 existing）
initial-cluster-state: &quot;existing&quot;
# 引导期间etcd集群的初始集群令牌，防止不同集群之间产生交互
initial-cluster-token: &quot;etcd-cluster&quot;
# 向客户端发布的服务端节点
advertise-client-urls: &quot;http://192.168.235.128:32379&quot;
logger: &quot;zap&quot;
# 配置日志级别，仅支持 debuf、info、warn、error、panic、or fatal
log-level: &quot;warn&quot;
log-outputs:
  - &quot;stderr&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	由于第四个配置文件中，集群配置里有四个节点并且初始化集群状态会已存在，故我们在后面的以第四个配置文件启动 etcd 服务的时候，需要先在集群中创建该节点，告诉其他节点有新节点来了，才能在使用该配置文件启动服务时与其他节点成功建立通信。&lt;/p&gt;
&lt;h5&gt;启动 etcd 服务&lt;/h5&gt;
&lt;p&gt;​	写好配置文件之后，我们仿照官网示例来启动 etcd 服务了，我们这里是采用读取配置文件的方式进行启动服务的，与官方示例不同。&lt;/p&gt;
&lt;p&gt;​	使用下面的命令创建并允许一个容器，这个命令主要是将 docker 设置在后台允许容器，以及一些端口映射、命名、配置文件路径的配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;docker run -d -p 2379:2379 -p 2380:2380 -v /tmp/etcd0-data:/etcd-data -v /root/etcd/etcdconf:/etcd-conf --name etcd0 quay.io/coreos/etcd:v3.5.5 /usr/local/bin/etcd --config-file=/etcd-conf/etcd0.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	可以通过 docker ps 观察容器是否启动起来了，如果启动了，就说明没有说明问题；如果没有成功启动，可以使用 docker log etcd0 查看 etcd0 的日志输出，找到错误信息进行排查。&lt;/p&gt;
&lt;p&gt;​	接着可以再检查一下我们的目录映射有没有问题，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;ls /tmp/etcd0-data/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/etcd0-data.png&quot; alt=&quot;etcd0-data&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	再看看我们的日志，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;docker logs -f etcd0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	会发现一直在报 warn 错，因为我们配置在其他几个节点，但是其他集群几个节点还没有启动，所以就会一直报错。&lt;/p&gt;
&lt;p&gt;​	然后我们依次去把其他两个节点启动，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;docker run -d -p 12379:12379 -p 12380:12380 -v /tmp/etcd1-data:/etcd-data -v /root/etcd/etcdconf:/etcd-conf --name etcd1 quay.io/coreos/etcd:v3.5.5 /usr/local/bin/etcd --config-file=/etcd-conf/etcd1.yaml

docker run -d -p 22379:22379 -p 22380:22380 -v /tmp/etcd2-data:/etcd-data -v /root/etcd/etcdconf:/etcd-conf --name etcd2 quay.io/coreos/etcd:v3.5.5 /usr/local/bin/etcd --config-file=/etcd-conf/etcd2.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	启动完成后，使用 docker ps 查看容器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/%E9%9B%86%E7%BE%A43%E8%8A%82%E7%82%B9.png&quot; alt=&quot;集群3节点&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	然后再次查看我们的日志，就发现我们的日志报错停止了，就说明我们的 etcd 集群启动成功了。&lt;/p&gt;
&lt;h1&gt;三、etcd 集群运维基本操作&lt;/h1&gt;
&lt;p&gt;​	由于虚拟机本地没有下载 etcd，我们只能去访问容器内的 etcd 服务了，使用下面的命令进入 etcd 容器交互模式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker exec -it etcd0 bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	然后我们开始我们的功能讲解，以及一些参数讲解。&lt;/p&gt;
&lt;h4&gt;健康检查&lt;/h4&gt;
&lt;p&gt;​	健康检查功能是值系统能够自动检测节点的健康状态，以确保集群的正常运行。&lt;/p&gt;
&lt;h5&gt;集群节点心跳间隔&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;--heartbeat-interval&lt;/code&gt;&lt;/strong&gt;：这个参数用于设置 etcd 集群中节点之间发送心跳的时间间隔。默认值为 100 毫秒。你可以通过以下方式修改为 500 毫秒：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;etcd --heartbeat-interval=500
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;心跳间隔最长时间&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;--election-timeout&lt;/code&gt;：&lt;/strong&gt; 这个参数用于设置选举超时时间，即节点在多长时间内没有收到心跳信号后就可能发起一次选举。默认值为 1000 毫秒。你可以通过以下方式修改为 3000 毫秒：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;etcd --election-timeout=3000
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;获取集群各节点状态信息&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;etcdctl endpoint status&lt;/code&gt;：这个命令用于获取 etcd 集群中各节点的详细状态信息，包括节点的 ID、地址、健康状况等。&lt;/p&gt;
&lt;p&gt;常用的参数有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;--cluster&lt;/code&gt;：打印所有节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w table&lt;/code&gt;：表格格式展示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--endpoints&lt;/code&gt;：指定访问的节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/etcdtable.png&quot; alt=&quot;etcdtable&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;详细解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ID&lt;/code&gt;：节点的唯一标识符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Version&lt;/code&gt;：etcd 版本。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Endpoint&lt;/code&gt;：节点的监听地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Status&lt;/code&gt;：节点的健康状况，通常包括 &lt;code&gt;healthy&lt;/code&gt;、&lt;code&gt;unhealthy&lt;/code&gt; 或 &lt;code&gt;unknown&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Duration&lt;/code&gt;：节点的运行时间。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Peer URLs&lt;/code&gt;：节点的对等节点通信地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Client URLs&lt;/code&gt;：节点的客户端通信地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;检查 etcd 集群的健康状况&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;etcdctl endpoint health&lt;/code&gt;：该命令用于检查 etcd 集群的健康状况，判断是否所有节点都处于正常运行状态。&lt;/p&gt;
&lt;p&gt;常用参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;--cluster&lt;/code&gt;：打印所有节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w table&lt;/code&gt;：表格格式展示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--endpoints&lt;/code&gt;：指定访问的节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/etcdhealthtable.png&quot; alt=&quot;etcdhealthtable&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	详细解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cluster is healthy&lt;/code&gt;：表示集群中的所有节点都处于健康状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unhealthy&lt;/code&gt;：表示集群中存在不健康的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;告警管理：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;​	在 etcd 中，告警管理是一种机制，用于帮助管理员和操作人员监测和响应 etcd 集群中可能发生的问题。通过设置告警规则和配置，管理员可以在集群遇到异常或潜在问题时得到通知，以便及时采取必要的措施。&lt;/p&gt;
&lt;p&gt;​	常见的命令有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;alarm disarm&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;作用：解除etcd集群中的告警状态，允许集群继续正常运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alarm list&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;作用：列出etcd集群中的告警信息，提供了对当前集群告警状态的查看。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;数据规模检查&lt;/h4&gt;
&lt;p&gt;​	在 etcd 中，数据规模检查通常是指对 etcd 存储的数据规模（数据量的大小）进行监测和检查的机制。这涉及到集群中存储的键值对数量、数据大小等方面的指标。&lt;/p&gt;
&lt;p&gt;​	常见的命令有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;**&lt;code&gt;etcdctl check datascale&lt;/code&gt;：**检查 etcd 集群数据规模的工具，常用参数如下：
&lt;ul&gt;
&lt;li&gt;**&lt;code&gt;--auto-compact&lt;/code&gt;：**启用自动压缩功能。etcd 存储中的历史版本可能会占用磁盘空间，自动压缩可以清理不再需要的历史版本，释放磁盘空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;--auto-defrag&lt;/code&gt;：&lt;/strong&gt; 启用磁盘自动碎片整理功能。etcd 存储在删除键值对时可能会导致碎片，自动碎片整理有助于提高磁盘空间的利用率。&lt;/li&gt;
&lt;li&gt;**&lt;code&gt;--load&lt;/code&gt;：**指定不同规模的集群来进行性能测试。可以用于模拟不同负载下 etcd 集群的性能表现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;--endpoints&lt;/code&gt;&lt;/strong&gt;： 对指定节点进行数据规模检查。可以通过 &lt;code&gt;--endpoints&lt;/code&gt; 参数指定 etcd 集群的节点地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;**&lt;code&gt;etcdctl check perf&lt;/code&gt;：**执行 etcd 集群的性能检查，用于评估集群的性能表现。&lt;/li&gt;
&lt;li&gt;**&lt;code&gt;etcdctl del /etcdctl-check-datascale/ --prefix&lt;/code&gt;：**删除以指定前缀的所有键，通常用于清理测试数据。在进行数据规模检查之前，可以使用该命令清理之前的测试数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;快照操作&lt;/h4&gt;
&lt;p&gt;​	在 etcd 中，快照操作是指对 etcd 存储中的当前状态进行备份的操作。快照是一个在某个时间点捕获的 etcd 存储的状态副本，它包含了该时间点的所有键值对数据以及相应的元数据信息。&lt;/p&gt;
&lt;p&gt;​	常见命令有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;etcdctl snapshot save&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;保存etcd集群的快照，用于备份和恢复。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;etcdutl snapshot restore&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;恢复etcd集群的快照，用于在需要时还原数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;etcdutl snapshot status&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;查看etcd集群快照的状态信息，包括快照文件的大小、创建时间等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;集群管理&lt;/h4&gt;
&lt;p&gt;​	在 etcd 中，集群管理涉及到对 etcd 集群进行配置、监控、维护和优化等一系列操作。&lt;/p&gt;
&lt;p&gt;​	常见的命令有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;etcdctl move-leader&lt;/code&gt;：手动移动etcd集群的领导者节点，用于修改集群中的领导者。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;节点管理&lt;/h4&gt;
&lt;p&gt;​	在 etcd 中，节点管理是指对 etcd 集群中的节点进行监控、维护和操作的一系列管理任务。&lt;/p&gt;
&lt;p&gt;​	常见的命令有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;etcdctl member add&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;作用：向etcd集群中添加新的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;etcdctl member list&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;作用：列出etcd集群中的所有节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;etcdctl member promote&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;作用：提升etcd集群中普通节点的权限，使其具备领导者选举资格。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;etcdctl member remove&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;作用：从etcd集群中移除指定节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;etcdctl member update&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;作用：更新etcd集群中节点的信息，如名称、地址等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;四、etcd 数据操作之租约与事务&lt;/h1&gt;
&lt;h4&gt;数据操作&lt;/h4&gt;
&lt;p&gt;​	在 etcd 中，数据操作的确主要涉及 &lt;code&gt;put&lt;/code&gt;、&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;del&lt;/code&gt; 这三个基本操作，分别用于存储、检索和删除键值对。&lt;/p&gt;
&lt;p&gt;​	下面带大家一一熟悉：&lt;/p&gt;
&lt;h5&gt;put&lt;/h5&gt;
&lt;p&gt;​	&lt;code&gt;etcdtcl put&lt;/code&gt; 是用于将键值对存储到 etcd 中的命令。&lt;/p&gt;
&lt;p&gt;​	常见的参数及其功能如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;--ignore-lease：&lt;/strong&gt; 忽略租约。使用此参数可以在存储键值对时忽略租约的存在。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--ignore-value：&lt;/strong&gt; 忽略值。即使键已经存在，也强制写入新值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--lease=&quot;0&quot;：&lt;/strong&gt; 设置租约的持续时间，0 表示无租约。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--prev-kv：&lt;/strong&gt; 在更新操作时，检查前一个键值对的存在性，只有存在时才执行更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;get&lt;/h5&gt;
&lt;p&gt;​	&lt;code&gt;etcdctl get&lt;/code&gt; 用于从 etcd 中检索键值对。&lt;/p&gt;
&lt;p&gt;​	常见的参数及其功能如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-w json：&lt;/strong&gt; 指定输出格式为 JSON，并提供详细的键值对信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--prefix：&lt;/strong&gt; 指定前缀，以获取匹配指定前缀的所有键值对。相当于 SQL 中的 &lt;code&gt;LIKE &#39;key%&#39;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--consistency=&quot;l or s&quot;：&lt;/strong&gt; 设置一致性级别，&lt;code&gt;l&lt;/code&gt; 表示与 leader 节点比较数据的一致性较高，&lt;code&gt;s&lt;/code&gt; 表示仅在当前节点上检查键值对的存在性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--count-only：&lt;/strong&gt; 仅返回匹配条件的键值对数量而不返回具体的键值对。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--from-key：&lt;/strong&gt; 获取键大于或等于指定键的所有键值对。相当于 SQL 中的 &lt;code&gt;WHERE key &amp;amp;gt;= &#39;specified_key&#39;&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;del&lt;/h5&gt;
&lt;p&gt;​	&lt;code&gt;etcdctl del&lt;/code&gt; 用于从 etcd 中删除键值对。&lt;/p&gt;
&lt;h4&gt;租约&lt;/h4&gt;
&lt;p&gt;​	在etcd中，租约（Lease）是一种用于为键值对分配时间的机制，用于管理临时性的关联性数据。租约的主要目的是为了在一段时间内提供对键值对的持久性，而在租约到期后，键值对会自动从存储中删除。&lt;/p&gt;
&lt;p&gt;​	租约的主要特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;时间控制：&lt;/strong&gt; 每个租约都有一个预定的时间期限，称为TTL（Time-to-Live）。该TTL指定了租约的生命周期，通常以秒为单位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;续约：&lt;/strong&gt; 租约可以续约，即在TTL期限内，持有者可以通过向etcd发送心跳继续使用租约。如果续约失败或终止，租约将在TTL到期后失效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关联键值对：&lt;/strong&gt; 租约通常与键值对相关联。在创建键值对时，可以将租约ID与其关联，从而确定键值对的生命周期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动删除：&lt;/strong&gt; 当租约到期时，关联的键值对将自动从etcd中删除，释放资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	租约中常用参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;lease grant&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用于创建一个新的租约，并返回租约的 ID。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;etcdctl lease grant &amp;amp;lt;TTL&amp;amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;lease keep-alive&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;保持租约的活动状态，防止租约过期。该命令会持续发送心跳以保持租约的有效性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;etcdctl lease keep-alive &amp;amp;lt;lease-id&amp;amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;lease list&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;列出当前存在的所有租约。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;etcdctl lease list
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;lease revoke&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用于撤销（取消）指定的租约。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;etcdctl lease revoke &amp;amp;lt;lease-id&amp;amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;lease timetolive&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;获取指定租约的剩余生存时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;etcdctl lease timetolive &amp;amp;lt;lease-id&amp;amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	下面带大家一起使用一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;​	我们先使用 &lt;code&gt;etcdctl lease grant 60 &lt;/code&gt; 创建一个 60s 的租约，它会返回一个租约 ID，&lt;/li&gt;
&lt;li&gt;​	然后我们拿着这个租约 ID 去给我们的设置租约，&lt;code&gt;etcdctl put k v --lease=&amp;amp;lt;lease-id&amp;amp;gt;&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;​	然后使用 &lt;code&gt;etcdctl lease timetolive &amp;amp;lt;lease-id&amp;amp;gt;&lt;/code&gt; 查看还有多久过期，&lt;/li&gt;
&lt;li&gt;​	在未过期时，可以使用 &lt;code&gt;etcdctl get k&lt;/code&gt; 查看到键值对，在租约过期后，就无法查看到了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/iamges/%E7%A7%9F%E7%BA%A6%E7%A4%BA%E4%BE%8B.png&quot; alt=&quot;租约示例&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	大家可以自己实践一下，而且只要租约还未过期，我们就可以为租期设置为永不过期 &lt;code&gt;etcdctl lease keep-alive &amp;amp;lt;lease-id&amp;amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;事务&lt;/h4&gt;
&lt;p&gt;​	在etcd中，事务是一组对键值存储的原子操作，可以确保这些操作要么全部成功，要么全部失败。etcd的事务支持在单个事务中包含多个操作，这些操作可以是读取、写入、修改等，事务将这些操作组合在一起执行。&lt;/p&gt;
&lt;p&gt;​	etcd 中的事务本质上是&lt;strong&gt;由 if 语句 + then语句 + else 语句 组成&lt;/strong&gt;。if 语句检查通过，则执行 then 语句里面的内容，否则执行 else 语句里面的内容&lt;/p&gt;
&lt;p&gt;​	if 语句里面可以判断的条件包括但不限于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;mod_revision&lt;/strong&gt;：检查键的修改版本号是否满足条件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;create_revision&lt;/strong&gt;：检查键的创建版本号是否满足条件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;version&lt;/strong&gt;：检查键的版本号是否满足条件。&lt;/li&gt;
&lt;li&gt;**value：**检查键的值是否满足条件。&lt;/li&gt;
&lt;li&gt;**evalue：**检查键的值是否匹配指定的正则表达式。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;开启事务&lt;/h5&gt;
&lt;p&gt;​	下面我们带大家写一个简单的 etcd 事务。&lt;/p&gt;
&lt;p&gt;​	使用 &lt;code&gt;etcdctl txn -i&lt;/code&gt; 开启事务，具体的流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/%E4%BA%8B%E5%8A%A1%E7%A4%BA%E4%BE%8B.png&quot; alt=&quot;事务示例&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;​	今天我们对 etcd 的介绍就只讲这么多了，后面还会带大家手把手用 Go 语言去操作 etcd 的客户端。&lt;/p&gt;
</description><link>https://studygolang.com/topics/17026</link><guid isPermaLink="false">https://studygolang.com/topics/17026</guid><pubDate>Mon, 11 Dec 2023 07:39:23 GMT</pubDate><author>oYto</author><category>每日一学</category></item><item><title>手把手教你写单元测试</title><description>&lt;p&gt;&amp;gt; 欢迎大家到我的博客阅读 &amp;lt;a href=&quot;&lt;a href=&quot;https://www.yinkai.cc/post/87f7ec85f25b15c6a2c7d33609789bdc&quot;&gt;https://www.yinkai.cc/post/87f7ec85f25b15c6a2c7d33609789bdc&lt;/a&gt;&quot;&amp;gt;YinKai &#39;s Blog&amp;lt;/a&amp;gt; ，会有更好的阅读体验 !&lt;/p&gt;
&lt;p&gt;​	本篇文章会带大家来认识什么是单元测试，并带大家动手写测试代码。&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;h1&gt;什么是单元测试&lt;/h1&gt;
&lt;p&gt;​	在 Go 语言中，单元测试是一种测试方法，用于验证代码的某个独立单元是否按预期功能，它的目的是确保代码的每个组成部分都在独立测试的情况下运行正常。&lt;/p&gt;
&lt;p&gt;​	在我们对项目新增一个新功能时，最好就要养成写单元测试的好习惯，这样可以有助于提高我们代码的质量、可维护性和可靠性。&lt;/p&gt;
&lt;p&gt;​	在 Go 中，单元测试的约定是使用标准库中的 &lt;code&gt;testing&lt;/code&gt; 包。测试文件通常以 &lt;code&gt;_test.go&lt;/code&gt; 为后缀，然后我们使用 &lt;code&gt;go test ...&lt;/code&gt; 配合一些参数去进行测试，Go 测试工具会自动识别并运行这些文件中那点测试样例。&lt;/p&gt;
&lt;h4&gt;go test 的两种模式&lt;/h4&gt;
&lt;h5&gt;1. 本地模式：执行当前目录下的所有测试用例&lt;/h5&gt;
&lt;p&gt;​	go test&lt;/p&gt;
&lt;h5&gt;2. 列表模式：输入一个或多个目录，执行这些目录下的测试用例&lt;/h5&gt;
&lt;p&gt;​	go test xx/xx&lt;/p&gt;
&lt;h4&gt;常用的 flag 参数&lt;/h4&gt;
&lt;p&gt;​	可以使用 go help testflag 查看，由于具体的参数很多，这里就只介绍一些常用的参数。&lt;/p&gt;
&lt;p&gt;​	我们经常使用的单元测试有三种，分别是功能测试、模糊测试、性能测试。下面会对这三种测试进行介绍，并列举出对应测试经常配合使用的参数，以及一些通用参数：&lt;/p&gt;
&lt;h5&gt;功能测试：&lt;/h5&gt;
&lt;p&gt;​	 功能测试是一种验证代码是否按照规范和需求进行工作的测试，它关注于测试单个函数或方法的功能是否正确，以确保其符合预期的行为。&lt;/p&gt;
&lt;p&gt;​	常配合使用的参数有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-run regexp：运行功能测试测试用例，可以匹配多个，&lt;/li&gt;
&lt;li&gt;-run ^$：不执行功能测试&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;模糊测试：&lt;/h5&gt;
&lt;p&gt;​	模糊测试是一种随机生成输入数据并将其提供给函数或程序的测试方法，它可以帮助发现潜在的边界情况和异常输入，以检测代码的鲁棒性。&lt;/p&gt;
&lt;p&gt;​	常配合使用的参数有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-fuzz regexp：运行匹配的模糊测试用例，只能匹配一个，因为模糊测试不中止，就不会停止&lt;/li&gt;
&lt;li&gt;-fuzztime t：指定模糊测试时长，默认一直运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;性能测试&lt;/h5&gt;
&lt;p&gt;​	性能测试用于评估代码在不同负载和压力下的性能表现，这里的性能测试对于某个功能函数来说可能会不太准确，它更偏向于系统层面的测试，但在一些情况下，单元测试也可以包含性能方面的验证，这里在后面会提到。&lt;/p&gt;
&lt;p&gt;​	常配合使用的参数有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-bench regexp ：运行正则表达式中匹配的的性能测试样例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-benchtime t：指定性能测试时间 1s 1m 或者次数 100x&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-count n：指定我们的测试次数，相当于多次运行 go test&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如&lt;code&gt;-benchtime 100x -count=5&lt;/code&gt; 则会运行我们的测试用例 500 次&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-cover：覆盖率分析，可以打印出一个覆盖率的分析。比如我们写了 3 个方法，但我们的 test 里面只有一个方法，所以覆盖率就会是 33%。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-cpu 1,2,4：会执行多次 go test，其中 runtime.GOMAXPROCS 分别是 1，2，4 来进行不同的测试&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-benchtime 100x -count=5 -cpu=1,2,4&lt;/code&gt; 这里会执行 1500 次&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-parallel n：性能测试时，指定并行 cpu 数量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;通用参数&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;-short：标识是否缩短运行时间。用于在系统进行小改动后的测试，告知不需要将所有测试用例全部运行，缩短时间允运行即可&lt;/li&gt;
&lt;li&gt;-timeout：单次 go test 超时时间，默认是 10 min，设置为 0 表示禁用&lt;/li&gt;
&lt;li&gt;-v：打印所有输出&lt;/li&gt;
&lt;li&gt;-benchmem：打印内存分配统计信息&lt;/li&gt;
&lt;li&gt;-blockprofile block.out ：指定阻塞数据写入到指定的文件&lt;/li&gt;
&lt;li&gt;-coverprofile cover.out：指定覆盖率信息写入到指定文件&lt;/li&gt;
&lt;li&gt;-cpuprofile cpu.out：CPU 使用数据写入指定文件&lt;/li&gt;
&lt;li&gt;-memprofilerate n：配置内存分析的详细程度，将其设置为较小的值将提高内存分析的精度，但会增加分析的开销。&lt;/li&gt;
&lt;li&gt;-mutexprofile mutex.out：将互斥锁信息写入指定文件&lt;/li&gt;
&lt;li&gt;-outputdir directory：指定输出目录&lt;/li&gt;
&lt;li&gt;-trace trace.out：将执行跟踪信息写入到指定文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;pprof 分析&lt;/h5&gt;
&lt;p&gt;​	上面所示输出的文件通常是二进制格式，为了查看对应的数据，我们要使用相应的工具进行分析。这里我们可以使用 pprof 工具进行分析，具体的我后续会出一篇文章讲解，这里就只讲一些用什么命令去查看：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;block.out：&lt;/strong&gt; 阻塞数据，使用 &lt;code&gt;go tool pprof -text block.out&lt;/code&gt; 来查看：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cover.out：&lt;/strong&gt; 覆盖率信息，使用 &lt;code&gt;go tool cover -func=cover.out&lt;/code&gt; 来查看：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cpu.out：&lt;/strong&gt; CPU 使用数据，使用 &lt;code&gt;go tool pprof -text cpu.out&lt;/code&gt; 来查看：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mutex.out：&lt;/strong&gt; 互斥锁信息，同样使用 &lt;code&gt;go tool pprof -text mutex.out&lt;/code&gt;：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;trace.out：&lt;/strong&gt; 执行跟踪信息，使用 &lt;code&gt;go tool trace trace.out&lt;/code&gt; 来查看：&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;怎么写单元测试&lt;/h1&gt;
&lt;p&gt;​	首先，要写单元测试，那么肯定需要一个功能函数。这里我们借用一下之前文章内存缓存系统中使用到的一个功能函数 &lt;code&gt;ParseSize&lt;/code&gt; ，它的功能是将用户的输入内存大小，转换为字节数和对应的字符串表示形式，其中还会涉及到一些输入不合法的处理，详情可以看 &lt;a href=&quot;https://oyto.github.io/2023/11/10/Go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F/#SetMaxMemory&quot;&gt;Go 语言实现缓存系统&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;​	本文讲的是如何写单元测试，这里 ParseSize  的源码就直接给大家了，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package util

import (
	&quot;regexp&quot;
	&quot;strconv&quot;
	&quot;strings&quot;
	&quot;time&quot;
)

const (
	B = 1 &amp;amp;lt;&amp;amp;lt; (iota * 10)
	KB
	MB
	GB
	TB
	PB
)

const defaultNum = 100

func ParseSize(size string) (int64, string) {
	time.Sleep(time.Nanosecond * 500)

	re, _ := regexp.Compile(&quot;[0-9]+&quot;)
	unit := string(re.ReplaceAll([]byte(size), []byte(&quot;&quot;)))
	num, _ := strconv.ParseInt(strings.Replace(size, unit, &quot;&quot;, 1), 10, 64)
	unit = strings.ToUpper(unit)

	var byteNum int64 = 0
	switch unit {
	case &quot;B&quot;:
		byteNum = num
	case &quot;KB&quot;:
		byteNum = num * KB
	case &quot;MB&quot;:
		byteNum = num * MB
	case &quot;GB&quot;:
		byteNum = num * GB
	case &quot;TB&quot;:
		byteNum = num * TB
	case &quot;PB&quot;:
		byteNum = num * PB
	default:
		num = 0
	}

	if num == 0 {
		num = 100
		byteNum = num * MB
		unit = &quot;MB&quot;
	}

	sizeStr := strconv.FormatInt(num, 10) + unit
	return byteNum, sizeStr
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	在项目根目录下创建 util 目录，然后创建 util.go 文件，将上面的代码粘贴进去就行了。&lt;/p&gt;
&lt;p&gt;​	强调一点，上面的 ParseSize 函数的开头，我加了一个睡眠函数，是因为我们的 ParseSize 函数的处理逻辑比较简单，怕执行太快，进行测试时显示时间为 0 ，所以加了个睡眠延迟一点时间，模拟一些比较耗时功能函数。&lt;/p&gt;
&lt;h4&gt;准备工作&lt;/h4&gt;
&lt;p&gt;​	同样，我们先在 util 包下创建 util_test.go 文件。在写单元测试的时候，我们通常有两种方法，一种是在测试函数里面构建匿名结构体来组织数据，另一种就是在提前构建数据。前者就是将构建数据的逻辑写在测试函数里，这里不多做介绍，我们要着重讲的是第二种。&lt;/p&gt;
&lt;p&gt;​	为了方便，我们先定义一个结构体，并将其实例化，用于存放我们的数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 所有的测试用例放在这里头
var commTestData []commStruct

type commStruct struct {
	Group         string // 所属类别
	SizeStr       string // 输入大小
	ExpectSize    int64  // 预期输出大小
	ExpectSizeStr string // 预期输出大小字符串类型
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Group：这个是用于子测试时分类的依据，关于子测试后面会提到，这里先不理会。&lt;/li&gt;
&lt;li&gt;SizeStr：是对应于我们的 ParseSize 功能函数的输入&lt;/li&gt;
&lt;li&gt;ExpectSize、ExpectSizeStr：对应于我们的 ParseSize 功能函数的输出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	在单元测试中，也有一个 &lt;code&gt;func TestMain(m *testing.M)&lt;/code&gt;入口函数，功能和用法于平时我们使用的 main 类似。我们可以在这里面为单元测试做一些准备工作，但需要注意的是：如果我们没有写 TestMain 函数，那么测试工具会直接调用我们的测试函数，但如果我们写了 TestMain 函数，就需要在 TestMain 中通过 m.Run() 显示地调用测试用例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 测试用例的入口函数：可以为测试做一些准备工作
func TestMain(m *testing.M) {
	initCommonData()
	m.Run() // 执行测试用例
}

func initCommonData() {
	commTestData = []commStruct{
		{&quot;B&quot;, &quot;1b&quot;, B, &quot;1B&quot;},
		{&quot;B&quot;, &quot;100b&quot;, 100 * B, &quot;100B&quot;},
		{&quot;KB&quot;, &quot;1kb&quot;, KB, &quot;1KB&quot;},
		{&quot;KB&quot;, &quot;100KB&quot;, 100 * KB, &quot;100KB&quot;},
		{&quot;MB&quot;, &quot;1Mb&quot;, MB, &quot;1MB&quot;},
		{&quot;GB&quot;, &quot;10Gb&quot;, 10 * GB, &quot;10GB&quot;},
		{&quot;TB&quot;, &quot;1tb&quot;, TB, &quot;1TB&quot;},
		{&quot;PB&quot;, &quot;10PB&quot;, 10 * PB, &quot;10PB&quot;},
		{&quot;unknown&quot;, &quot;1G&quot;, 100 * MB, &quot;100MB&quot;},
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	上面我们通过 TestMain 函数，提前构建好了测试所需要的数据，避免在不同的测试函数中重复构建测试用例。&lt;/p&gt;
&lt;h4&gt;功能测试&lt;/h4&gt;
&lt;p&gt;​	功能测试是一种验证代码是否按照规范和需求进行工作的测试，它关注于测试单个函数或方法的功能是否正确，以确保其符合预期的行为。&lt;/p&gt;
&lt;p&gt;​	根据它的定义，我们就大概知道该怎么写我们的功能测试了。首先功能测试的函数签名是这样的 &lt;code&gt;func TestFunctionName(t *testing.T)&lt;/code&gt;。我们直接在函数里面写逻辑即可，因为有很多组测试样例，所以我们肯定要用 for 循环将所有的样例拿出来，然后一一进行验证，验证的过程就是将该样例的输入拿出来执行一遍功能函数，然后将结果与我们的样例预期结果进行比对即可，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 功能测试
func TestParseSize(t *testing.T) {
	testData := commTestData
	for _, data := range testData {
		size, sizeStr := ParseSize(data.SizeStr)
		if size != data.ExpectSize || sizeStr != data.ExpectSizeStr {
			t.Errorf(&quot;测试结果不符合预期：%+v&quot;, data)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这样我们就写好了一个具备基本功能的功能测试代码了。我们可以通过命令 &lt;code&gt;go test -v&lt;/code&gt; 去执行，输出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;$  go test -v
=== RUN   TestParseSize
--- PASS: TestParseSize (0.14s)
PASS
ok      main/util       0.178s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	我们一起来看看这个输出：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;=== RUN TestParseSize&lt;/code&gt;：表示正在运行名为 &lt;code&gt;TestParseSize&lt;/code&gt; 的测试函数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--- PASS: TestParseSize (0.14s)&lt;/code&gt;：表示测试函数 &lt;code&gt;TestParseSize&lt;/code&gt; 成功通过，用时 0.14 秒。&lt;code&gt;PASS&lt;/code&gt; 表示测试通过，&lt;code&gt;FAIL&lt;/code&gt; 则表示测试失败。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PASS&lt;/code&gt;：表示整个测试过程中没有发现错误，所有的测试函数都成功通过。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ok main/util 0.178s&lt;/code&gt;：表示测试包 &lt;code&gt;main/util&lt;/code&gt; 成功通过，总用时为 0.178 秒。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	下面我们再来看看功能测试的子测试。&lt;/p&gt;
&lt;p&gt;​	功能测试的子测试，又可以叫做并发测试，我们可以利用它来加快测试的效率。我们下面以测试样例中的单位，即 group 字段来将测试样例分个组：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;testData := make(map[string][]commStruct)
for _, item := range commTestData {
    group := item.Group
    _, ok := testData[group]
    if !ok {
        testData[group] = make([]commStruct, 0)
    }
    testData[group] = append(testData[group], item)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	有了数据，其实我们的子测试，就相当于对不同组别分别去进行测试。&lt;/p&gt;
&lt;p&gt;​	所以首先要用一个 for 循环拿出不同组别的数据，去分别运行，然后在每个组别运行时，去拿出对应组别的数据去做验证即可，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func TestParseSizeSub(t *testing.T) {
	if testing.Short() {
		t.Skip(&quot;跳过测试用例 TestParseSizeSub&quot;)
	}

	// 按照 group 分个组
	testData := make(map[string][]commStruct)
	for _, item := range commTestData {
		group := item.Group
		_, ok := testData[group]
		if !ok {
			testData[group] = make([]commStruct, 0)
		}
		testData[group] = append(testData[group], item)
	}

	// 分组去测试 测试数据
	for k, _ := range testData {
		t.Run(k, func(t *testing.T) {
			// 下面的子测试样例就会去并行执行：通过睡眠可以看出效果
			t.Parallel()
			for _, data := range testData[k] {
				size, sizeStr := ParseSize(data.SizeStr)
				if size != data.ExpectSize || sizeStr != data.ExpectSizeStr {
					t.Errorf(&quot;测试结果不符合预期：%+v&quot;, data)
				}
			}
		})
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	细心的小伙伴一定看到了上面有两个点是我们没讲的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;if testing.Short()&lt;/code&gt; 这个是做什么的呢？还记得我们上面介绍参数的时候说过吗，这个参数是用来避免一些不必要的测试的，所以如果我们的测试不需要，就可以使用 short 参数跳过这个子测试。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;t.Parallel()&lt;/code&gt; 这个就是我们子测试并行测试的关键了，只有加了这行代码，我们的子测试才能进行并行测试。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	下面带大家看看&lt;code&gt;t.Parallel()&lt;/code&gt; 是不是真的有效果，我们在子测试代码中加入一个睡眠时间，先把 &lt;code&gt;t.Parallel()&lt;/code&gt; 注释掉：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;for k, _ := range testData {
    t.Run(k, func(t *testing.T) {
        //t.Parallel()
        for _, data := range testData[k] {
            time.Sleep(time.Second)
            size, sizeStr := ParseSize(data.SizeStr)
            if size != data.ExpectSize || sizeStr != data.ExpectSizeStr {
                t.Errorf(&quot;测试结果不符合预期：%+v&quot;, data)
            }
        }
    })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	然后执行命令 &lt;code&gt;go test -v&lt;/code&gt;，可以观察到子测试的样例每隔一秒才执行一次，最终耗时 9.367 秒。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;$  go test -v
=== RUN   TestParseSize
--- PASS: TestParseSize (0.10s)
=== RUN   TestParseSizeSub
=== RUN   TestParseSizeSub/KB
=== RUN   TestParseSizeSub/MB
=== RUN   TestParseSizeSub/GB
=== RUN   TestParseSizeSub/TB
=== RUN   TestParseSizeSub/PB
=== RUN   TestParseSizeSub/unknown
=== RUN   TestParseSizeSub/B
--- PASS: TestParseSizeSub (9.22s)            
    --- PASS: TestParseSizeSub/KB (2.05s)     
    --- PASS: TestParseSizeSub/MB (1.02s)     
    --- PASS: TestParseSizeSub/GB (1.02s)     
    --- PASS: TestParseSizeSub/TB (1.03s)     
    --- PASS: TestParseSizeSub/PB (1.03s)     
    --- PASS: TestParseSizeSub/unknown (1.03s)
    --- PASS: TestParseSizeSub/B (2.04s)      
PASS
ok      main/util       9.367s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	我们再把 &lt;code&gt;t.Parallel()&lt;/code&gt; 的注释去掉，再执行 &lt;code&gt;go test -v&lt;/code&gt; 观察一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;$  go test -v
=== RUN   TestParseSize
--- PASS: TestParseSize (0.14s)
=== RUN   TestParseSizeSub
=== RUN   TestParseSizeSub/unknown
=== PAUSE TestParseSizeSub/unknown
=== RUN   TestParseSizeSub/B
=== PAUSE TestParseSizeSub/B
=== RUN   TestParseSizeSub/KB
=== PAUSE TestParseSizeSub/KB
=== RUN   TestParseSizeSub/MB
=== PAUSE TestParseSizeSub/MB
=== RUN   TestParseSizeSub/GB
=== PAUSE TestParseSizeSub/GB
=== RUN   TestParseSizeSub/TB
=== PAUSE TestParseSizeSub/TB
=== RUN   TestParseSizeSub/PB
=== PAUSE TestParseSizeSub/PB
=== CONT  TestParseSizeSub/unknown
=== CONT  TestParseSizeSub/GB
=== CONT  TestParseSizeSub/PB
=== CONT  TestParseSizeSub/TB
=== CONT  TestParseSizeSub/KB
=== CONT  TestParseSizeSub/MB
=== CONT  TestParseSizeSub/B
--- PASS: TestParseSizeSub (0.00s)
    --- PASS: TestParseSizeSub/TB (1.03s)
    --- PASS: TestParseSizeSub/B (1.03s)
    --- PASS: TestParseSizeSub/MB (1.03s)
    --- PASS: TestParseSizeSub/PB (1.03s)
    --- PASS: TestParseSizeSub/KB (1.03s)
    --- PASS: TestParseSizeSub/unknown (1.03s)
    --- PASS: TestParseSizeSub/GB (1.03s)
PASS
ok      main/util       1.210s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	会发现子测试几乎是同时打印出来的信息，最终耗时 1.120s，这就验证了 &lt;code&gt;t.Parallel()&lt;/code&gt; 的作用，也同时验证了功能测试的子测试的作用。&lt;/p&gt;
&lt;h4&gt;模糊测试&lt;/h4&gt;
&lt;p&gt;​	模糊测试是一种随机生成输入数据并将其提供给函数或程序的测试方法，它可以帮助发现潜在的边界情况和异常输入，以检测代码的鲁棒性。&lt;/p&gt;
&lt;p&gt;​	也就是说，模式测试本质上也是功能测试，只不过模糊测试的输入不再是我们提前构建好的数据，而是测试工具根据我们传入的参数类型去帮我们构建各种输入，以此来检测我们的功能函数在这种随机构造的输入情况下，是否还能照常工作。模糊测试的函数签名是&lt;code&gt;func FuzzFunctionName(f *testing.F) {}&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func FuzzParseSize(f *testing.F) {
	// 也就是说，模糊测试，本质上也是一个功能测试。
	// 只是输入的内容不再是 data，而是所谓的 a
	f.Fuzz(func(t *testing.T, a string) {
		size, sizeStr := ParseSize(a)
		if size == 0 || sizeStr == &quot;&quot; {
			t.Errorf(&quot;输入异常，导致 parsesize 没拿到正确结果&quot;)
		}
	})
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	然后我们可以通过 &lt;code&gt;go test -fuzz FuzzParseSize&lt;/code&gt; 命令开启模糊测试，输出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go test -fuzz FuzzParseSize
warning: starting with empty corpus
fuzz: elapsed: 0s, execs: 0 (0/sec), new interesting: 0 (total: 0)
fuzz: elapsed: 3s, execs: 614 (205/sec), new interesting: 7 (total: 7)
fuzz: elapsed: 6s, execs: 4210 (1194/sec), new interesting: 22 (total: 22)
fuzz: elapsed: 9s, execs: 5579 (456/sec), new interesting: 26 (total: 26)
fuzz: elapsed: 12s, execs: 9227 (1221/sec), new interesting: 35 (total: 35)
fuzz: elapsed: 15s, execs: 14480 (1744/sec), new interesting: 44 (total: 44)
fuzz: elapsed: 18s, execs: 16198 (572/sec), new interesting: 49 (total: 49)
......
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;warning: starting with empty corpus&lt;/code&gt;：这是一个警告，表示开始时模糊测试的语料库（corpus）是空的。语料库是用来保存历史模式测试时，出现错误的样例。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;elapsed&lt;/code&gt;：经过的时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;execs&lt;/code&gt;：执行的测试次数（平均每秒执行多少次）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new interesting&lt;/code&gt;：新增的随机测试输入个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;total&lt;/code&gt;：本次测试的的输入样例个数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	运行模糊测试，你会发现根本不会停，只能主动去停止，这也是为什么模糊测试只能同时测试的原因。&lt;/p&gt;
&lt;p&gt;​	还有就是上面提到的预料库，在运行模糊测试时，如果出现了预期之外的错误，那就会将这个样例保存到语料库中，并且在之后每次的模糊测试都会去运行这些出错的样例。语料库也是保存在本地的，会在根目录下生成一个对应的文件去存放。&lt;/p&gt;
&lt;h4&gt;性能测试&lt;/h4&gt;
&lt;p&gt;​	最后我们再来看看性能测试，在进行性能测试之前，我们需要先将 ParseSize 函数中的睡眠函数关掉，避免影响我们的性能测试。因为&lt;code&gt;Sleep()&lt;/code&gt; 不仅会让程序睡眠，还会做一些其他处理，会对我们的性能测试产生不小的影响。&lt;/p&gt;
&lt;p&gt;​	待会我们也可以做一个测试，然后进行一个对比。&lt;/p&gt;
&lt;p&gt;​	性能测试写起来条条框框会比较多，它的函数签名是这样的 &lt;code&gt;func BenchmarkFunctionName(b *testing.B) {}&lt;/code&gt;我们啥也先不管，先来个 for 循环，然后直接调用我们的 ParseSize 函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func BenchmarkParseSize(b *testing.B) {
	for i := 0; i &amp;amp;lt; b.N; i++ {
		ParseSize(&quot;1MB&quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这样，一个简易的性能测试就写完了，我们可以用 &lt;code&gt; go test -bench BenchmarkParseSize&lt;/code&gt;，这里先不注释 ParseSize 中的睡眠函数，我们看看效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;go test -bench BenchmarkParseSize
goos: windows
goarch: amd64
pkg: main/util
cpu: AMD Ryzen 7 4800H with Radeon Graphics
BenchmarkParseSize-16                100          15301008 ns/op
BenchmarkParseSizeSub/B-16           100          14830110 ns/op
BenchmarkParseSizeSub/KB-16          100          15324944 ns/op
BenchmarkParseSizeSub/MB-16          100          15445510 ns/op
BenchmarkParseSizeSub/GB-16          100          14851633 ns/op
BenchmarkParseSizeSub/TB-16          100          15136910 ns/op
BenchmarkParseSizeSub/PB-16          100          15281375 ns/op
BenchmarkParseSizeSub/unknown-16                     100          15188822 ns/op
PASS
ok      main/util       22.495s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	再将睡眠函数注释掉，运行同样的命令，看看效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;go test -bench BenchmarkParseSize                                    
goos: windows
goarch: amd64                                       
pkg: main/util                                      
cpu: AMD Ryzen 7 4800H with Radeon Graphics         
BenchmarkParseSize-16             735984              1603 ns/op
BenchmarkParseSizeSub/B-16        704841              1616 ns/op
BenchmarkParseSizeSub/KB-16       750050              1630 ns/op
BenchmarkParseSizeSub/MB-16       748998              1647 ns/op
BenchmarkParseSizeSub/GB-16       635871              1689 ns/op
BenchmarkParseSizeSub/TB-16       769012              1639 ns/op
BenchmarkParseSizeSub/PB-16       748689              1642 ns/op
BenchmarkParseSizeSub/unknown-16                  770593              1620 ns/op
PASS
ok      main/util       19.901s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	我们先来解释一下各个参数代表什么：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;goos: windows&lt;/code&gt; 和 &lt;code&gt;goarch: amd64&lt;/code&gt;：表示你的操作系统和体系结构。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pkg: main/util&lt;/code&gt;：表示正在测试的 Go 包的路径。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cpu: AMD Ryzen 7 4800H with Radeon Graphics&lt;/code&gt;：表示你的 CPU 信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BenchmarkParseSize-16 735984 1603 ns/op&lt;/code&gt;：表示运行了 735984 次，平均每次耗时 1603 纳秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PASS&lt;/code&gt;：表示所有的性能测试都通过&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ok main/util 19.901s&lt;/code&gt;：表示整个测试过程消耗了 19.901 秒。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	可以很明显的看到，这里两次测试的平均每次迭代耗时差了很多个数量级，但算上我们的睡眠时间 &lt;code&gt;time.Sleep(time.Nanosecond * 500)&lt;/code&gt;，也就 500 ns 而已。之所以会这样是因为 &lt;code&gt;time.Sleep&lt;/code&gt; 函数的调用对于测试的结果会产生较大的影响，特别是在精度较高的情况，比如我们这里的纳米级别。 &lt;code&gt;time.Sleep&lt;/code&gt; 会导致当前 goroutine 挂起，等待指定的时间再继续执行。在测试中，这样的挂起会导致每次迭代的耗时相对较大，从而影响性能测试的结果。&lt;/p&gt;
&lt;p&gt;​	可能会有人好奇，为什么平均时长差了很多，但是总耗时却差不多。因为在 Go 语言的性能测试中，每个子测试的迭代次数数由测试框架自动决定的，它会根据自己执行时间的变化动态调整迭代次数，以保证测试结果的稳定性和可靠性。我们也可以自己使用 &lt;code&gt;-benchtime t&lt;/code&gt; 参数来配置自己想要的运行次数和时间。&lt;/p&gt;
&lt;p&gt;​	下面我们再来看看说说性能测试的子测试。&lt;/p&gt;
&lt;p&gt;​	性能测试的子测试，其实没有啥明确的使用场景，我们下面所举的例子，也只是为了写性能测试子测试而写子测试，能够使用的场景也就是需要分组归类去测试的数据，比如 B、KB、MB 等相同单位的一组去测试。&lt;/p&gt;
&lt;p&gt;​	这样做的好处是啥？有人肯定会觉得，可以像功能测试那样做并行测试。&lt;/p&gt;
&lt;p&gt;​	答案是否定的，性能测试的子测试没有并行机制。我个人觉得这样的好处就是，可以指定只执行对应分组的测试用例，比如我们只需要对某一个单位的大小进行特殊处理，就可以只去执行对应分组的测试用例了。&lt;/p&gt;
&lt;p&gt;​	然后我们来看看怎么写，同样的，需要先对我们的测试样例进行分组，然后在用 for 对不同组别的测试样例分别去运行性能测试函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func BenchmarkParseSizeSub(b *testing.B) {
	testData := make(map[string][]commStruct)
	for _, item := range commTestData {
		group := item.Group
		_, ok := testData[group]
		if !ok {
			testData[group] = make([]commStruct, 0)
		}
		testData[group] = append(testData[group], item)
	}

	for k, _ := range testData {
		b.Run(k, func(b *testing.B) {
			for i := 0; i &amp;amp;lt; b.N; i++ {
				ParseSize(testData[k][0].SizeStr)
			}
		})
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	上面代码需要知道的一点，就是在每次运行 &lt;code&gt;b.Run()&lt;/code&gt; 的时候，for 循环里的测试次数是测试工具自动决定的，我们只需要调用就可以了。&lt;/p&gt;
&lt;p&gt;​	上面就差不多是性能测试的基本写法了，只不过在一些情况下，比如我们在每次测试时需要去进行一下其他的数据准备，如果不进行一些处理，这些准备数据的时间就可能会导致我们的性能测试偏差较大：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;for k, _ := range testData {
    b.Run(k, func(b *testing.B) {
        // case1
        preBenchmark()
        for i := 0; i &amp;amp;lt; b.N; i++ {
            // case2
            preBenchmark1()
            ParseSize(testData[k][0].SizeStr)
        }
    })
}

func preBenchmark1() {
	time.Sleep(10 * time.Second)
}

func preBenchmark2() {
	time.Sleep(time.Nanosecond * 500)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	在上述代码中，我们通过 &lt;code&gt;preBenchmark1&lt;/code&gt; 和 &lt;code&gt;preBenchmark2&lt;/code&gt; 函数模拟了准备数据等其他操作的耗时，这里就直接告诉大家解决的方法了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 &lt;code&gt;case1&lt;/code&gt;：可以在数据准备完成后，使用&lt;code&gt;b.ResetTimer()&lt;/code&gt; 重置计时器&lt;/li&gt;
&lt;li&gt;对于&lt;code&gt;case2&lt;/code&gt;：可以在准备数据前使用 &lt;code&gt;b.StopTimer()&lt;/code&gt; 将计时器暂停，然后在准备好数据后，重新启动计时器 &lt;code&gt;b.StartTimer()&lt;/code&gt;，这样就可以减小误差。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;for k, _ := range testData {
    b.Run(k, func(b *testing.B) {
        // for 循环外，可以通过 b.ResetTimer() 来重置
        preBenchmark1()
        b.ResetTimer()
        for i := 0; i &amp;amp;lt; b.N; i++ {
            // for 循环内，可以通过 b.StopTimer() 和 b.StartTimer() 配合使用，来跳过我们不想统计的耗时操作。迫不得已不要使用，测试速度慢
            b.StopTimer()
            preBenchmark2()
            b.StartTimer()
            ParseSize(testData[k][0].SizeStr)
        }
    })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这里强调一点，上面的解决办法也只能减缓误差，并不能真正避免误差。并且如果你要测试上述代码的话，记得加上&lt;code&gt;-benchtime&lt;/code&gt; 限制一下执行次数，否则会等很久。&lt;/p&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;​	这篇文章介绍了单元测试，并从一个功能函数出发，给大家演示了该怎么写功能测试、模糊测试、性能测试，以及对应的一些注意事项，也希望大家平时就能养成写单元测试的习惯。&lt;/p&gt;
</description><link>https://studygolang.com/topics/17021</link><guid isPermaLink="false">https://studygolang.com/topics/17021</guid><pubDate>Sun, 10 Dec 2023 07:34:45 GMT</pubDate><author>oYto</author><category>每日一学</category></item><item><title>[go 面试] 一致性哈希：数据分片与负载均衡的黄金法则</title><description>&lt;p&gt;&amp;gt; 关注公众号【爱发白日梦的后端】分享技术干货、读书笔记、开源项目、实战经验、高效开发工具等，您的关注将是我的更新动力！&lt;/p&gt;
&lt;p&gt;在分布式系统中，一致性哈希（Consistent Hashing）是一项关键算法，为解决数据分片和负载均衡难题提供了强大的支持。本文将深入研究一致性哈希的核心原理，解析其如何超越传统哈希算法，同时详细探讨一个关键问题：当节点发生问题时，数据是如何被处理的。&lt;/p&gt;
&lt;h1&gt;一、探秘基本原理&lt;/h1&gt;
&lt;p&gt;一致性哈希巧妙地将节点和数据映射到一个环状的哈希空间上。节点的哈希值确定了其在环上的位置，而数据的哈希值则找到了对应的环上位置。为了提高均衡性，一致性哈希引入了虚拟节点的概念，进一步优化了节点与数据的分布。&lt;/p&gt;
&lt;h1&gt;二、巧妙应对节点问题&lt;/h1&gt;
&lt;p&gt;Q：节点问题如何巧妙处理？&lt;/p&gt;
&lt;p&gt;节点离开： 当节点不可用或被标记为离开状态时，系统探测到并作出相应处理。
数据重新分配： 一致性哈希算法重新计算数据的哈希值，找到新的节点存储这些数据。
数据迁移： 需要迁移的数据从离开的节点中取出，按新的哈希值找到新的节点存储。此过程可能耗时，取决于数据大小和分布。
新节点加入： 添加新节点时，算法根据新节点的哈希值在环上找到位置，并从相邻节点迁移一部分数据，保持负载均衡。&lt;/p&gt;
&lt;h1&gt;三、优势与应用场景&lt;/h1&gt;
&lt;p&gt;一致性哈希通过虚拟节点和环状结构，解决了传统哈希算法在动态环境下的数据迁移问题，提供了卓越的负载均衡性能。其在分布式系统中的数据分片和负载均衡方面有着广泛的应用。&lt;/p&gt;
&lt;p&gt;通过以上步骤，一致性哈希算法能够在节点故障时重新分配数据，确保数据的存储和访问不受影响。相比于传统哈希算法，一致性哈希在节点变动时的数据迁移开销较小，使系统更有效地应对节点故障和扩展。&lt;/p&gt;
</description><link>https://studygolang.com/topics/17019</link><guid isPermaLink="false">https://studygolang.com/topics/17019</guid><pubDate>Sun, 10 Dec 2023 05:34:45 GMT</pubDate><author>TimLiuDream</author><category>每日一学</category></item><item><title>手把手教你使用pprof进行性能优化</title><description>&lt;p&gt;&amp;gt; 欢迎大家到我的博客浏览，&amp;lt;a href=&quot;&lt;a href=&quot;https://www.yinkai.cc/post/56154c4bf826fbfcd53d66ac5541f6a1&quot;&gt;https://www.yinkai.cc/post/56154c4bf826fbfcd53d66ac5541f6a1&lt;/a&gt;&quot;&amp;gt;YinKai &#39;s Blog&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;​	大家好，今天我们来一起学习一下 pprof 这个工具。&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;h4&gt;pprof 是什么&lt;/h4&gt;
&lt;p&gt;​	肯定会有人问，pprof 是做什么用的？&lt;/p&gt;
&lt;p&gt;​	pprof 是 Go 语言自带的性能分析工具，用于识别和解决应用程序中的性能瓶颈问题。大家应该或多或少有听说过 “三高代码”，这里的 “三高” 并不是指 “高血压、高血糖、高血脂”，而是指 &lt;strong&gt;”高性能、高并发、高可用“&lt;/strong&gt;，而 pprof 就可以帮助我们写出这样的 “ 三高代码 ”。&lt;/p&gt;
&lt;p&gt;​	在正式介绍 pprof 之前，我们先来解释一下三高的含义，以及需要注意的点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;高性能&lt;/strong&gt;：由于我们电脑组件的执行速度 CPU &amp;gt; 内存 &amp;gt; 磁盘，想要写出高性能的代码，就要优先让 CPU 去处理核心逻辑。像 io 操作这类耗时且不太核心的逻辑，比如 日志打印、日志保存，就不需要去关注它的执行速度 。我们可以将 io 操作，放在消息队列里面去缓慢执行，我们不关心它什么时候完成，只需要最后能够完成就行了。这样，我们就可以让 CPU 更多的时间去处理业务的核心逻辑。再者就是采用合适的算法和数据结构进行优化，这里需要具体情况具体分析，就不做多的解释了。总结一下就是，&lt;strong&gt;避免 io 操作，采用合适的算法和数据结构。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;**高并发：**Go 语言本身就更利于高并发的实现，可以充分利用 CPU 资源，但我们也需要注意避免阻塞，因为这会导致 CPU 的调度工作增加，程序上的体现就是程序执行缓慢。同样的，由于 io 并不支持并发，如果你的代码中涉及到了 io 操作，即使是并发执行的，也会退化成同步执行。总结一下就是，&lt;strong&gt;避免阻塞、避免 io 操作，io 不支持并发。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高可用：&lt;/strong&gt; 比如 session sookie 机制，就不支持多机部署，我们的代码最好是无状态的，这样从才能支持高可用。&lt;strong&gt;总结一下就是，避免状态，使应用程序变成无状态程序。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;如何使用 pprof&lt;/h4&gt;
&lt;p&gt;​	pprof 本质上就是一个工具，我们在写完代码之后，可以借助 pprof 对我们的程序进行性能指标的采集，采集的方式也有好几种，下面我们会介绍三种，分别是 web 网页采集、基准测试采集、硬编码采集。采集到对应的信息后，再借助 pprof 提供的工具 &lt;code&gt;go tool pprof&lt;/code&gt; 进行性能分析，进而确定造成性能瓶颈的地方，对代码进行优化。&lt;/p&gt;
&lt;h5&gt;性能指标&lt;/h5&gt;
&lt;p&gt;​	下面我们先来介绍一下 pprof 一些常见的性能指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;allocs：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;功能：查看过去所有的内存分配信息&lt;/li&gt;
&lt;li&gt;用途：用于分析程序的内存分配情况，找到可能导致内存泄漏或者不必要的大内存分配代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;block：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;功能：查看导致同步原语阻塞的堆栈跟踪信息&lt;/li&gt;
&lt;li&gt;用途：用于识别程序中的同步阻塞点，找到潜在的并发瓶颈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cmdline：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;功能：查看当前应用程序的命令行完整的调用路径&lt;/li&gt;
&lt;li&gt;用途：用于了解应用程序的启动参数和调用路径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;goroutine：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;功能：查看当前所有的协程堆栈跟踪信息&lt;/li&gt;
&lt;li&gt;用途：用于了解当前程序中所有运行的协程，以及它们的堆栈信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;heap：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;功能：查看活动对象的内存分配情况&lt;/li&gt;
&lt;li&gt;用途：用于分析程序的堆内存分配情况，找到可能导致内存泄漏或者不必要的大内存分配的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mutex：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;功能：查看互斥锁的竞争持有者的堆栈跟踪信息&lt;/li&gt;
&lt;li&gt;用途：用于识别程序中互斥锁的竞争情况，找到可能的并发瓶颈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;profile：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;功能：CPU 的使用报告&lt;/li&gt;
&lt;li&gt;用途：用于分析程序的 CPU 使用情况，找到可能导致性能瓶颈的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;threadcreate&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;功能：查看新线程的堆栈跟踪信息&lt;/li&gt;
&lt;li&gt;用途：用于了解程序中新线程的创建情况，以及它们的堆栈信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;trace：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;功能：整个应用程序的调用的堆栈信息&lt;/li&gt;
&lt;li&gt;用于了解整个应用程序的调用路径和函数调用关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	知道了各项性能指标的功能以及用途，接下来我们来看看如何采集对应这些性能指标吧~&lt;/p&gt;
&lt;h4&gt;三种性能指标采集方式&lt;/h4&gt;
&lt;p&gt;​	这里介绍的三种不同的采集方式，是指生成对应的信息的方式不同，但最终都是需要通过 pprof 工具对采集到的信息文件进行分析的。&lt;/p&gt;
&lt;h5&gt;准备工作&lt;/h5&gt;
&lt;p&gt;​	在采集信息之前，我们先写一些有问题的代码，以模拟我们平时的问题代码。&lt;/p&gt;
&lt;p&gt;在根目录中，创建 data 目录，然后在 data 目录下创建一个 data.go 文件，在里面定义一个接口，以供我们写一些其他代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package data

type Cmd interface {
	Name() string
	Run()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	然后再在 data 目录下，分别创建 block、cpu、goroutine、mem、mutex 目录，以及对应的 .go 文件。&lt;/p&gt;
&lt;p&gt;​	下面我们来分别看看对应的 .go 文件中的内容，以及它们的作用：&lt;/p&gt;
&lt;h6&gt;block.go&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package block

import (
	&quot;log&quot;
	&quot;time&quot;
)

type Block struct {
}

func (b *Block) Name() string {
	return &quot;block&quot;
}

func (b *Block) Run() {
	log.Println(b.Name(), &quot;Run&quot;)
	// 模拟同步原语
	&amp;amp;lt;-time.After(time.Second)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这里通过将程序睡眠一秒钟，来模拟一些需要等待的操作。&lt;/p&gt;
&lt;h6&gt;cpu.go&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package cpu

import &quot;log&quot;

type Cpu struct {
}

func (c *Cpu) Name() string {
	return &quot;cpu&quot;
}

func (c *Cpu) Run() {
	log.Println(c.Name(), &quot;Run&quot;)
	for i := 0; i &amp;amp;lt; 10000000000; i++ {
		// 模拟不断消耗 CPU
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这段代码通过循环 100 亿次，来模拟不断消耗 CPU 的场景。&lt;/p&gt;
&lt;h6&gt;goroutine.go&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package goroutine

import (
	&quot;log&quot;
	&quot;time&quot;
)

type Goroutine struct {
}

func (g *Goroutine) Name() string {
	return &quot;goroutine&quot;
}

func (g *Goroutine) Run() {
	log.Println(g.Name(), &quot;Run&quot;)
	for i := 0; i &amp;amp;lt; 10; i++ {
		go func() {
			time.Sleep(time.Second * 30) // 确保在每个时刻都有协程活着
		}()
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这里通过创建 10 个协程，并让每个协程睡眠 30 秒，以保证每个时刻都有协程处于活跃状态。&lt;/p&gt;
&lt;h6&gt;mem.go&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package mem

import (
	&quot;log&quot;
	&quot;main/constants&quot;
)

type Mem struct {
	buffer [][constants.Mi]byte
}

func (m *Mem) Name() string {
	return &quot;mem&quot;
}

func (m *Mem) Run() {
	log.Println(m.Name(), &quot;Run&quot;)
	// 分配内存：小于一个 G 就往里面加元素
	for len(m.buffer)*constants.Mi &amp;amp;lt; constants.Gi {
		m.buffer = append(m.buffer, [constants.Mi]byte{})
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这段代码通过不断往 buffer 中分配内存，来模拟实际程序中分配内存的情况。只要内存小于 1 个 G，就每次新分配 1 M。&lt;/p&gt;
&lt;p&gt;​	这里的单位是定义在一个新的目录 constants 中的 constants.go 文件里的，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package constants

// 定义字节
const (
	I = 1 &amp;amp;lt;&amp;amp;lt; (iota * 10)
	Ki
	Mi
	Gi
	Ti
	Pi
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;mutex.go&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package mutex

import (
	&quot;log&quot;
	&quot;main/constants&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

type Mutex struct {
	buffer [][constants.Mi]byte
}

func (m *Mutex) Name() string {
	return &quot;mem&quot;
}

func (m *Mutex) Run() {
	log.Println(m.Name(), &quot;Run&quot;)
	mutex := &amp;amp;amp;sync.Mutex{}
	// 这里模拟了死锁的情况
	mutex.Lock()
	go func() {
		time.Sleep(time.Second)
		mutex.Unlock()
	}()
	mutex.Lock()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这里通过加锁两次、解锁一次，来模拟程序死锁的情况。&lt;/p&gt;
&lt;p&gt;​	至此，我们的准备工作都完成了，下面就开始介绍如何采集信息了。&lt;/p&gt;
&lt;h5&gt;web 网页采集&lt;/h5&gt;
&lt;p&gt;​	我们在项目根目录下创建 main.go 文件，由于是 web 网页采集，所以我们需要起一个 web 服务，然后再去采集该服务的信息。在监听服务前，我们需要开启对锁调用以及对阻塞操作的跟踪，不开启的话抓不到，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
	&quot;log&quot;
	&quot;main/data&quot;
	&quot;main/data/block&quot;
	&quot;main/data/cpu&quot;
	&quot;main/data/goroutine&quot;
	&quot;main/data/mem&quot;
	&quot;main/data/mutex&quot;
	&quot;net/http&quot;
	_ &quot;net/http/pprof&quot;
	&quot;os&quot;
	&quot;runtime&quot;
	&quot;time&quot;
)

var cmds = []data.Cmd{
	&amp;amp;amp;cpu.Cpu{},
	&amp;amp;amp;mem.Mem{},
	&amp;amp;amp;block.Block{},
	&amp;amp;amp;goroutine.Goroutine{},
	&amp;amp;amp;mutex.Mutex{},
}

func main() {
	// 设置日志的输出格式标志：输出包含完整的文件路径和行号
	log.SetFlags(log.Llongfile)
	log.SetOutput(os.Stdout)

	// 开启对锁调用的跟踪，不开启的话抓取不到（下同）
	runtime.SetMutexProfileFraction(1)
	// 开启对阻塞操作的跟踪
	runtime.SetBlockProfileRate(1)

	go func() {
		http.ListenAndServe(&quot;:6060&quot;, nil) // 这里会阻塞，所以需要开一个协程去监听
	}()

	for i := 0; i &amp;amp;lt; 200; i++ {
		for _, v := range cmds {
			v.Run()
		}
		time.Sleep(time.Second)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	通过将之前准备好的各种指标的模拟函数封装到 cmds 里，然后循环调用 200 次，来模拟我们真实的应用程序环境。&lt;/p&gt;
&lt;p&gt;​	然后我们运行 &lt;code&gt;go run main.go&lt;/code&gt; ，再浏览器中访问 &lt;a href=&quot;http://localhost:6060/debug/pprof/&quot;&gt;http://localhost:6060/debug/pprof/&lt;/a&gt; 就能看到我们上面介绍过的性能指标了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/debugPprof.png&quot; alt=&quot;debugPprof&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	我们可以点击到对应的指标进行查看，会发现这种形式我们很难看懂。这个时候，我们可以先点进某个指标的对应页面，比如 allocs，可以看到浏览器中的网址是 &lt;a href=&quot;http://localhost:6060/debug/pprof/allocs?debug=1&quot;&gt;localhost:6060/debug/pprof/allocs?debug=1&lt;/a&gt; 我们把网址中的 &lt;code&gt;?debug=1&lt;/code&gt; 删除，并点击回车，浏览器就会自动帮我们下载对应的文件到我们电脑上，这样我们就获得了该项性能指标的数据了。其他指标也是同样的操作方式，需要强调的是对于 &lt;code&gt;profile&lt;/code&gt; ， 点击它，pprof 会默认采集 30 s 数据，并在采集完成后自动将信息下载电脑上。至于怎么分析，我们后面再来介绍。&lt;/p&gt;
&lt;h5&gt;基准测试采集&lt;/h5&gt;
&lt;p&gt;​	现在我们再来看看第二种采集方式 —— 基准测试采集。其实本质上就是利用性能测试，然后将对应测试的结果以文件的形式输出到对应的目录下保存，然后再对这些采集到的数据用 pprof 工具进行分析即可。关于性能测试方面的知识，可以查看 &lt;a href=&quot;https://oyto.github.io/2023/11/13/Go/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-1&quot;&gt;手把手教你写单元测试 - 胤凯 (oyto.github.io)&lt;/a&gt; 这篇文章。下面我就直接带大家简单的过一下，利用性能测试采集的代码怎么写就行了。&lt;/p&gt;
&lt;p&gt;​	为了方便，我们的基准测试就直接调用之前写好的各类指标的 Run 方法。同样我们在项目根目录下创建一个 data_test 目录，然后创建一个 data_test.go 文件，在里面粘贴我们的基准测试代码即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package data_test

import (
	&quot;main/data/block&quot;
	&quot;main/data/cpu&quot;
	&quot;main/data/goroutine&quot;
	&quot;main/data/mem&quot;
	&quot;main/data/mutex&quot;
	&quot;testing&quot;
)

func BenchmarkData(b *testing.B) {
	b.Run(&quot;block&quot;, func(b *testing.B) {
		o := block.Block{}
		for i := 0; i &amp;amp;lt; b.N; i++ {
			o.Run()
		}
	})
	b.Run(&quot;cpu&quot;, func(b *testing.B) {
		o := cpu.Cpu{}
		for i := 0; i &amp;amp;lt; b.N; i++ {
			o.Run()
		}
	})
	b.Run(&quot;mem&quot;, func(b *testing.B) {
		o := mem.Mem{}
		for i := 0; i &amp;amp;lt; b.N; i++ {
			o.Run()
		}
	})
	b.Run(&quot;goroutine&quot;, func(b *testing.B) {
		o := goroutine.Goroutine{}
		for i := 0; i &amp;amp;lt; b.N; i++ {
			o.Run()
		}
	})
	b.Run(&quot;mutex&quot;, func(b *testing.B) {
		o := mutex.Mutex{}
		for i := 0; i &amp;amp;lt; b.N; i++ {
			o.Run()
		}
	})
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	然后 在 根目录下创建 testout 目录，用于存放我们采集的信息，并在命令行运行 &lt;code&gt;go test -run ^$ -bench . ./data_test/ -blockprofile block.out -cpuprofile cpu.out -memprofile mem.out -mutexprofile mutex.out -trace trace.out -outputdir ./testout&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;​	等待一段时间后，基准测试完成之后，就可以看到采集到的信息已经全部在 testout 中存放了。我们可以试着打开这些文件看一下，会发现是乱码，无法直观的看到对应指标的信息到底是怎么样的。所以我们还是需要通过 pprof 提供的工具进行分析。&lt;/p&gt;
&lt;h5&gt;硬编码采集&lt;/h5&gt;
&lt;p&gt;​	硬编码采集其实和基准测试是差不多的，只是需要我们自己去写对应的采集代码的逻辑，并将采集的信息保存到指定的位置。同样最后，也是需要使用 pprof 工具才能进行分析。&lt;/p&gt;
&lt;p&gt;​	我们在项目根目录创建 code_coolection 目录，在该目录下创建 out 目录和 main.go 文件，并将下面的代码粘贴到 main.go 文件中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
	&quot;log&quot;
	&quot;main/data&quot;
	&quot;main/data/block&quot;
	&quot;main/data/cpu&quot;
	&quot;main/data/goroutine&quot;
	&quot;main/data/mem&quot;
	&quot;main/data/mutex&quot;
	_ &quot;net/http/pprof&quot;
	&quot;os&quot;
	&quot;runtime&quot;
	&quot;runtime/pprof&quot;
	&quot;runtime/trace&quot;
	&quot;time&quot;
)

var cmds = []data.Cmd{
	&amp;amp;amp;cpu.Cpu{},
	&amp;amp;amp;mem.Mem{},
	&amp;amp;amp;block.Block{},
	&amp;amp;amp;goroutine.Goroutine{},
	&amp;amp;amp;mutex.Mutex{},
}

func main() {
	// 设置日志的输出格式标志：输出包含完整的文件路径和行号
	log.SetFlags(log.Llongfile)
	log.SetOutput(os.Stdout)

	// 开启对锁调用的跟踪，不开启的话抓取不到（下同）
	runtime.SetMutexProfileFraction(1)
	// 开启对阻塞操作的跟踪
	runtime.SetBlockProfileRate(1)

	// 硬编码采集 cpu
	cpufile, err := os.OpenFile(&quot;code_collection/out/cpu.out&quot;, os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalln(err)
	}
	// 开始采集
	err = pprof.WriteHeapProfile(cpufile)
	// 停止采集
	defer pprof.StopCPUProfile()
	defer cpufile.Close()

	// 硬编码采集 mem
	memfile, err := os.OpenFile(&quot;code_collection/out/mem.out&quot;, os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalln(err)
	}
	// 开始采集
	err = pprof.WriteHeapProfile(memfile)
	defer memfile.Close()

	// 硬编码采集 trace
	tracefile, err := os.OpenFile(&quot;code_collection/out/trace.out&quot;, os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalln(err)
	}
	// 开始采集
	err = trace.Start(tracefile)
	defer trace.Stop()
	defer tracefile.Close()
	// 业务代码

	for {
		for _, v := range cmds {
			v.Run()
		}
		time.Sleep(time.Second)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	上面的代码可以分为三部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开启一些必要日志输出和锁调用以及阻塞操作调用的跟踪&lt;/li&gt;
&lt;li&gt;编码采集 cpu、mem、trace 信息，并将采集的信息保存下来&lt;/li&gt;
&lt;li&gt;利用之前实现好的接口，模拟业务代码&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;三种采集方式的对比&lt;/h5&gt;
&lt;h6&gt;web 网页采集&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实时可视化:&lt;/strong&gt; 提供实时的可视化界面，便于直观观察应用程序的性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交互式分析:&lt;/strong&gt; 可以通过图形化界面进行交互式的性能分析，查看不同性能指标的详细信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方便易用:&lt;/strong&gt; 无需修改代码，通过 HTTP 请求即可触发性能数据采集。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实时性:&lt;/strong&gt; 不适合长时间运行或对实时性要求较高的生产环境，因为需要手动访问页面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可控性较差:&lt;/strong&gt; 无法在代码中控制何时开始和结束性能采集。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用场景:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;开发和测试阶段:&lt;/strong&gt; 用于开发人员和测试人员在开发、测试过程中对性能进行快速分析和调试。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6&gt;基准测试采集&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可编程:&lt;/strong&gt; 可以通过编写基准测试函数，并使用 &lt;code&gt;testing&lt;/code&gt; 包进行性能采集。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动化:&lt;/strong&gt; 可以在测试套件中自动运行性能测试，方便集成到持续集成流程中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;需要额外编写测试代码:&lt;/strong&gt; 需要编写专门的基准测试代码，不能直接在生产环境中使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用场景:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;持续集成:&lt;/strong&gt; 适用于集成到持续集成流程中，每次构建运行性能测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6&gt;硬编码采集&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;灵活性:&lt;/strong&gt; 可以在代码中灵活选择何时何地采集性能信息，对采集内容有更大的控制权。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定制性高:&lt;/strong&gt; 可以选择性采集特定的性能信息，更符合定制化需求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;需要手动编码:&lt;/strong&gt; 需要在代码中手动添加采集性能信息的逻辑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生产环境谨慎使用:&lt;/strong&gt; 在生产环境中需要慎重使用，避免因为性能采集导致系统负载过大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用场景:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定制化需求:&lt;/strong&gt; 需要根据具体场景定制性能采集逻辑的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Web 网页采集:&lt;/strong&gt; 适合开发和测试阶段，用于快速观察和调试。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基准测试采集:&lt;/strong&gt; 适用于集成到持续集成流程，自动运行性能测试。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬编码采集:&lt;/strong&gt; 适用于需要灵活控制采集逻辑，以及特定场景下的性能调试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;如何分析采集到的信息&lt;/h4&gt;
&lt;p&gt;​	收集到的信息一般都会保存在一个文件中，我们找到该文件，使用 pprof 提供的工具就可以进行分析了。&lt;/p&gt;
&lt;p&gt;​	我们以 cpu.out 文件为例，在命令行中切换到该文件对应的目录，然后使用 &lt;code&gt;go tool pprof cpu.out&lt;/code&gt; ，然后就可以进入到交互模式。&lt;/p&gt;
&lt;h5&gt;top  命令&lt;/h5&gt;
&lt;p&gt;​	我们可以使用 top 命令， 执行 &lt;code&gt;top&lt;/code&gt; 命令后，会在命令行中输出当前的 CPU 消耗排行榜，显示消耗 CPU 最多的函数，帮助快速定位  CPU 使用率最高的部分，默认显示 10 条。可以通过添加参数 &lt;code&gt;top n&lt;/code&gt; 来控制输出的条数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/topics/images/top.png&quot; alt=&quot;top&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flat：函数自身运行的资源消耗&lt;/li&gt;
&lt;li&gt;cum：当前函数加上所用调用栈&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;list 命令&lt;/h5&gt;
&lt;p&gt;​	也可以使用 list Run 命令，执行后会在命令行中输出与函数 &lt;code&gt;Run&lt;/code&gt; 相关的源代码，方便我们快速查找到有问题的源代码所在地，这对于进一步分析和优化性能问题很有帮助。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/topics/images/listRun.png&quot; alt=&quot;listRun&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h5&gt;web 命令&lt;/h5&gt;
&lt;p&gt;​	想使用 web 命令，需要我们先去下载一个插件 &lt;a href=&quot;https://graphviz.gitlab.io/download/&quot;&gt;Download | Graphviz&lt;/a&gt; ，找到对应的系统进行安装，并在配置好环境变量。&lt;/p&gt;
&lt;p&gt;​	同样使用 &lt;code&gt;go tool pprof cpu.out&lt;/code&gt; 进入交互模式，在交互模式下输入 web ，然后会生成一张 svg 格式的图片，并会默认在浏览器中打开。这张图以图形化的方式展示程序中各个函数的调用关系和执行时间。通过这个该图，你可以迅速定位程序的性能瓶颈。深色、宽度较大的块通常表示执行时间较长的函数，可能是需要优化的部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/topics/images/svg.png&quot; alt=&quot;svg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h5&gt;ui 方式查看&lt;/h5&gt;
&lt;p&gt;​	我们还可以使用 &lt;code&gt;go tool pprof -http :8080 cpu.out&lt;/code&gt; 这种方式指定一个端口进行查看。&lt;/p&gt;
&lt;p&gt;​	这种方式会在本地启动一个 HTTP 服务器，并在浏览器中显示性能分析的交互式界面。我们可以通过浏览器直观地浏览性能分析数据，而不必依赖终端界面，而且我们可以将性能分析页面的 URL 分享给其他人，方便团队成员共同分析和解决问题。更为重要的是，&lt;code&gt;-http&lt;/code&gt; 方式提供了实时更新的功能。当程序在运行时采集数据，浏览器中的页面会及时反映这些数据的变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/topics/images/pprofhttp.png&quot; alt=&quot;pprofhttp&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	其实 ui 方式，就是将命令行下一些参数所显示的信息，通过图形界面向我们展示。比如：&lt;/p&gt;
&lt;h6&gt;VIEW&lt;/h6&gt;
&lt;p&gt;​	VIEW 下的选项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;top：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用：&lt;/strong&gt; 显示性能分析的顶级函数列表，按照 CPU 使用时间排序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 用于查看程序中占用 CPU 时间最多的函数，帮助确定性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;graph：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用：&lt;/strong&gt; 生成并显示调用图（call graph）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 提供了函数之间调用关系的可视化，有助于理解代码的调用流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;flame Graph：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用：&lt;/strong&gt; 生成并显示火焰图。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 火焰图是一种可视化工具，直观显示函数调用关系和执行时间，更容易发现性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;peek：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用：&lt;/strong&gt; 显示函数的源码和汇编码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 提供了在源码和汇编级别查看函数的功能，用于深入分析函数执行过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;source：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用：&lt;/strong&gt; 显示函数的源码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 提供了在源码级别查看函数的功能，便于理解代码的具体实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;disassemble：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用：&lt;/strong&gt; 显示函数的汇编码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 提供了在汇编级别查看函数的功能，有助于深入了解函数的底层执行过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h6&gt;SAMPLE&lt;/h6&gt;
&lt;p&gt;​	SAMPLE 下的选项：&lt;code&gt;samples&lt;/code&gt; 和 &lt;code&gt;cpu&lt;/code&gt; 是两个常用的命令，用于查看不同类型的性能样本信息。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;samples：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用：&lt;/strong&gt; 表示程序在采样时的状态信息，记录了堆栈跟踪信息和对应的采样计数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 用于采样分析，通过收集一系列采样数据，可以了解程序在不同时刻的执行情况，帮助找出热点代码和性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cpu：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用：&lt;/strong&gt; 表示 CPU 使用时间的信息，记录了每个函数的 CPU 使用时间和调用次数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 用于 CPU 时间分析，提供了函数级别的 CPU 使用情况，帮助确定哪些函数占用了大量的 CPU 时间，从而找到潜在的性能问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h6&gt;REFINE&lt;/h6&gt;
&lt;p&gt;​	REFINE 下的选项：&lt;code&gt;focus&lt;/code&gt;、&lt;code&gt;ignore&lt;/code&gt;、&lt;code&gt;hide&lt;/code&gt;、&lt;code&gt;show&lt;/code&gt;、&lt;code&gt;show from&lt;/code&gt;、&lt;code&gt;reset&lt;/code&gt; 是用于调整视图的命令。它们的作用如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;focus：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用：&lt;/strong&gt; 将视图聚焦于指定的函数，只显示与该函数相关的信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 用于关注某个特定函数，查看与该函数相关的性能信息，便于深入分析该函数的性能状况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ignore：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用：&lt;/strong&gt; 忽略指定函数，不显示与该函数相关的信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 用于排除某些函数，以便在性能分析中聚焦于其他关键函数，减少视图的干扰。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hide：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用：&lt;/strong&gt; 隐藏指定函数及其调用图，不显示在视图中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 用于在视图中隐藏一些不感兴趣或者不重要的函数，简化视图。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;show：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用：&lt;/strong&gt; 显示之前被隐藏的函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 用于取消之前使用 &lt;code&gt;hide&lt;/code&gt; 命令隐藏的函数，重新在视图中显示。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;show from：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用：&lt;/strong&gt; 从指定函数开始显示调用图。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 设置一个起始点，从该点开始显示函数的调用图，有助于查看特定路径的调用关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reset：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用：&lt;/strong&gt; 重置视图，取消之前的 &lt;code&gt;focus&lt;/code&gt;、&lt;code&gt;ignore&lt;/code&gt;、&lt;code&gt;hide&lt;/code&gt; 等操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 用于还原视图到最初的状态，清除之前的调整，重新全面查看性能信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	这些命令提供了在交互模式下调整视图的灵活性，使用户能够更好地根据具体需求选择和排除函数，以获取更有针对性的性能分析信息。&lt;/p&gt;
&lt;h6&gt;CONFIG&lt;/h6&gt;
&lt;p&gt;​	CONFIG 下的选项：Save as ... 和 Default 是在 Web UI中的一些配置选项。作用如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Save as ...&lt;/strong&gt;: 这个选项允许您保存当前的配置为一个命名的配置文件。配置文件包含了视图布局、颜色方案等信息。通过保存配置，您可以在将来重新加载相同的配置，方便重复使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Default&lt;/strong&gt;: 这个选项是将当前的配置设置为默认配置。默认配置会在下次打开 &lt;code&gt;go tool pprof&lt;/code&gt; 时自动加载。这对于您希望在多次运行中使用相同的配置时很有用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	这两个选项的目的在于提供一种灵活的方式，使用户能够保存和恢复他们喜欢的配置，或者设置一个默认配置以简化工作流。这对于在不同的分析任务之间切换，或者在不同的会话中保持一致的可视化设置都很有帮助。&lt;/p&gt;
&lt;h6&gt;DOWNLOAD&lt;/h6&gt;
&lt;p&gt;​	&lt;code&gt;Download&lt;/code&gt; 选项允许您下载当前的图形化展示或报告。下载之后，会生成一个 .pb 文件，同样需要配合 go tool pprof 使用。&lt;/p&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;​	这篇文章，带大家了解了 pprof 工具，并带大家熟悉了 pprof 工具的使用方法，相信大家在未来一定会使用到这款工具的，毕竟一位优秀的程序员，写出来的代码一定是 “三高” 代码。&lt;/p&gt;
</description><link>https://studygolang.com/topics/17018</link><guid isPermaLink="false">https://studygolang.com/topics/17018</guid><pubDate>Sat, 09 Dec 2023 08:03:43 GMT</pubDate><author>oYto</author><category>每日一学</category></item><item><title>[go 面试] 深入理解并发控制：掌握锁的精髓</title><description>&lt;p&gt;&amp;gt; 关注公众号【爱发白日梦的后端】分享技术干货、读书笔记、开源项目、实战经验、高效开发工具等，您的关注将是我的更新动力！
&amp;gt;&lt;/p&gt;
&lt;p&gt;在并发编程中，锁是保障共享资源安全访问的重要机制。本文将深入探讨不同类型的锁、公平锁与非公平锁的对比、乐观锁与悲观锁的选择以及信号量与锁的区别，助你更好地应对并发场景。&lt;/p&gt;
&lt;h2&gt;1. 锁的种类&lt;/h2&gt;
&lt;h3&gt;1.1 互斥锁（Mutex Lock）&lt;/h3&gt;
&lt;p&gt;互斥锁是最基本的锁类型，用于保护共享资源。同一时间只允许一个线程或进程获取锁，其他的线程或进程需要等待锁的释放。&lt;/p&gt;
&lt;h3&gt;1.2 读写锁（Read-Write Lock）&lt;/h3&gt;
&lt;p&gt;读写锁允许多个线程同时读取共享资源，但只允许一个线程进行写入操作。读操作之间不会互斥，而写操作必须独占锁。&lt;/p&gt;
&lt;h3&gt;1.3 自旋锁（Spin Lock）&lt;/h3&gt;
&lt;p&gt;自旋锁在多核系统中使用，当线程请求锁时，它会等待直到获取到锁。相比于互斥锁，自旋锁避免了线程切换的开销，适用于锁竞争时间短暂的情况。&lt;/p&gt;
&lt;h3&gt;1.4 读写自旋锁（Read-Write Spin Lock）&lt;/h3&gt;
&lt;p&gt;优化的读写锁，适用于读操作频繁、写操作较少的场景，提高读操作的并发性能。&lt;/p&gt;
&lt;h3&gt;1.5 条件变量（Condition Variable）&lt;/h3&gt;
&lt;p&gt;用于线程之间的同步和通信，让线程等待某个条件的满足，并在条件满足时通知等待的线程继续执行。&lt;/p&gt;
&lt;h3&gt;1.6 信号量（Semaphore）&lt;/h3&gt;
&lt;p&gt;一种计数器，用于控制对共享资源的访问，限制同时访问资源的线程或进程数量。&lt;/p&gt;
&lt;h3&gt;1.7 递归锁（Recursive Lock）&lt;/h3&gt;
&lt;p&gt;允许同一个线程或进程多次获取同一个锁，避免了死锁情况的发生。&lt;/p&gt;
&lt;h2&gt;2. 公平锁 / 非公平锁&lt;/h2&gt;
&lt;h3&gt;2.1 公平锁&lt;/h3&gt;
&lt;p&gt;保证锁获取的顺序与线程请求锁的顺序相一致，避免饥饿问题，但可能会导致额外的线程切换开销。&lt;/p&gt;
&lt;h3&gt;2.2 非公平锁&lt;/h3&gt;
&lt;p&gt;不保证锁获取顺序与线程请求锁的顺序一致，减少线程切换开销，提高锁的吞吐量，但可能导致某些线程长时间获取不到锁，出现饥饿问题。&lt;/p&gt;
&lt;p&gt;选择公平锁或非公平锁取决于具体的应用场景和需求。&lt;/p&gt;
&lt;h2&gt;3. 乐观锁 / 悲观锁&lt;/h2&gt;
&lt;h3&gt;3.1 悲观锁&lt;/h3&gt;
&lt;p&gt;保守的策略，假设并发环境下会有其他线程对共享资源进行修改，因此在访问共享资源之前会将其锁定。&lt;/p&gt;
&lt;h3&gt;3.2 乐观锁&lt;/h3&gt;
&lt;p&gt;更为乐观的策略，假设并发冲突较少发生，在操作之后检查是否有其他线程对该资源进行了修改。&lt;/p&gt;
&lt;p&gt;选择乐观锁还是悲观锁取决于应用场景，悲观锁适用于对数据一致性要求较高的情况，而乐观锁适用于读多写少的情况。&lt;/p&gt;
&lt;h2&gt;4. 信号量和锁的区别&lt;/h2&gt;
&lt;p&gt;信号量用于控制对共享资源的访问数量，可以限制同时访问资源的线程或进程数量。锁用于保护单个共享资源的互斥访问。信号量更适合控制并发访问数量，而锁更适合保护单个资源的安全访问。&lt;/p&gt;
&lt;p&gt;在实际应用中，选择合适的锁类型、调度策略，以及并发控制机制，将有助于提高系统的稳定性和性能。&lt;/p&gt;
</description><link>https://studygolang.com/topics/17017</link><guid isPermaLink="false">https://studygolang.com/topics/17017</guid><pubDate>Sat, 09 Dec 2023 05:45:52 GMT</pubDate><author>TimLiuDream</author><category>每日一学</category></item><item><title>手把手用 Go 带你写一个小工具</title><description>&lt;p&gt;&amp;gt; 欢迎大家到我的博客浏览 &amp;lt;a href=&quot;&lt;a href=&quot;https://www.yinkai.cc/post/af0e9d38c0f30cc51c0bcc25e449709e&quot;&gt;https://www.yinkai.cc/post/af0e9d38c0f30cc51c0bcc25e449709e&lt;/a&gt;&quot;&amp;gt;YinKai &#39;s Blog | 手把手带你写一个小工具&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;​	这篇文章带大家动手实现一个小工具，能够将一个 Go 文件中的注释内容删除。&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;p&gt;​	起因是这样的，我在写文章的时候，最后需要附上项目的源码，然后就发现我在写代码的时候加了很多注释，然后需要自己手动注释很麻烦，于是就想着写这样一个工具，去代替手动删除注释这一项工作。&lt;/p&gt;
&lt;p&gt;​	当然我知道可以用 AI 来做这件事，但我就是想写一个工具，别烦！&lt;/p&gt;
&lt;h4&gt;需求分析&lt;/h4&gt;
&lt;p&gt;​	首先我们要清楚，Go 语言中的注释分为两种：单行注释和多行注释。&lt;/p&gt;
&lt;p&gt;​	单行注释，是采用 &lt;code&gt;// ....&lt;/code&gt; 的形式，将注释写在 &lt;code&gt;//&lt;/code&gt; 的后面；&lt;/p&gt;
&lt;p&gt;​	而多行注释，是采用 &lt;code&gt;/* ... */&lt;/code&gt; 的方式，将注释写在 &lt;code&gt;/*&lt;/code&gt; 和 &lt;code&gt;*/&lt;/code&gt; 之间的。&lt;/p&gt;
&lt;p&gt;​	我们的目的是将一个 Go 文件的注释删除，并出到另一个文件中。为什么这里不直接修改源文件？因为避免程序出错，导致源文件的代码丢失。&lt;/p&gt;
&lt;p&gt;​	那这个过程中就会涉及到文件的打开关闭以及写入、如何正确识别单行注释和多行注释、如何处理一些特殊情况等问题，下面我们会一一展开说明。&lt;/p&gt;
&lt;h4&gt;代码实现&lt;/h4&gt;
&lt;p&gt;​	由于这只是一个小工具，我们就把所有的代码全部写在一个 main.go 文件就足够了。&lt;/p&gt;
&lt;p&gt;​	我们的实现过程，大概是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过命令行指定需要处理的 Go 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据文件名调用对应的功能函数去进行处理&lt;/p&gt;
&lt;p&gt;a. 打开文件&lt;/p&gt;
&lt;p&gt;b. 删除注释和空行&lt;/p&gt;
&lt;p&gt;c. 重新构建一个新的文件，并将处理后的结果写入文件中&lt;/p&gt;
&lt;p&gt;d. 控制台输出打印成功&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果出现错误，就在控制台中打印信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	下面我们就根据上面的步骤一步一步实现我们的小工具。&lt;/p&gt;
&lt;h5&gt;获取文件&lt;/h5&gt;
&lt;p&gt;​	首先，我们在项目根目录下创建一个 main.go 文件和 todo.go 文件。可以提前在 todo.go 文件中放一段带有注释的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
)

// saveToFile 保存数据到文件
// 参数：
//   filePath: 要保存的文件路径
//   data: 要保存的数据
// 返回值：
//   error: 如果保存成功，则为nil；否则为保存失败的错误信息
func saveToFile(filePath string, data string) error {
	// 使用 os.WriteFile 函数将数据写入文件
	err := os.WriteFile(filePath, []byte(data), 0644)
	if err != nil {
		// 如果写入文件出错，返回错误信息
		return fmt.Errorf(&quot;保存文件失败：%v&quot;, err)
	}

	// 文件保存成功，返回nil表示没有错误
	return nil
}

func main() {
	// 要保存的数据
	dataToSave := &quot;Hello, this is some data to be saved to a file.&quot;

	// 保存数据到文件
	err := saveToFile(&quot;output.txt&quot;, dataToSave)
	if err != nil {
		// 如果保存失败，打印错误信息
		fmt.Println(err)
		return
	}

	// 文件保存成功
	fmt.Println(&quot;文件保存成功！&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	然后就可以写我们的主函数代码了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func main() {
	if len(os.Args) &amp;amp;lt; 2 {
		fmt.Println(&quot;请提供要处理的Go文件&quot;)
		return
	}

	filePath := os.Args[1]

	err := removeComments(filePath)
	if err != nil {
		fmt.Printf(&quot;错误: %v\n&quot;, err)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;首先判断是否指定了待处理的文件：这里直接通过判断命令行参数的个数判断即可&lt;/li&gt;
&lt;li&gt;然后将文件的路径取出，传入 &lt;code&gt;removeComments&lt;/code&gt; 函数即可&lt;/li&gt;
&lt;li&gt;如果出错了，就打印对应的信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	然后我们来看看 &lt;code&gt;removeComments&lt;/code&gt; 函数的实现逻辑：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func removeComments(filePath string) error {
	// 打开文件
	file, err := os.Open(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	// 删除注释 和 空行 并保存
	output, err := removeNote(file)
	if err != nil {
		return err
	}

	// 将结果保存到新文件中
	outputFilePath := &quot;output.txt&quot;
	err = os.WriteFile(outputFilePath, []byte(output), 0644)
	if err != nil {
		return err
	}

	// 打印操作成功的消息
	fmt.Printf(&quot;注释已删除，并已保存到 %s 文件中。\n&quot;, outputFilePath)

	return err
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这里相当于一个代理层，并没有将核心的删注释逻辑写在这里，这个函数只是做一个文件的打开关闭，以及将处理后的文件写入新文件的操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开文件，并在检查是否发生错误&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;removeNote&lt;/code&gt; 函数删除注释和空行，并返回一个字符串&lt;/li&gt;
&lt;li&gt;将字符串转换为字节数组，写入新文件&lt;/li&gt;
&lt;li&gt;最后打印操作成功的提示信息&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;核心逻辑&lt;/h5&gt;
&lt;p&gt;​	我们的核心处理逻辑，就在 &lt;code&gt;removeNote&lt;/code&gt; 函数中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func removeNote(file *os.File) (string, error) {
	// 创建一个新的扫描器，用于逐行读取文件内容
	scanner := bufio.NewScanner(file)
	// 用于跟踪是否在多行注释中
	inMultilineComment := false
	var output string

	// 逐行扫描文件内容
	for scanner.Scan() {
		line := scanner.Text()
		// 处理多行注释
		if inMultilineComment {
			// 查找多行注释结束标记 &quot;*/&quot;
			endIndex := regexp.MustCompile(&quot;\\*/&quot;).FindStringIndex(line)
			if endIndex != nil {
				// 多行注释结束，更新标志并截取剩余部分
				inMultilineComment = false
				//isDelete = true
				line = line[endIndex[1]:]
			} else {
				// 如果当前行还在多行注释中，跳过处理并继续下一行
				continue
			}
		}

		// 处理单行注释和多行注释的开始
		lineWithoutComments, _ := processLine(line, &amp;amp;amp;inMultilineComment)

		if hasNonSpaceCharacters(lineWithoutComments) {
			// 将处理后的行添加到结果字符串
			output += lineWithoutComments + &quot;\n&quot;
		}
	}

	// 检查扫描文件时是否发生错误
	if err := scanner.Err(); err != nil {
		return &quot;&quot;, err
	}
	return output, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先我们创建一个扫描器，从传入的文件指针开始逐行读取文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个标志位，用于跟踪是否存在多行注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开始逐行扫描内容&lt;/p&gt;
&lt;p&gt;a. 先对多行注释进行处理，因为可能在本行的前面几行就已经开启了多行注释，所以需要先判断多行注释的结尾。判断的逻辑就是利用正则表达式寻找本行是否存在 &lt;code&gt;*/&lt;/code&gt;，存在的话，就通过下标截取&lt;code&gt;*/&lt;/code&gt;之前的部分，并更新标志位&lt;/p&gt;
&lt;p&gt;b. 然后再对单行注释和多行注释的处理&lt;/p&gt;
&lt;p&gt;c. 处理完成之后，将非空行添加到输出&lt;code&gt;output&lt;/code&gt; 中&lt;/p&gt;
&lt;p&gt;d. 最后再检查一下扫描文件时，是否发生错误即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	最后我们再来看看 &lt;code&gt;processLine&lt;/code&gt; 函数，这里就是对单行注释和多行注释的判断，其实本质都是一样的，都是通过正则表达式找到对应的符合 &lt;code&gt;//&lt;/code&gt; 和 &lt;code&gt;/*&lt;/code&gt; ，然后再进行内容的截取，最后将截取的内容返回即可，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func processLine(line string, inMultilineComment *bool) (string, bool) {
	// 该行是否需要删除：单行注释 或者 多行注释的时候
	// 处理单行注释
	index := regexp.MustCompile(&quot;//&quot;).FindStringIndex(line)
	if index != nil {
		// 截取注释之前的部分
		if index[0] != 0 &amp;amp;amp;&amp;amp;amp; line[index[0]-1] == &#39;&quot;&#39; {

		} else {
			line = line[:index[0]]
		}
	}

	// 处理多行注释的开始
	startIndex := regexp.MustCompile(&quot;/\\*&quot;).FindStringIndex(line)
	if startIndex != nil {
		// 进入多行注释状态，并截取注释之前的部分
		*inMultilineComment = true
		// 查找本行是不是就结束了
		isEnd := false
		endIndex := regexp.MustCompile(&quot;\\*/&quot;).FindStringIndex(line)
		if endIndex != nil {
			// 多行注释结束，更新标志并截取剩余部分
			*inMultilineComment = false
			isEnd = true
		}
		if isEnd {
			line = line[:startIndex[0]] + line[endIndex[1]:]
		} else {
			line = line[:startIndex[0]]
		}
	}

	// 返回处理后的行和更新后的多行注释状态
	return line, *inMultilineComment
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;完整代码&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;regexp&quot;
	&quot;strings&quot;
)

func main() {
	if len(os.Args) &amp;amp;lt; 2 {
		fmt.Println(&quot;请提供要处理的Go文件&quot;)
		return
	}

	filePath := os.Args[1]

	err := removeComments(filePath)
	if err != nil {
		fmt.Printf(&quot;错误: %v\n&quot;, err)
	}
}

func removeComments(filePath string) error {
	file, err := os.Open(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	output, err := removeNote(file)
	if err != nil {
		return err
	}

	outputFilePath := &quot;output.txt&quot;
	err = os.WriteFile(outputFilePath, []byte(output), 0644)
	if err != nil {
		return err
	}

	fmt.Printf(&quot;注释已删除，并已保存到 %s 文件中。\n&quot;, outputFilePath)

	return err
}

func removeNote(file *os.File) (string, error) {
	scanner := bufio.NewScanner(file)
	inMultilineComment := false
	var output string

	for scanner.Scan() {
		line := scanner.Text()

		if inMultilineComment {
			endIndex := regexp.MustCompile(&quot;\\*/&quot;).FindStringIndex(line)
			if endIndex != nil {
				inMultilineComment = false
				line = line[endIndex[1]:]
			} else {
				continue
			}
		}

		lineWithoutComments, _ := processLine(line, &amp;amp;amp;inMultilineComment)

		if hasNonSpaceCharacters(lineWithoutComments) {
			output += lineWithoutComments + &quot;\n&quot;
		}
	}

	if err := scanner.Err(); err != nil {
		return &quot;&quot;, err
	}
	return output, nil
}

func hasNonSpaceCharacters(line string) bool {
	trimmed := strings.TrimSpace(line)
	return trimmed != &quot;&quot;
}

func processLine(line string, inMultilineComment *bool) (string, bool) {
	index := regexp.MustCompile(&quot;//&quot;).FindStringIndex(line)
	if index != nil {
		if index[0] != 0 &amp;amp;amp;&amp;amp;amp; line[index[0]-1] == &#39;&quot;&#39; {

		} else {
			line = line[:index[0]]
		}
	}

	startIndex := regexp.MustCompile(&quot;/\\*&quot;).FindStringIndex(line)
	if startIndex != nil {
		*inMultilineComment = true
		isEnd := false
		endIndex := regexp.MustCompile(&quot;\\*/&quot;).FindStringIndex(line)
		if endIndex != nil {
			*inMultilineComment = false
			isEnd = true
		}
		if isEnd {
			line = line[:startIndex[0]] + line[endIndex[1]:]
		} else {
			line = line[:startIndex[0]]
		}
	}

	return line, *inMultilineComment
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;代码执行&lt;/h4&gt;
&lt;p&gt;​	我们利用提前创建好的 todo.go 文件，是不是使用 &lt;code&gt;go run main.go todo.go&lt;/code&gt; 命令，就可以删除注释了？&lt;/p&gt;
&lt;p&gt;​	我们可以来试一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;go run main.go todo.go
文件保存成功！
请提供要处理的Go文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	出现了意外情况，这里并没有获取到 todo.go 文件，而是将 todo.go 文件当做需要运行的程序去运行了。&lt;/p&gt;
&lt;p&gt;​	解决的办法有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个是将需要删除注释的代码放在 .txt 文件中&lt;/li&gt;
&lt;li&gt;先编译 main.go 文件，然后再将需要处理的文件当做参数运行 main.exe 文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	两个办法都很容易理解，第一个的话，你把后缀名改掉，&lt;code&gt;go run&lt;/code&gt;命令自然就不会去执行该文件了。第二个办法的话， 我们这里可以再引入一个 Makefile 文件，将多部操作进行一个合并，我们只需要使用 &lt;code&gt;make&lt;/code&gt; 命令就可以执行我们预习定义好的命令了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-makefile&quot;&gt;# Makefile

.PHONY: all

all: build run

build:
	go build main.go

run:
	./main.exe todo.go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	我们来解释一下这个文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;.PHONY: all&lt;/code&gt;：声明 &lt;code&gt;all&lt;/code&gt; 是一个伪目标。伪目标通常是一些不产生实际文件的任务，而只是执行其他任务的别名。这里的 &lt;code&gt;.PHONY&lt;/code&gt; 告诉 make 工具 &lt;code&gt;all&lt;/code&gt; 是一个伪目标，不要去检查是否有一个文件名为 &lt;code&gt;all&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;all: build run&lt;/code&gt;：定义了一个名为 &lt;code&gt;all&lt;/code&gt; 的目标，它依赖于 &lt;code&gt;build&lt;/code&gt; 和 &lt;code&gt;run&lt;/code&gt; 两个目标。当执行 &lt;code&gt;make all&lt;/code&gt; 时，它将首先执行 &lt;code&gt;build&lt;/code&gt;，然后执行 &lt;code&gt;run&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build:&lt;/code&gt;：定义了一个名为 &lt;code&gt;build&lt;/code&gt; 的目标。当执行 &lt;code&gt;make build&lt;/code&gt; 时，它将执行后面的命令，即 &lt;code&gt;go build main.go&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;run:&lt;/code&gt;：定义了一个名为 &lt;code&gt;run&lt;/code&gt; 的目标。当执行 &lt;code&gt;make run&lt;/code&gt; 时，它将执行后面的命令，即 &lt;code&gt;./main.exe todo.go&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	然后我们直接使用  &lt;code&gt;make all&lt;/code&gt; 和 &lt;code&gt;make run&lt;/code&gt; 就能这个小工具了&lt;/p&gt;
&lt;h4&gt;小结&lt;/h4&gt;
&lt;p&gt;​	这篇文章，我从实际出发，带大家手把手写了一个小工具，还涉及到 Makefile 文件的简单使用，希望对大家能够提供帮助。&lt;/p&gt;
&lt;p&gt;​	在平时的学习生活中，大家也可以像我这样，把遇到的一些问题，试着抽象出来，看看能不能实现一个工具，去便捷地完成它们。&lt;/p&gt;
</description><link>https://studygolang.com/topics/17014</link><guid isPermaLink="false">https://studygolang.com/topics/17014</guid><pubDate>Fri, 08 Dec 2023 04:14:59 GMT</pubDate><author>oYtoLIGUANGYAO</author><category>每日一学</category></item><item><title>[go 面试] 接口测试的方法与技巧</title><description>&lt;p&gt;&amp;gt; 关注公众号【爱发白日梦的后端】分享技术干货、读书笔记、开源项目、实战经验、高效开发工具等，您的关注将是我的更新动力！
&amp;gt;&lt;/p&gt;
&lt;p&gt;接口测试是确保软件系统接口功能、性能和可靠性等方面的关键步骤。以下是一些常见的接口测试方法和技巧：&lt;/p&gt;
&lt;h2&gt;1. &lt;strong&gt;输入验证&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;验证接口对于不同的输入数据是否正确处理和响应，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正常输入&lt;/li&gt;
&lt;li&gt;边界条件&lt;/li&gt;
&lt;li&gt;异常输入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;确保接口在各种输入情况下都能正常工作。&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;接口协议测试&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;验证接口是否符合定义的协议规范，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP协议&lt;/li&gt;
&lt;li&gt;SOAP协议&lt;/li&gt;
&lt;li&gt;RESTful规范&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查协议实现是否正确，确保接口按照标准进行通信。&lt;/p&gt;
&lt;h2&gt;3. &lt;strong&gt;接口功能测试&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;测试接口的功能是否按照需求正确实现，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求和响应数据的正确性&lt;/li&gt;
&lt;li&gt;接口逻辑的正确执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;确保接口的功能满足用户需求，检查返回的数据是否符合预期。&lt;/p&gt;
&lt;h2&gt;4. &lt;strong&gt;接口性能测试&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;通过模拟各种场景，测试接口在高负载情况下的性能表现，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应时间&lt;/li&gt;
&lt;li&gt;吞吐量
-并发性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;确保接口在真实使用场景下能够稳定高效地工作。&lt;/p&gt;
&lt;h2&gt;5. &lt;strong&gt;接口安全测试&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;测试接口对于安全漏洞的防护能力，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未授权访问&lt;/li&gt;
&lt;li&gt;SQL注入&lt;/li&gt;
&lt;li&gt;跨站脚本攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;确保接口对于潜在的安全风险具有防护机制。&lt;/p&gt;
&lt;h2&gt;6. &lt;strong&gt;接口稳定性测试&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;通过模拟长时间运行和大数据量操作，验证接口的稳定性和可靠性，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存泄漏&lt;/li&gt;
&lt;li&gt;资源耗尽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;确保接口在持续运行中不会出现性能下降或系统崩溃。&lt;/p&gt;
&lt;h2&gt;7. &lt;strong&gt;接口集成测试&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;测试接口与其他系统组件的集成情况，确保接口在与其他系统组件交互时的正确性和稳定性。&lt;/p&gt;
&lt;h2&gt;8. &lt;strong&gt;Mock 测试&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;使用模拟对象替代真实的依赖对象，测试接口的特定行为是否符合预期。Mock 测试可帮助隔离依赖，使测试更灵活和独立。&lt;/p&gt;
&lt;p&gt;在进行接口测试时，使用各种测试工具和框架如Postman、JMeter、RestAssured等，并考虑自动化测试以提高效率和准确性。通过这些方法和技巧，可以有效保障软件系统接口的质量和可靠性。&lt;/p&gt;
</description><link>https://studygolang.com/topics/17011</link><guid isPermaLink="false">https://studygolang.com/topics/17011</guid><pubDate>Thu, 07 Dec 2023 14:30:45 GMT</pubDate><author>TimLiuDreamLIGUANGYAO</author><category>每日一学</category></item><item><title>手把手教你用go语言实现生产者消费者模式</title><description>&lt;p&gt;&amp;gt; 欢迎大家到我的博客浏览 &amp;lt;a href=&quot;&lt;a href=&quot;https://www.yinkai.cc/post/f07fe1e9850811ed7745690013acaace&quot;&gt;https://www.yinkai.cc/post/f07fe1e9850811ed7745690013acaace&lt;/a&gt;&quot;&amp;gt;YinKai &#39;s Blog | 手把手教你用go语言实现生产者消费者模式&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;​	本篇文章会从生产者消费者模式的定义、特点、流程等方面为大家展开介绍，并带大家手把手来实现一下生产者消费者模式。&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;h3&gt;一、 简介&lt;/h3&gt;
&lt;p&gt;​	生产者消费者模式是一种并发设计模式，用于解决多线程环境下生产者和消费者之间的协作和数据共享问题。在这个模式中，有两种不同的角色：生产者和消费者，它们共同操作一个共享的缓冲区，以实现线程间的安全通信。&lt;/p&gt;
&lt;p&gt;​	它的应用场景和优点如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;异步任务处理&lt;/strong&gt;：在异步编程中，生产者可以生成异步任务，而消费者负责处理这些任务。生产者消费者模式可以有效地协调异步任务的生成和处理，提高系统的响应速度。&lt;/li&gt;
&lt;li&gt;**缓冲区处理：**当生产者和消费者的处理速度不一致时，通过引入缓冲区，可以平衡两者之间的速度差异。生产者将数据放入缓冲区，而消费者从缓冲区中获取数据，使两者能够独立运行，提高系统的效率。&lt;/li&gt;
&lt;li&gt;**任务调度：**在任务调度系统中，生产者可以生成需要执行的任务，而消费者负责执行这些任务。通过生产者消费者模式，可以灵活地管理和调度任务，实现任务的分发和执行的解耦。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息队列：&lt;/strong&gt; 生产者消费者模式常用于消息队列的实现。生产者向队列中发送消息，而消费者从队列中获取消息进行处理。这种模式使得消息的生成和处理能够异步进行，提高了系统的可伸缩性和可维护性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解耦生产者和消费者：&lt;/strong&gt; 生产者和消费者之间的解耦使得系统更加灵活和可维护。可以独立地修改和扩展生产者和消费者的实现，而不影响整个系统的稳定性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;二、角色&lt;/h3&gt;
&lt;p&gt;​	在生产者消费者模式中有三个角色，分别是生产者、消费者和缓冲区，下面为大家分别介绍这两个角色的职责和特点：&lt;/p&gt;
&lt;h5&gt;生产者&lt;/h5&gt;
&lt;p&gt;​	生产者主要的职责是生成数据并将数据放入共享的缓冲区，并在缓冲区已满时进行等待。&lt;/p&gt;
&lt;p&gt;​	它的特点是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;独立运行&lt;/strong&gt;：可以以自己的速度生成数据，而不必等待消费者的处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据生成&lt;/strong&gt;：主要关注数据的生成和放置，不涉及具体的数据处理逻辑，不关心数据的最终用途。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可能阻塞&lt;/strong&gt;：当缓冲区已满时，生产者可能会被阻塞，以此确保生产者和消费者之间的同步。&lt;/li&gt;
&lt;li&gt;**任务分配：**生产者可以根据需求，将生成的数据进行分配和调度，将数据分发给不同的消费者进行处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;消费者&lt;/h5&gt;
&lt;p&gt;​	消费者主要的职责是从共享的缓冲区中获取数据并进行处理，并在缓冲区为空时进行等待。&lt;/p&gt;
&lt;p&gt;​	它的特点是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;独立运行：&lt;/strong&gt; 它可以以自己的速度从缓冲区中获取数据，而不必等待生产者的生成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据处理：&lt;/strong&gt; 主要关注对获取的数据的处理，而不涉及数据的生成过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可能阻塞：&lt;/strong&gt; 当缓冲区为空时，消费者可能会被阻塞，这确保了生产者和消费者之间的同步。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;任务执行：&lt;/strong&gt; 消费者可能负责实际执行任务的逻辑，如处理消息、执行计算等，取决于具体应用场景。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;缓冲区&lt;/h5&gt;
&lt;p&gt;​	缓冲区在生产者消费者模式中起到了关键的作用，其主要作用是作为生产者和消费者之间的中介，用于存储生产者生成的数据，以便消费者能够安全、有序地获取这些数据。&lt;/p&gt;
&lt;p&gt;​	缓冲区相当于提供了一个同步点，使得生产者和消费者能够协调它们的操作。缓冲区提供一定量的数据，生产者生成数据放入缓冲区，消费者从缓冲区获取数据，两者之间通过缓冲区进行间接通信，不需要直接依赖对方的状态，这样可以使得两者之间可以异步操作，而不会导致数据丢失或不一致。&lt;/p&gt;
&lt;p&gt;​	它的重要性如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;防止竞态条件：&lt;/strong&gt; 避免了生产者和消费者之间的竞态条件，确保了在多线程环境中的数据访问的正确性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高系统吞吐量：&lt;/strong&gt; 缓冲区的使用可以提高系统的吞吐量，使得生产者和消费者能够以各自的速度进行操作，而不会互相阻塞。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;减少资源竞争：&lt;/strong&gt; 缓冲区作为共享的数据结构，通过合适的同步机制，减少了对共享资源的竞争，提高了系统的效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增加系统灵活性：&lt;/strong&gt; 缓冲区的引入使得系统更加灵活，可以调整缓冲区的大小以满足不同场景的需求，同时提供了一个中介层，使得系统的不同部分能够独立演化而不影响整体结构。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;三、基本流程&lt;/h3&gt;
&lt;h5&gt;生产者将数据放入缓冲区的步骤&lt;/h5&gt;
&lt;p&gt;​	生产者将数据放入缓冲区的过程包括获取互斥锁，检查缓冲区状态，将生成的数据放入缓冲区，然后释放互斥锁。&lt;/p&gt;
&lt;h5&gt;消费者从缓冲区获取数据的步骤&lt;/h5&gt;
&lt;p&gt;​	消费者从缓冲区获取数据的过程包括获取互斥锁，检查缓冲区状态，获取数据进行处理，然后释放互斥锁。&lt;/p&gt;
&lt;p&gt;​	可能有人会问，“ 为什么使用缓冲区，而不是直接生产者和消费者直接通信？”&lt;/p&gt;
&lt;p&gt;​	使用缓冲区的主要原因在于解耦和同步。缓冲区作为一个中介，提供了一个独立的数据存储空间，使得生产者和消费者可以独立运行，不需要即时通信。这种解耦性增加了系统的灵活性，允许生产者和消费者以各自的速度操作数据，而不必互相等待。同时，缓冲区通过同步机制确保了线程安全，防止了数据竞争和不一致性问题，从而提高了系统的稳定性和可维护性。&lt;/p&gt;
&lt;h3&gt;四、手把手带大家实现&lt;/h3&gt;
&lt;p&gt;​	首先要明确，生产者消费者模式分为四种，分别是 一对一、一对多、多对一、多对多，对于不同的模式，都有细微的差距，下面一一展开讲解：&lt;/p&gt;
&lt;p&gt;​	在正式开始写代码之前，我们先写一个输出包，以便于后续打印需要的信息。我们在项目根目录下创建一个 &lt;code&gt;out&lt;/code&gt; 目录，然后创建一个 &lt;code&gt;out.go&lt;/code&gt; 文件，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package out

import &quot;fmt&quot;

// Out 输出
type Out struct {
	data chan interface{}
}

// 单例模式
var out *Out

// NewOut 初始化
func NewOut() *Out {
	if out == nil {
		out = &amp;amp;amp;Out{
			data: make(chan interface{}, 65535), // 这里必须设置缓冲区
		}
	}
	return out
}

// Println out 的写入方法
func Println(i interface{}) {
	out.data &amp;amp;lt;- i
}

// OutPut 将 out 内所有数据全部输出
func (o *Out) OutPut() {
	for {
		select {
		case i := &amp;amp;lt;-o.data:
			fmt.Println(i)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;一对一&lt;/h5&gt;
&lt;p&gt;​	首先我们定义一个任务结构体，生产者生成的任务就是一个带有 &lt;code&gt;ID&lt;/code&gt; 的任务，然后消费任务的逻辑就是将该任务的 &lt;code&gt;ID&lt;/code&gt; 打印出来：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Task 任务
type Task struct {
	ID int64
}

// 消费任务
func (t *Task) run() {
	out.Println(t.ID)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	然后定义一个缓冲区，用于存放生产者生产的任务，这里采用 带缓存的&lt;code&gt;channel&lt;/code&gt; 来做缓冲区，并且给生产者需要生产的任务数量赋值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 缓冲池
var taskCh = make(chan Task, 10)

// 生产者需要生产的任务数量
const taskNum int64 = 10000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	接着写我们的生产者逻辑，因为是一对一，所以只有一个生产者，那么在该生产者生产完任务之后就可以将生产者通道关闭。需要注意的是，如果这里没有关闭的话，可能会导致后续消费者误以为还有任务在生产一直等待，导致死锁：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func producer(wo chan&amp;amp;lt;- Task) {
	var i int64
	for i = 1; i &amp;amp;lt;= taskNum; i++ {
		t := Task{
			ID: i,
		}
		wo &amp;amp;lt;- t
	}
	// 单个生产者就可以直接关闭通道了，关闭后，消费者任然可以消费
	close(wo)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	再来看消费者逻辑，消费者的话，直接用 &lt;code&gt;for - range&lt;/code&gt; 的方式阻塞等待生产者生产任务即可，待生产者生产完成之后，会主动关闭通断，消费者消费完成之后，就会结束 &lt;code&gt;for - range&lt;/code&gt; 循环了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func consumer(ro &amp;amp;lt;-chan Task) {
	for t := range ro {
		if t.ID != 0 {
			t.run()
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	最后就是我们的执行函数，由于我们不知道什么时候生产者和消费者完成了自己负责的任务，于是我们通过 &lt;code&gt;sync.WaitGroup&lt;/code&gt; 来作协程通知，以确保生产者任务生产完毕且消费者任务消费完毕：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func Exec() {
	wg := &amp;amp;amp;sync.WaitGroup{}
	wg.Add(2)
	go func(wg *sync.WaitGroup) {
		defer wg.Done()
		producer(taskCh)
	}(wg)
	go func(wg *sync.WaitGroup) {
		defer wg.Done()
		consumer(taskCh)
	}(wg)

	wg.Wait()
	out.Println(&quot;执行成功&quot;)

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	在使用 &lt;code&gt;sync.WaitGroup&lt;/code&gt; 进行函数传参时需要注意，由于 Go 语言的函数传参是值传递，如果只传递的是值的话，在函数内部执行 &lt;code&gt;Done()&lt;/code&gt; 操作是不会影响到函数外的计数器的数量的，所以如果要传参，就需要使用指针进行传递。&lt;/p&gt;
&lt;h6&gt;完整代码&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package one_one

import (
	&quot;main/out&quot;
	&quot;sync&quot;
)

// Task 任务
type Task struct {
	ID int64
}

// 消费任务
func (t *Task) run() {
	out.Println(t.ID)
}

/* 可能存在的问题
1、生产者通道未关闭，消费者未结束，wg.Wait()没有等待，导致死锁
2、wg 传参时，如果是值传递，可能会导致wg.Wait()没有被 Done 为零
*/
// 缓冲池
var taskCh = make(chan Task, 10)

// 生产者需要生产的任务数量
const taskNum int64 = 10000

// 一个生产者
func producer(wo chan&amp;amp;lt;- Task) {
	var i int64
	for i = 1; i &amp;amp;lt;= taskNum; i++ {
		t := Task{
			ID: i,
		}
		wo &amp;amp;lt;- t
	}
	// 单个生产者就可以直接关闭通道了，关闭后，消费者任然可以消费
	close(wo)
}

// 一个消费者
func consumer(ro &amp;amp;lt;-chan Task) {
	for t := range ro {
		if t.ID != 0 {
			t.run()
		}
	}
}

func Exec() {
	wg := &amp;amp;amp;sync.WaitGroup{}
	wg.Add(2)
	go func(wg *sync.WaitGroup) {
		defer wg.Done()
		producer(taskCh)
	}(wg)
	go func(wg *sync.WaitGroup) {
		defer wg.Done()
		consumer(taskCh)
	}(wg)

	wg.Wait()
	out.Println(&quot;执行成功&quot;)

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;一对多&lt;/h5&gt;
&lt;p&gt;​	一对多的话，还是一个生产者去生产任务，但是多个消费者去消费任务，这里我们只需要在 “ 一对一 ” 的基础上修改 &lt;code&gt;Exec()&lt;/code&gt; 函数，开多个消费者进行消费即可，消费逻辑也不需要进行修改。这里需要强调一点，由于 Go 语言中 &lt;code&gt;chennel&lt;/code&gt; 是线程安全的，故这里多个消费者去竞争任务的时候，不会出现线程安全的问题，我们也不需要额外加锁去作兜底。&lt;/p&gt;
&lt;p&gt;​	我们这里就通过任务的增量逐渐来开新的消费者去消费：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func Exec() {
	wg := &amp;amp;amp;sync.WaitGroup{}
	wg.Add(1)
	go func(wg *sync.WaitGroup) {
		defer wg.Done()
		producer(taskCh)
	}(wg)
	var i int64
	for i = 0; i &amp;amp;lt; taskNum; i++ {
		if i%100 == 0 { // 根据任务增量来逐渐开新的消费者去消费
			wg.Add(1)
			go func(wg *sync.WaitGroup) {
				defer wg.Done()
				consumer(taskCh)
			}(wg)
		}
	}
	wg.Wait()
	out.Println(&quot;执行成功&quot;)

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	每 100 个任务，就开一个消费者去消费。这里并不是将 100 个任务分配给指定的消费者，而是多个消费者去缓冲区中竞争任务来处理执行。&lt;/p&gt;
&lt;h6&gt;完整代码&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package one_many

import (
	&quot;main/out&quot;
	&quot;sync&quot;
)

// Task 任务
type Task struct {
	ID int64
}

// 消费任务
func (t *Task) run() {
	out.Println(t.ID)
}

/* 可能存在的问题
1、channel 是线程安全的，多个消费者同时去消费不存在 数据竞争问题
2、wg 传参时，如果是值传递，可能会导致wg.Wait()没有被 Done 为零
*/
// 缓冲池
var taskCh = make(chan Task, 10)

// 生产者需要生产的任务数量
const taskNum int64 = 10000

// 一个生产者
func producer(wo chan&amp;amp;lt;- Task) {
	var i int64
	for i = 1; i &amp;amp;lt;= taskNum; i++ {
		t := Task{
			ID: i,
		}
		wo &amp;amp;lt;- t
	}
	// 单个生产者就可以直接关闭通道了，关闭后，消费者任然可以消费
	close(wo)
}

// 一个消费者
func consumer(ro &amp;amp;lt;-chan Task) {
	for t := range ro {
		if t.ID != 0 {
			t.run()
		}
	}
}

func Exec() {
	wg := &amp;amp;amp;sync.WaitGroup{}
	wg.Add(1)
	go func(wg *sync.WaitGroup) {
		defer wg.Done()
		producer(taskCh)
	}(wg)
	var i int64
	for i = 0; i &amp;amp;lt; taskNum; i++ {
		if i%100 == 0 { // 根据任务增量来逐渐开新的消费者去消费
			wg.Add(1)
			go func(wg *sync.WaitGroup) {
				defer wg.Done()
				consumer(taskCh)
			}(wg)
		}
	}
	wg.Wait()
	out.Println(&quot;执行成功&quot;)

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;多对一&lt;/h5&gt;
&lt;p&gt;​	多对一的话，就是需要多个生产者生产任务，而只有一个消费者去消费任务，所以这里的消费者逻辑不需要进行更改。而生产者逻辑，我们这里规定每个生产者需要生产的任务数量 &lt;code&gt;nums&lt;/code&gt;，然后生产者逻辑就是：从当前任务编号开始生产，生产 &lt;code&gt;nums&lt;/code&gt; 个，然后就可以停止生产了，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 多个生产者
func producer(wo chan&amp;amp;lt;- Task, startNum int64, nums int64) {
	var i int64
	for i = startNum; i &amp;amp;lt; startNum+nums; i++ {
		t := Task{
			ID: i,
		}
		wo &amp;amp;lt;- t
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	同样，&lt;code&gt;Exec()&lt;/code&gt;执行逻辑中，我们去做一个多对一的生产者消费者逻辑。我们限制每个生产者生产 nums 个任务，即每 nums 个任务开一个新的生产者去生产。同时为了保证生产者任务生产完毕，我们使用 &lt;code&gt;pwg.Add(1)&lt;/code&gt; 在生产任务前将计数器 ++，在生产任务结束后，用&lt;code&gt;pwg.Done()&lt;/code&gt; 将计数器 --。&lt;/p&gt;
&lt;p&gt;​	还是一样的，为了保证生产者和消费者都完成了任务，我们使用 &lt;code&gt;wg.Add(1)&lt;/code&gt; 在生产者和消费者在工作前将计数器 ++，在生产者和消费者完成工作后将计数器 --。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func Exec() {
	// 保证生产者任务生产完毕
	wg := &amp;amp;amp;sync.WaitGroup{}
	// 保证生产者任务生产完毕后，将 channel 关闭
	pwg := &amp;amp;amp;sync.WaitGroup{}
	var i int64
	wg.Add(1)
	for i = 0; i &amp;amp;lt; taskNum; i += nums {
		if i &amp;amp;gt;= taskNum {
			break
		}
		// 每个生产者生产 100 个任务
		wg.Add(1)
		pwg.Add(1)
		// 问题2：参数传递
		go func(i int64) {
			defer wg.Done()
			defer pwg.Done()
			producer(taskCh, i, nums)
		}(i)
	}

	go func() {
		defer wg.Done()
		consumer(taskCh)
	}()
	pwg.Wait()
	// 这里需要注意，问题 1
	go close(taskCh)
	wg.Wait()

	out.Println(&quot;执行成功&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这里需要注意的两个问题：一个是，在 &lt;code&gt;for&lt;/code&gt; 循环中的变量 &lt;code&gt;i&lt;/code&gt; 可能会存在内存共享的问题，因为在可能在本次循环中 &lt;code&gt;i&lt;/code&gt; 的值为 &lt;code&gt;199&lt;/code&gt;，但是在协程开始执行后，传入 &lt;code&gt;producer()&lt;/code&gt; 函数的 &lt;code&gt;i&lt;/code&gt; 的值就变成了 &lt;code&gt;200&lt;/code&gt;，所以这里需要用参数将 &lt;code&gt;i&lt;/code&gt; 的值传到对应的协程中。另一个问题是，在关闭通道 &lt;code&gt;close(taskch)&lt;/code&gt; 的时候，这里可能会存在一个极小的时间差，可能会存在还有协程在往通道里面写数据，所以这里用 &lt;code&gt;go(close)&lt;/code&gt; 会保险一点。&lt;/p&gt;
&lt;h6&gt;完整代码&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package many_one

import (
	&quot;main/out&quot;
	&quot;sync&quot;
)

// Task 任务
type Task struct {
	ID int64
}

// 消费任务
func (t *Task) run() {
	out.Println(t.ID)
}

/* 可能存在的问题
1、go close 去关闭channel，因为可能还有协程在向里面写数据，有极小的时间差
2、生产者在生产的时候，可能存在数据竞争问题
*/
// 缓冲池
var taskCh = make(chan Task, 10)

// 生产者需要生产的任务数量
const taskNum int64 = 10000

// 每个生产者生产的任务数量，100
const nums int64 = 100

// 多个生产者
func producer(wo chan&amp;amp;lt;- Task, startNum int64, nums int64) {
	var i int64
	for i = startNum; i &amp;amp;lt; startNum+nums; i++ {
		t := Task{
			ID: i,
		}
		wo &amp;amp;lt;- t
	}
}

// 一个消费者
func consumer(ro &amp;amp;lt;-chan Task) {
	for t := range ro {
		if t.ID != 0 {
			t.run()
		}
	}
}

func Exec() {
	// 保证生产者任务生产完毕
	wg := &amp;amp;amp;sync.WaitGroup{}
	// 保证生产者任务生产完毕后，将 channel 关闭
	pwg := &amp;amp;amp;sync.WaitGroup{}
	var i int64
	wg.Add(1)
	for i = 0; i &amp;amp;lt; taskNum; i += nums {
		if i &amp;amp;gt;= taskNum {
			break
		}
		// 每个生产者生产 100 个任务
		wg.Add(1)
		pwg.Add(1)
		// 问题2：参数传递
		go func(i int64) {
			defer wg.Done()
			defer pwg.Done()
			producer(taskCh, i, nums)
		}(i)
	}

	go func() {
		defer wg.Done()
		consumer(taskCh)
	}()
	pwg.Wait()
	// 这里需要注意，问题 1
	go close(taskCh)
	wg.Wait()

	out.Println(&quot;执行成功&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;多对多&lt;/h5&gt;
&lt;p&gt;​	多对多的话，就比较接近现实中的场景了。会有源源不断的生产者生产任务，就会有消费者不断地去消费任务，它们都不会主动退出，靠人为信号退出 goroutine。因此，我们需要先定义一个全局停止运行的信号：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 停止运行的信号
var done = make(chan struct{})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	生产者由于是无限生产，那毫无疑问生产者逻辑是写在一个 &lt;code&gt;for&lt;/code&gt; 循环内的，这里为了避免缓冲区满了，生产者因为阻塞而导致无法接收到 &lt;code&gt;done&lt;/code&gt; 信号，我们配合 &lt;code&gt;select&lt;/code&gt; 来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func producer(wo chan&amp;amp;lt;- Task, done chan struct{}) {
	var i int64
	for {
		if i &amp;amp;gt;= TaskNum { // 无限生产
			i = 0
		}
		i++
		t := Task{
			ID: i,
		}
		// 可以防止因为生产者阻塞，而导致关闭信号无法关闭
		select {
		case wo &amp;amp;lt;- t:
		case &amp;amp;lt;-done:
			out.Println(&quot;生产者退出&quot;)
			return
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	同样，我们的消费者逻辑肯定也是放在 &lt;code&gt;for&lt;/code&gt; 循环中来写，并且也配合 &lt;code&gt;select&lt;/code&gt; 来接收信号：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func consumer(ro &amp;amp;lt;-chan Task, done chan struct{}) {
	for {
		select {
		case t := &amp;amp;lt;-ro:
			if t.ID != 0 {
				t.run()
			}
		case &amp;amp;lt;-done: // 这里如果直接退出的话，可能 channel 里面还有值没有被消费（有缓存区的情况）
			for t := range ro { // 生产者那边已经停止，消息不会再生产。消费者这里将所有消息消费后，就可以 退出了
				if t.ID != 0 {
					t.run()
				}
			}
			out.Println(&quot;消费者退出&quot;)
			return
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	在接收到 &lt;code&gt;done&lt;/code&gt; 信号后，这里有一个小坑：可能此时缓冲区中还存在任务没有被消费。故我们应该在退出运行前，再消费执行一次消费逻辑，保证缓冲区中没有任务剩余。&lt;/p&gt;
&lt;p&gt;​	执行函数的逻辑就很简单了，直接异步开多个生产者和消费者同时运行即可。这里也需要注意先关闭信号，再关闭通道，如果反过来了，就可能会导致向已关闭的 &lt;code&gt;channel&lt;/code&gt; 内写入数据，会报异常。&lt;/p&gt;
&lt;h6&gt;完整代码&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package many_many

import (
	&quot;main/out&quot;
	&quot;time&quot;
)

// Task 任务
type Task struct {
	ID int64
}

// 消费任务
func (t *Task) run() {
	out.Println(t.ID)
}

/* 可能存在的问题
1、生产者 和 消费者 都不主动退出，靠信号退出 goroutine
2、源源不断地生产，消费者也不间断。
*/

// 缓冲池
var taskCh = make(chan Task, 10)

// 停止运行的信号
var done = make(chan struct{})

// TaskNum 生产者需要生产的任务数量
const TaskNum int64 = 10000

func producer(wo chan&amp;amp;lt;- Task, done chan struct{}) {
	var i int64
	for {
		if i &amp;amp;gt;= TaskNum { // 无限生产
			i = 0
		}
		i++
		t := Task{
			ID: i,
		}
		// 可以防止因为生产者阻塞，而导致关闭信号无法关闭
		select {
		case wo &amp;amp;lt;- t:
		case &amp;amp;lt;-done:
			out.Println(&quot;生产者退出&quot;)
			return
		}
	}
}

func consumer(ro &amp;amp;lt;-chan Task, done chan struct{}) {
	for {
		select {
		case t := &amp;amp;lt;-ro:
			if t.ID != 0 {
				t.run()
			}
		case &amp;amp;lt;-done: // 这里如果直接退出的话，可能 channel 里面还有值没有被消费（有缓存区的情况）
			for t := range ro { // 生产者那边已经停止，消息不会再生产。消费者这里将所有消息消费后，就可以 退出了
				if t.ID != 0 {
					t.run()
				}
			}
			out.Println(&quot;消费者退出&quot;)
			return
		}
	}
}

func Exec() {
	// 多个生产者
	go producer(taskCh, done)
	go producer(taskCh, done)
	go producer(taskCh, done)
	go producer(taskCh, done)
	go producer(taskCh, done)
	go producer(taskCh, done)
	go producer(taskCh, done)
	go producer(taskCh, done)

	// 多个消费者
	go consumer(taskCh, done)
	go consumer(taskCh, done)
	go consumer(taskCh, done)
	go consumer(taskCh, done)
	go consumer(taskCh, done)
	go consumer(taskCh, done)
	go consumer(taskCh, done)

	time.Sleep(time.Second * 5)
	// 一定要先关闭 done，再关闭通道。防止向已关闭的 channel 写入数据，报异常
	close(done)
	close(taskCh)
	out.Println(&quot;执行成功&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;五、总结&lt;/h3&gt;
&lt;p&gt;​	生产者消费者模式的核心思想是通过&lt;strong&gt;共享缓冲区实现生产者和消费者之间的解耦&lt;/strong&gt;，使得生产者生成数据并放入缓冲区，而消费者从缓冲区获取数据进行处理。&lt;/p&gt;
&lt;p&gt;​	关键的实现要点包括同步机制，阻塞和唤醒机制，以及解耦生产者和消费者的直接依赖关系。这种模式通过平衡数据生成和处理的速度，提高了系统的灵活性和效率，适用于多线程环境下的异步数据交换。&lt;/p&gt;
</description><link>https://studygolang.com/topics/17010</link><guid isPermaLink="false">https://studygolang.com/topics/17010</guid><pubDate>Thu, 07 Dec 2023 07:12:56 GMT</pubDate><author>oYto</author><category>每日一学</category></item><item><title>[go 面试] 前端请求到后端API的中间件流程解析</title><description>&lt;p&gt;&amp;gt; 关注公众号【爱发白日梦的后端】分享技术干货、读书笔记、开源项目、实战经验、高效开发工具等，您的关注将是我的更新动力！
&amp;gt;&lt;/p&gt;
&lt;p&gt;在前端请求到后端API的典型流程中，经过一系列中间件的处理，确保请求的顺利处理和安全性。以下是中间件的详细解析：&lt;/p&gt;
&lt;h2&gt;1. &lt;strong&gt;前端请求&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;用户在前端发起请求，包括请求的URL、参数、以及其他必要的信息。&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;网关（Ingress/Nginx）&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;请求首先经过网关层，可能是Ingress或Nginx。网关的主要功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;负载均衡：&lt;/strong&gt; 将请求分发到多个后端服务，实现负载均衡，提高系统的性能和可用性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSL终止：&lt;/strong&gt; 在这一层进行SSL/TLS解密，保障数据的安全传输。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求转发：&lt;/strong&gt; 根据请求的路径或其他条件，将请求转发到对应的后端服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3. &lt;strong&gt;路由中间件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;后端服务可能使用路由中间件，根据请求的URL或其他条件，将请求分发给相应的处理器或控制器。这有助于模块化和组织代码。&lt;/p&gt;
&lt;h2&gt;4. &lt;strong&gt;身份验证中间件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在一些需要身份验证的场景中，身份验证中间件被用来验证请求的身份。这可以包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基于令牌的身份验证：&lt;/strong&gt; 用户提供令牌，服务器验证令牌的合法性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OAuth：&lt;/strong&gt; 通过OAuth流程验证用户身份。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JWT：&lt;/strong&gt; 使用JSON Web Tokens进行身份验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;5. &lt;strong&gt;鉴权中间件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;通过身份验证后，鉴权中间件用于验证用户是否有权访问请求的资源。它确保用户拥有执行操作的权限，防止未授权的访问。&lt;/p&gt;
&lt;h2&gt;6. &lt;strong&gt;缓存中间件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在需要缓存的场景中，缓存中间件用于缓存请求的结果，以避免不必要的计算或数据库查询。这提高了系统的响应速度和效率。&lt;/p&gt;
&lt;h2&gt;7. &lt;strong&gt;日志中间件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;日志中间件被用于追踪和记录请求的日志。它记录请求的详细信息，包括路径、参数、响应状态码等。这对于系统的监控、排查问题和性能优化都至关重要。&lt;/p&gt;
&lt;h2&gt;8. &lt;strong&gt;其他自定义中间件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;根据实际需求，还可以添加其他自定义中间件，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;请求计时：&lt;/strong&gt; 统计请求的处理时间，用于性能分析。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求限流：&lt;/strong&gt; 防止过多的请求同时到达，保护系统免受过载的影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常处理：&lt;/strong&gt; 处理请求过程中的异常情况，确保系统的稳定性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综合使用这些中间件，可以构建一个高效、安全、可维护的后端API系统，适应各种复杂的业务需求。&lt;/p&gt;
</description><link>https://studygolang.com/topics/17007</link><guid isPermaLink="false">https://studygolang.com/topics/17007</guid><pubDate>Wed, 06 Dec 2023 15:24:42 GMT</pubDate><author>TimLiuDream</author><category>每日一学</category></item><item><title>手把手教你用Go实现Ping操作</title><description>&lt;p&gt;&amp;gt; 欢迎大家到我的博客浏览 &amp;lt;a href=&quot;&lt;a href=&quot;https://www.yinkai.cc/post/74f3b4b7d2699b0fb647468756e0475d&quot;&gt;https://www.yinkai.cc/post/74f3b4b7d2699b0fb647468756e0475d&lt;/a&gt;&quot;&amp;gt;YinKai &#39;s Blog | 手把手教你用Go实现Ping操作&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;​	这次我们来看一下什么是 Ping 操作，以及它有什么用处，并且我们来动手实现一个简易版的 Ping 工具。&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;h4&gt;Ping 是什么？&lt;/h4&gt;
&lt;p&gt;​	&lt;code&gt;ping&lt;/code&gt; 是一个计算机网络工具，通常用于测试网络连接的可达性和测量往返时间。在大多数操作系统中，&lt;code&gt;ping&lt;/code&gt; 命令是一个内置的命令行工具，可以通过命令行终端使用。例如，在 Windows 操作系统中，你可以在命令提示符中运行 &lt;code&gt;ping&lt;/code&gt; 命令，而在类 Unix 操作系统（如 Linux 和 macOS）中，你可以在终端中使用 &lt;code&gt;ping&lt;/code&gt; 命令。通常，命令的语法是 &lt;code&gt;ping 目标主机或 IP&lt;/code&gt;，然后命令将输出与目标主机的通信状态和 RTT 相关的信息。&lt;/p&gt;
&lt;h4&gt;Ping 有什么用处？&lt;/h4&gt;
&lt;p&gt;​	&lt;code&gt;Ping&lt;/code&gt; 工具主要有以下几个主要用途：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;测试主机的可达性&lt;/strong&gt;：&lt;code&gt;ping&lt;/code&gt; 命令用于检查另一个主机是否可以在网络上访问。它向目标主机发送一个小的数据包（通常是 ICMP Echo Request），如果目标主机正常工作，它将响应一个回复数据包（通常是 ICMP Echo Reply）。如果没有响应，那么目标主机可能无法访问或处于离线状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测量往返时间（RTT）&lt;/strong&gt;：&lt;code&gt;ping&lt;/code&gt; 命令通常会显示每次请求和响应之间的时间差，这被称为往返时间（RTT）。这个值表示了数据从发送端到接收端的往返延迟，通常以毫秒为单位。测量 RTT 对于评估网络性能和延迟非常有用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络故障排除&lt;/strong&gt;：&lt;code&gt;ping&lt;/code&gt; 是网络故障排除的有用工具之一。通过检查 &lt;code&gt;ping&lt;/code&gt; 的输出，网络管理员可以确定网络连接是否正常，以及延迟是否在可接受范围内。如果 &lt;code&gt;ping&lt;/code&gt; 失败，管理员可以进一步调查网络故障的原因。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监测网络稳定性&lt;/strong&gt;：&lt;code&gt;ping&lt;/code&gt; 命令还可以用于监测网络的稳定性。通过连续地向目标主机发送 &lt;code&gt;ping&lt;/code&gt; 请求，可以了解网络连接的质量和稳定性。如果出现不稳定性，管理员可以及时采取措施。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;动手实现一个 Ping 工具&lt;/h4&gt;
&lt;p&gt;​	首先，我们要了解一下 &lt;code&gt;Ping&lt;/code&gt; 操作的工作原理：向网络上的另一个主机系统发送 &lt;code&gt;ICMP&lt;/code&gt; 报文，如果指定系统得到了报文，它将把回复报文传回给发送者。&lt;/p&gt;
&lt;p&gt;​	先来看看 ICMP 报文长什么样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/ICMP%E6%8A%A5%E6%96%87.png&quot; alt=&quot;ICMP报文&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	ICMP 报文由 ICMP 报文头 和 数据包组成，其报文头包含 Type、Code、Checksum、ID、SequenceNum 字段。因此，我们需要先在本地主机上定义 ICMP 请求报文结构体：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type ICMP struct {
	Type        uint8  // 类型
	Code        uint8  // 代码
	CheckSum    uint16 // 校验和
	ID          uint16 // ID
	SequenceNum uint16 // 序号
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	上面只是 ICMP 的报文头，我们在后面还需要为这个报文构建请求数据。需要注意的是，定义的顺序不能乱，因为我们发送数据包是按字节发送的，所以获取对应的字段的时候，也是按照对应字段的位置去获取的，如果顺序乱了，获取到的数据就会出错。&lt;/p&gt;
&lt;p&gt;​	在构建数据之前，我们先设置好命令行参数，以获取对应参数和目标 IP，同时需要定义全局变量，将命令行参数绑定到对应的变量中，方便使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var (
	helpFlag bool
	timeout  int64 // 耗时
	size     int   // 大小
	count    int   // 请求次数
)

func GetCommandArgs() {
	flag.Int64Var(&amp;amp;amp;timeout, &quot;w&quot;, 1000, &quot;请求超时时间&quot;)
	flag.IntVar(&amp;amp;amp;size, &quot;l&quot;, 32, &quot;发送字节数&quot;)
	flag.IntVar(&amp;amp;amp;count, &quot;n&quot;, 4, &quot;请求次数&quot;)
	flag.BoolVar(&amp;amp;amp;helpFlag, &quot;h&quot;, false, &quot;显示帮助信息&quot;)
	flag.Parse()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	在 &lt;code&gt;main&lt;/code&gt; 函数中，启用命令行参数设置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func main() {
	GetCommandArgs()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	在发送报文前，我们需要先建立连接，此时需要先获取目标 IP，这个由命令行参数中获取：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 获取目标 IP
desIP := os.Args[len(os.Args)-1]
// 构建连接
conn, err := net.DialTimeout(&quot;ip:icmp&quot;, desIP, time.Duration(timeout)*time.Millisecond)
if err != nil {
    log.Println(err.Error())
    return
}
defer conn.Close()
// 远程地址
remoteaddr := conn.RemoteAddr()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	连接建立后，我们需要根据参数中的发送次数 &lt;code&gt;count&lt;/code&gt; 去发送对应次数的报文，因此需要用 &lt;code&gt;for&lt;/code&gt; 去做：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;for i := 0; i &amp;amp;lt; count; i ++ {
	...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	通过百度百科可以查到，我们要使用的是 Ping 请求，即回显请求，其对应的 Type 和 Code 如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/ICMPPing%E8%AF%B7%E6%B1%82.png&quot; alt=&quot;ICMPPing请求&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	同样，我们在全局变量中添加对应的值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var (
	typ      uint8 = 8
    code     uint8 = 0
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	做好前面的准备工作，我们就可以开始构建我们的 ICMP 请求报文了。我们这里以发送的第几次作为 ID 和序列号：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;icmp := &amp;amp;amp;ICMP{
        Type:        typ,
        Code:        code,
        CheckSum:    uint16(0),
        ID:          uint16(i),
        SequenceNum: uint16(i),
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	由于 ICMP 是使用二进制进行传输的，所以我们需要将信息用二进制表示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var buffer bytes.Buffer
binary.Write(&amp;amp;amp;buffer, binary.BigEndian, icmp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	然后根据发送数据的大小 &lt;code&gt;size&lt;/code&gt; 构建数据并写在 ICMP 报文后面：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;data := make([]byte, size)
buffer.Write(data)
data = buffer.Bytes()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	现在，就只差一个校验和字段了，计算 ICMP（Internet Control Message Protocol）报文的校验和字段遵循以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将报文分为 16 位的字（两个字节）。&lt;/li&gt;
&lt;li&gt;对所有字进行按位求和（二进制求和），包括数据部分和报文头。如果有剩余字节（奇数个字节），将其附加到最后一个字节。&lt;/li&gt;
&lt;li&gt;将溢出的进位位（如果有）加回到结果中。&lt;/li&gt;
&lt;li&gt;取结果的二进制反码（按位取反）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	代码实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func checkSum(data []byte) uint16 {
	// 第一步：两两拼接并求和
	length := len(data)
	index := 0
	var sum uint32
	for length &amp;amp;gt; 1 {
		// 拼接且求和
		sum += uint32(data[index])&amp;amp;lt;&amp;amp;lt;8 + uint32(data[index+1])
		length -= 2
		index += 2
	}
	// 奇数情况，还剩下一个，直接求和过去
	if length == 1 {
		sum += uint32(data[index])
	}

	// 第二部：高 16 位，低 16 位 相加，直至高 16 位为 0
	hi := sum &amp;amp;gt;&amp;amp;gt; 16
	for hi != 0 {
		sum = hi + uint32(uint16(sum))
		hi = sum &amp;amp;gt;&amp;amp;gt; 16
	}
	// 返回 sum 值 取反
	return uint16(^sum)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	接着再将算出来的校验和放到报文头对应的位置中去，这里需要计算一下位置。假设我们有以下 ICMP 报文：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Type       |      Code       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Checksum (2 bytes)       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Identifier (2 bytes)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Sequence Number (2 bytes) |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Data (variable length) |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	校验和属于报文的第3、4个字节，即 data[2] 和 data[3]。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;data[2] = byte(checkSum &amp;amp;gt;&amp;amp;gt; 8)
data[3] = byte(checkSum)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	最后再设置一下超时时间，就可以将数据 &lt;code&gt;data&lt;/code&gt; 写入连接中了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 设置超时时间
conn.SetDeadline(time.Now().Add(time.Duration(timeout) * time.Millisecond))

// 将 data 写入连接中，
n, err := conn.Write(data)
if err != nil {
    log.Println(err)
    continue
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	发送完成后，再构建缓冲接收响应包，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;buf := make([]byte, 1024)
n, err = conn.Read(buf)
//fmt.Println(data)
if err != nil {
    log.Println(err)
    continue
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	然后我们就可以从响应包中获取我们需要的数据，比如 IP 地址、TTL等：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/icmp%E5%9B%9E%E5%A4%8D%E6%8A%A5%E6%96%87.png&quot; alt=&quot;icmp回复报文&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	根据抓到的 ICMP 响应包，可以知道 IP 头共 20 个字节，源 IP 和 目标 IP 在我们接收的数据包的倒数 8 个字节里，所以我们可以推算出我们访问的 IP 地址，就可以构建我们的打印信息了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;fmt.Printf(&quot;来自 %d.%d.%d.%d 的回复：字节=%d 时间=%d TTL=%d\n&quot;, buf[12], buf[13], buf[14], buf[15], n-28, t, buf[8])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	至此，我们 Ping 工具的核心功能就实现了，还有一些统计信息，就不做具体的讲解了，感兴趣的可以从代码中看具体的实现。&lt;/p&gt;
&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
	&quot;bytes&quot;
	&quot;encoding/binary&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;math&quot;
	&quot;net&quot;
	&quot;os&quot;
	&quot;time&quot;
)

// tcp 报文前20个是报文头，后面的才是 ICMP 的内容。
// ICMP：组建 ICMP 首部（8 字节） + 我们要传输的内容
// ICMP 首部：type、code、校验和、ID、序号，1 1 2 2 2
// 回显应答：type = 0，code = 0
// 回显请求：type = 8, code = 0

var (
	helpFlag bool
	timeout  int64 // 耗时
	size     int   // 大小
	count    int   // 请求次数
	typ      uint8 = 8
	code     uint8 = 0
	SendCnt  int                   // 发送次数
	RecCnt   int                   // 接收次数
	MaxTime  int64 = math.MinInt64 // 最大耗时
	MinTime  int64 = math.MaxInt64 // 最短耗时
	SumTime  int64                 // 总计耗时
)

// ICMP 序号不能乱
type ICMP struct {
	Type        uint8  // 类型
	Code        uint8  // 代码
	CheckSum    uint16 // 校验和
	ID          uint16 // ID
	SequenceNum uint16 // 序号
}

func main() {
	fmt.Println()
	log.SetFlags(log.Llongfile)
	GetCommandArgs()

	// 打印帮助信息
	if helpFlag {
		displayHelp()
		os.Exit(0)
	}

	// 获取目标 IP
	desIP := os.Args[len(os.Args)-1]
	//fmt.Println(desIP)
	// 构建连接
	conn, err := net.DialTimeout(&quot;ip:icmp&quot;, desIP, time.Duration(timeout)*time.Millisecond)
	if err != nil {
		log.Println(err.Error())
		return
	}
	defer conn.Close()
	// 远程地址
	remoteaddr := conn.RemoteAddr()
	fmt.Printf(&quot;正在 Ping %s [%s] 具有 %d 字节的数据:\n&quot;, desIP, remoteaddr, size)
	for i := 0; i &amp;amp;lt; count; i++ {
		// 构建请求
		icmp := &amp;amp;amp;ICMP{
			Type:        typ,
			Code:        code,
			CheckSum:    uint16(0),
			ID:          uint16(i),
			SequenceNum: uint16(i),
		}

		// 将请求转为二进制流
		var buffer bytes.Buffer
		binary.Write(&amp;amp;amp;buffer, binary.BigEndian, icmp)
		// 请求的数据
		data := make([]byte, size)
		// 将请求数据写到 icmp 报文头后
		buffer.Write(data)
		data = buffer.Bytes()
		// ICMP 请求签名（校验和）：相邻两位拼接到一起，拼接成两个字节的数
		checkSum := checkSum(data)
		// 签名赋值到 data 里
		data[2] = byte(checkSum &amp;amp;gt;&amp;amp;gt; 8)
		data[3] = byte(checkSum)
		startTime := time.Now()

		// 设置超时时间
		conn.SetDeadline(time.Now().Add(time.Duration(timeout) * time.Millisecond))

		// 将 data 写入连接中，
		n, err := conn.Write(data)
		if err != nil {
			log.Println(err)
			continue
		}
		// 发送数 ++
		SendCnt++
		// 接收响应
		buf := make([]byte, 1024)
		n, err = conn.Read(buf)
		//fmt.Println(data)
		if err != nil {
			log.Println(err)
			continue
		}
		// 接受数 ++
		RecCnt++
		//fmt.Println(n, err) // data：64，ip首部：20，icmp：8个 = 92 个
		// 打印信息
		t := time.Since(startTime).Milliseconds()
		fmt.Printf(&quot;来自 %d.%d.%d.%d 的回复：字节=%d 时间=%d TTL=%d\n&quot;, buf[12], buf[13], buf[14], buf[15], n-28, t, buf[8])
		MaxTime = Max(MaxTime, t)
		MinTime = Min(MinTime, t)
		SumTime += t
		time.Sleep(time.Second)
	}

	fmt.Printf(&quot;\n%s 的 Ping 统计信息:\n&quot;, remoteaddr)
	fmt.Printf(&quot;    数据包: 已发送 = %d，已接收 = %d，丢失 = %d (%.f%% 丢失)，\n&quot;, SendCnt, RecCnt, count*2-SendCnt-RecCnt, float64(count*2-SendCnt-RecCnt)/float64(count*2)*100)
	fmt.Println(&quot;往返行程的估计时间(以毫秒为单位):&quot;)
	fmt.Printf(&quot;    最短 = %d，最长 = %d，平均 = %d\n&quot;, MinTime, MaxTime, SumTime/int64(count))
}

// 求校验和
func checkSum(data []byte) uint16 {
	// 第一步：两两拼接并求和
	length := len(data)
	index := 0
	var sum uint32
	for length &amp;amp;gt; 1 {
		// 拼接且求和
		sum += uint32(data[index])&amp;amp;lt;&amp;amp;lt;8 + uint32(data[index+1])
		length -= 2
		index += 2
	}
	// 奇数情况，还剩下一个，直接求和过去
	if length == 1 {
		sum += uint32(data[index])
	}

	// 第二部：高 16 位，低 16 位 相加，直至高 16 位为 0
	hi := sum &amp;amp;gt;&amp;amp;gt; 16
	for hi != 0 {
		sum = hi + uint32(uint16(sum))
		hi = sum &amp;amp;gt;&amp;amp;gt; 16
	}
	// 返回 sum 值 取反
	return uint16(^sum)
}

// GetCommandArgs 命令行参数
func GetCommandArgs() {
	flag.Int64Var(&amp;amp;amp;timeout, &quot;w&quot;, 1000, &quot;请求超时时间&quot;)
	flag.IntVar(&amp;amp;amp;size, &quot;l&quot;, 32, &quot;发送字节数&quot;)
	flag.IntVar(&amp;amp;amp;count, &quot;n&quot;, 4, &quot;请求次数&quot;)
	flag.BoolVar(&amp;amp;amp;helpFlag, &quot;h&quot;, false, &quot;显示帮助信息&quot;)
	flag.Parse()
}

func Max(a, b int64) int64 {
	if a &amp;amp;gt; b {
		return a
	}
	return b
}

func Min(a, b int64) int64 {
	if a &amp;amp;lt; b {
		return a
	}
	return b
}

func displayHelp() {
	fmt.Println(`选项：
	-n count       要发送的回显请求数。
	-l size        发送缓冲区大小。
	-w timeout     等待每次回复的超时时间(毫秒)。
	-h 	       帮助选项`)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;小结&lt;/h4&gt;
&lt;p&gt;​	本文讲解了常用工具 Ping，并且从 ICMP 报文角度手把手教大家实现了一个简易版的 Ping 工具，在这个过程中大家可以收获到很多东西，希望大家能够自己动手实现一下，结果一定不会让你失望。&lt;/p&gt;
</description><link>https://studygolang.com/topics/17000</link><guid isPermaLink="false">https://studygolang.com/topics/17000</guid><pubDate>Wed, 06 Dec 2023 02:47:23 GMT</pubDate><author>oYtoLIGUANGYAO</author><category>每日一学</category></item><item><title>[go 面试] 优化线上故障排查与性能问题的方法</title><description>&lt;p&gt;&amp;gt; 关注公众号【爱发白日梦的后端】分享技术干货、读书笔记、开源项目、实战经验、高效开发工具等，您的关注将是我的更新动力！&lt;/p&gt;
&lt;p&gt;在面对线上故障和性能问题时，迅速而准确的排查是至关重要的。以下是一些优化排查的方法，帮助你更有效地解决短时间内产生大量time wait请求的问题。&lt;/p&gt;
&lt;h2&gt;1. 监控和日志分析&lt;/h2&gt;
&lt;p&gt;通过监控系统实时监控应用的指标，特别关注与网络通信和连接有关的指标。检查日志以找到与time wait请求相关的信息，可能有网络异常或连接超时的记录。&lt;/p&gt;
&lt;h2&gt;2. 网络问题诊断&lt;/h2&gt;
&lt;p&gt;使用网络诊断工具（如ping、traceroute）检查与第三方服务通信的网络是否正常。查看连接是否有丢包或延迟异常，这可能是time wait增多的原因之一。&lt;/p&gt;
&lt;h2&gt;3. 第三方服务调用分析&lt;/h2&gt;
&lt;p&gt;如果应用依赖第三方服务，查看与这些服务的通信是否正常。过度频繁的time wait可能是因为与某个服务的连接频繁断开导致的，可以通过增加连接池大小或优化连接复用来缓解这个问题。&lt;/p&gt;
&lt;h2&gt;4. 锁竞争问题&lt;/h2&gt;
&lt;p&gt;使用性能分析工具（如pprof）来检查应用的锁竞争情况。过多的锁竞争可能导致连接被阻塞，引起time wait增多。考虑优化代码，减少锁的争用。&lt;/p&gt;
&lt;h2&gt;5. 系统资源分析&lt;/h2&gt;
&lt;p&gt;使用系统监控工具检查系统资源的使用情况，确保CPU、内存、磁盘等资源没有达到极限。系统资源不足可能导致连接无法及时处理，进而产生time wait。&lt;/p&gt;
&lt;h2&gt;6. 分布式跟踪&lt;/h2&gt;
&lt;p&gt;在分布式系统中使用分布式跟踪工具（如Jaeger）来追踪请求的调用链，找出潜在的故障点。有可能某个服务的故障引发了time wait的激增。&lt;/p&gt;
&lt;h2&gt;7. 容错设计与优化&lt;/h2&gt;
&lt;p&gt;引入容错机制，如重试、熔断、限流，可以减轻网络或服务异常对系统的影响。同时，考虑优化代码和算法，减少不必要的计算和资源消耗。
以上方法综合使用，可以更全面地排查短时间内产生大量time wait请求的原因。记得在修改任何配置或代码之前，先做好备份，并谨慎进行调整。希望这些方法对解决你的问题有所帮助。如果有其他具体信息，可以提供更详细的指导。&lt;/p&gt;
</description><link>https://studygolang.com/topics/16995</link><guid isPermaLink="false">https://studygolang.com/topics/16995</guid><pubDate>Tue, 05 Dec 2023 07:20:25 GMT</pubDate><author>TimLiuDream</author><category>每日一学</category></item><item><title>手把手教你用Go语言实现缓存系统</title><description>&lt;p&gt;&amp;gt; 欢迎大家到我的博客浏览 &amp;lt;a href=&quot;&lt;a href=&quot;https://www.yinkai.cc/post/a78e65ab014d188b51f57487f4e5c45c&quot;&gt;https://www.yinkai.cc/post/a78e65ab014d188b51f57487f4e5c45c&lt;/a&gt;&quot;&amp;gt;YinKai &#39;s Blog | 手把手教你用Go语言实现缓存系统&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;​	今天我们围绕一个面试题来实现一个内存缓存系统，大家也可以在完成后，自己增加一些额外的功能。&amp;lt;!--more--&amp;gt;&lt;/p&gt;
&lt;h1&gt;面试题内容&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;支持设置过期时间，精度到秒&lt;/li&gt;
&lt;li&gt;支持设置最大内存，当内存超出时做出合理的处理&lt;/li&gt;
&lt;li&gt;支持并发安全&lt;/li&gt;
&lt;li&gt;按照以下接口要求实现&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type Cache interface {
	// SetMaxMemory size : 1KB 100KB 1MB 2MB 1GB
	SetMaxMemory(size string) bool
	// Set 将 value 写入缓存
	Set(key string, val interface{}, expire time.Duration) bool
	// Get 根据 key 值获取 value
	Get(key string) (interface{}, bool)
	// Del 删除 key 值
	Del(key string) bool
	// Exists 判断 key 是否存在
	Exists(key string) bool
	// Flush 清空所有 key
	Flush() bool
	// Keys 获取缓存中所有 key 的数量
	Keys() int64
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;使用示例&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;cache := NewMemCache()
cache.SetMaxMemory(&quot;100MB&quot;)
cache.Set(&quot;int&quot;, 1)
cache.Set(&quot;bool&quot;, false)
cache.Set(&quot;data&quot;, map[string]interface{}{&quot;a&quot;: 1})
cache.Get(&quot;int&quot;)
cache.Del(&quot;int&quot;)
cache.Flush()
cache.Keys()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;​	题目乍一看没有什么难点，就依据题目实现对应的接口以及对应的方法就行了。但其实有一个坑，那就是接口中的 &lt;code&gt;Set&lt;/code&gt; 方法参数和使用示例中的对不上，使用示例中没有传入过期时间。难道是题目出错了？&lt;/p&gt;
&lt;p&gt;​	显然不是的，这里是需要我们去做一个代理层，去实现一个可选参数的 &lt;code&gt;Set&lt;/code&gt; 方法。我们可以在实现了带过期时间参数的方法后，再去封装一层，然后设置成可选参数即可。&lt;/p&gt;
&lt;p&gt;​	这样子，题目的要求，就差不多没什么问题了。但这是面试题，我们想要面试官对我们的评价更好，就要做到更多的内容，寻找一些加分项，比如我们可以增加一个功能，定期删除过期缓存键，又或者我们可以写一些单元测试，让面试官知道我们有写单元测试的好习惯，这些都是一些加分项，能让我们更加地突出。&lt;/p&gt;
&lt;h1&gt;动手写代码&lt;/h1&gt;
&lt;p&gt;​	下面就带着大家一步一步来完成这个缓存系统，当然只是一个具有基础的功能缓存系统，大家在后续也可以自行在其中丰富更多的功能。&lt;/p&gt;
&lt;h4&gt;构建大体框架&lt;/h4&gt;
&lt;p&gt;​	首先，我们可以先在项目根目录下创建一个 cache 包，然后在 cache 包里创建一个 cache.go 文件，然后将题目中要求实现的接口放在里面：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// cache/cache.go
type Cache interface {
	// SetMaxMemory size : 1KB 100KB 1MB 2MB 1GB
	SetMaxMemory(size string) bool
	// Set 将 value 写入缓存
	Set(key string, val interface{}, expire time.Duration) bool
	// Get 根据 key 值获取 value
	Get(key string) (interface{}, bool)
	// Del 删除 key 值
	Del(key string) bool
	// Exists 判断 key 是否存在
	Exists(key string) bool
	// Flush 清空所有 key
	Flush() bool
	// Keys 获取缓存中所有 key 的数量
	Keys() int64
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	接着我们再在 cache 包下创建一个 memCache.go 文件，并在该文件中创建一个 memCache 结构体，去实现题目中要求的 Cache 接口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type memCache struct {
}

func (mc *memCache) SetMaxMemory(size string) bool {
	return false
}

// Set 将 value 写入缓存
func (mc *memCache) Set(key string, val interface{}, expire time.Duration) bool {
	return false
}

// Get 根据 key 值获取 value
func (mc *memCache) Get(key string) (interface{}, bool) {
	return nil, false
}

// Del 删除 key 值
func (mc *memCache) Del(key string) bool {
	return true
}

// Exists 判断 key 是否存在
func (mc *memCache) Exists(key string) bool {
	return true
}

// Flush 清空所有 key
func (mc *memCache) Flush() bool {
	return true
}

// Keys 获取缓存中所有 key 的数量
func (mc *memCache) Keys() int64 {
	return 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	可以看到使用样例中有一个 NewMemCache 函数，于是我们还需要在 memCache.go 文件中添加一个 NewMemCache() 函数，返回一个实例，供 main 函数调用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// cache/memCache.go
func NewMemCache() Cache {
	return &amp;amp;amp;memCache{}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	接着，我们就可以先去主函数 main 中用使用示例跑一下，看看有没有什么问题。在项目根目录下创建一个 main 函数，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// main.go
package main

import cache2 &quot;main/cache&quot;

func main() {
	cache := cache2.NewMemCache()
	cache.SetMaxMemory(&quot;100MB&quot;)
	cache.Set(&quot;int&quot;, 1)
	cache.Set(&quot;bool&quot;, false)
	cache.Set(&quot;data&quot;, map[string]interface{}{&quot;a&quot;: 1})
	cache.Get(&quot;int&quot;)
	cache.Del(&quot;int&quot;)
	cache.Flush()
	cache.Keys()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/memCache_main_error.png&quot; alt=&quot;memCache_main_error&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	然后你就会发现报错了，这个问题就是我们上面说的那个坑，这里需要做一个代理层，但为了方便我们可以先修改使用样例，使他能够先跑通，最后再来做一个代理就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// main.go
cache.Set(&quot;int&quot;, 1, 3)
cache.Set(&quot;bool&quot;, false, 1)
cache.Set(&quot;data&quot;, map[string]interface{}{&quot;a&quot;: 1}, 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	为了看出效果，我们可以在所有的方法中都打印一个信息，比如 Set 方法中打印 `fmt.Println(&quot;我是 Set 方法&quot;)。&lt;/p&gt;
&lt;p&gt;​	最后如果所有的方法都打印出了对应的信息，就说明这个大体框架我们已经搭建好了，下面再去慢慢实现各个方法就可以了。&lt;/p&gt;
&lt;h4&gt;逐个实现方法&lt;/h4&gt;
&lt;p&gt;​	下面就带着大家逐个实现每个具体的方法：&lt;/p&gt;
&lt;h5&gt;SetMaxMemory&lt;/h5&gt;
&lt;p&gt;​	这个方法是用于设置我们缓存系统的最大缓存大小的，因此我们的 memCache 结构体中，就至少应该需要两个字段：最大内存大小 和当前内存大小，因为我们肯定需要去判断当前内存是否超过了最大内存大小，为了方便，我们再增加一个 最大内存大小字段的字符串表示，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// cache/memCache.go
type memCache struct {
	// 最大内存大小
	maxMemorySize int64
	// 最大内存字符串表示
	maxMemorySizeStr string
	// 当前内存大小
	currMemorySize int64
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	然后再来看我们的题目要求，&lt;code&gt;SetMaxMemory size : 1KB 100KB 1MB 2MB 1GB&lt;/code&gt; 要求支持多种单位的表示，所以这里我们肯定需要对输入的内存大小做一个转换，因此我们需要去实现一个 parseSize 函数去解析用户的输入。&lt;/p&gt;
&lt;p&gt;​	我们在 cache 包下，创建一个 util.go 文件，用于存放一些通用功能和工具函数。&lt;/p&gt;
&lt;p&gt;​	parseSize 函数的实现思路是：将用户输入的字符串中的数字部分和单位部分分别提取出来，再进行校验和单位转换等的处理。&lt;/p&gt;
&lt;p&gt;​	利用正则表达式先将用户的输入中的数字部分提取出来，然后再将用户输入的字符串中的数字部分用空格替换，这样剩下的部分就是单位了。&lt;/p&gt;
&lt;p&gt;​	同样的，将用户输入字符串中的单位部分用空格替换，得到的就是数字部分了。&lt;/p&gt;
&lt;p&gt;​	接下来，就是对用户的单位做一个转换，这里我们利用 Go 语言中的预定义标识符，采用小技巧来做一个单位的转换，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// cache/util.go
const (
	B = 1 &amp;amp;lt;&amp;amp;lt; (iota * 10) // 1
	KB 					 // 2024
	MB  				 // 1048576
	GB  				 // 1073741824
	TB 					 // ...
	PB 					 // ...
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	有了不同的单位，我们就可以对解析出来的单位进行处理了，我们这里统一将所有的单位转换成字节，也就是 B：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// cache/util.go
var byteNum int64 = 0
// 1KB 100KB 1MB 2MB 1GB，单位统一为 byte
switch unit {
case &quot;B&quot;:
    byteNum = num
case &quot;KB&quot;:
    byteNum = num * KB
case &quot;MB&quot;:
    byteNum = num * MB
case &quot;GB&quot;:
    byteNum = num * GB
case &quot;TB&quot;:
    byteNum = num * TB
case &quot;PB&quot;:
    byteNum = num * PB
default: // 设置不合法，设置为 0，后续设置为 默认值
    num = 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	如果用户输入的单位不合法，就是通过后续处理设置为默认值 100MB：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// cache/util.go
// 用户使用不合法，打印日志并设置默认值
if num == 0 {
    log.Println(&quot;ParseSize 仅支持 B、KB、MB、GB、TB、PB&quot;)
    num = 100
    byteNum = num * MB
    unit = &quot;MB&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	最后由于我们需要返回的有两种形式，即字符串形式和数字形式，所以这里还需要拼接一下字符串形式。这里没有直接使用用户传入的值，是因为可能用户的输入有问题，然后我们采用的是默认值，故这里直接统一全部重新拼接：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// cache/util.go
sizeStr := strconv.FormatInt(num, 10) + unit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	至此，ParseSize 函数，我们就实现完毕了，完整代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func ParseSize(size string) (int64, string) {
	// 默认大小为 100

	// 利用正则表达式匹配一个或者多个数字
	re, _ := regexp.Compile(&quot;[0-9]+&quot;)
	// 获取单位：使用编译好的正则表达式 re，将 size 字符串中匹配的数字字符替换为空字符串
	unit := string(re.ReplaceAll([]byte(size), []byte(&quot;&quot;)))

	// 获取数字：将 size 字符串中的单位部分 unit 用空字符串替换，即可获取数字部分。最后再将数字转换为 int64 类型
	num, _ := strconv.ParseInt(strings.Replace(size, unit, &quot;&quot;, 1), 10, 64)

	// 单位转换为大写
	unit = strings.ToUpper(unit)
    
	var byteNum int64 = 0
	// 1KB 100KB 1MB 2MB 1GB，单位统一为 byte
	switch unit {
	case &quot;B&quot;:
		byteNum = num
	case &quot;KB&quot;:
		byteNum = num * KB
	case &quot;MB&quot;:
		byteNum = num * MB
	case &quot;GB&quot;:
		byteNum = num * GB
	case &quot;TB&quot;:
		byteNum = num * TB
	case &quot;PB&quot;:
		byteNum = num * PB
	default: // 设置不合法，设置为 0，后续设置为 默认值
		num = 0
	}

	// 用户使用不合法，打印日志并设置默认值
	if num == 0 {
		log.Println(&quot;ParseSize 仅支持 B、KB、MB、GB、TB、PB&quot;)
		num = 100
		byteNum = num * MB
		unit = &quot;MB&quot;
	}

	sizeStr := strconv.FormatInt(num, 10) + unit
	return byteNum, sizeStr
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	然后我们的 SetMaxMemory 函数就简单了，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// cache/memCache.go
func (mc *memCache) SetMaxMemory(size string) bool {
	mc.maxMemorySize, mc.maxMemorySizeStr = ParseSize(size)
	fmt.Println(mc.maxMemorySize, mc.maxMemorySizeStr)
	return true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	然后我们可以运行 main.go 函数，打印一下检查是否有问题：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;$ go run main.go
104857600 100MB
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	可以用计算器算一下，没有问题，我们的 SetMaxMemory 函数就完成了。&lt;/p&gt;
&lt;h5&gt;Set&lt;/h5&gt;
&lt;p&gt;​	然后是我们的 Set 方法，这个方法是用来将键值对存入我们的缓存系统中的。&lt;/p&gt;
&lt;p&gt;​	首先，我们需要考虑用什么类型来存储键值对，很自然就可以想到用 Go 语言内置的字典，即 map 来实现。那新的问题又来了，那 map 的 key-value 分别用什么类型呢？key 的类型，毫无疑问肯定是 string 类型；value 的类型的话，这里如果也用一个单独的 interface{} 类型的话，可能也会存在一些问题，因为我们的 value 需要携带很多附加信息，比如 value 的值、过期时间、value 大小等，故这里的 value 需要用一个结构体去表示，故我们要先创建一个 memCacheValue 结构体：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// cahce.memCache.go
type memCacheValue struct {
	// value 值
	val interface{}
	// 过期时间
	expireTime time.Time
	// 有效时长
	expire time.Duration
	// value 大小。用于计算当前内存大小
	size int64
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	有了 memCacheValue，就可以在 memCache 中新增一个字段了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// cahce.memCache.go
type memCache struct {
	// 最大内存大小
	maxMemorySize int64
	// 最大内存字符串表示
	maxMemorySizeStr string
	// 当前内存大小
	currMemorySize int64
	// 缓存键值对
	values map[string]*memCacheValue
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	由于这里使用了 map，故在初始化 memCache 实例的时候，需要进行内存的分配，所以我们要修改 NewMemCache 函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// cahce.memCache.go
func NewMemCache() Cache {
	mc := &amp;amp;amp;memCache{
		values: make(map[string]*memCacheValue),
	}
	return mc
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	言归正传，继续分析我们的 Set 方法的实现，由于 Set 方法是写操作，Map 并非线程安全的，所以我们在进行写操作的时候需要进行加锁保护，故这里 memCache 结构中还需要加一个锁：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type memCache struct {
	...
	// 读写锁
	locker sync.RWMutex
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这里我们采用读写锁，这样可以利用 map 的读写机制：读操作兼容、写操作互斥，最大化提升读写 map 的性能。&lt;/p&gt;
&lt;p&gt;​	因为我们的键可能存在过期时间，如果是重复 Set 一个已存在的值，就需要去重新计算更新对应的时间，会需要分情况讨论，比较复杂。所以，这里我们统一使用，先删除对应键值，再添加对应键值，写起来会比较方便，下面我们实现三个方法，以便我们调用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 判断是否存在对应的 value
func (mc *memCache) get(key string) (*memCacheValue, bool) {
	val, ok := mc.values[key]
	return val, ok
}

// 删除：当前内存大小更新、删除当前 key 值
func (mc *memCache) del(key string) {
	tmp, ok := mc.get(key)
	if ok &amp;amp;amp;&amp;amp;amp; tmp != nil {
		mc.currMemorySize -= tmp.size
		delete(mc.values, key)
	}
}

// 添加：当前内存大小更新、删除当前 key 值
func (mc *memCache) add(key string, val *memCacheValue) {
	mc.values[key] = val
	mc.currMemorySize += val.size
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	上述三个方法比较简单，就不做过多赘述了。有了这三个函数，我们后面其他的方法实现起来，都会很简单。&lt;/p&gt;
&lt;p&gt;​	然后我们的 Set 方法就可以写了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (mc *memCache) Set(key string, val interface{}, expire time.Duration) bool {
	// map 非线程安全需要加锁访问
	mc.locker.Lock()
	defer mc.locker.Unlock()
	// 确定一个 value 值
	v := &amp;amp;amp;memCacheValue{
		val:        val,
		expireTime: time.Now().Add(expire),
		expire:     expire,
		size:       GetValSize(val),
	}
	// 为了简化代码复杂度，这里用 “删除再添加” 来代替 “更新” 操作
	if _, ok := mc.get(key); ok { // 存在则删除
		mc.del(key)
	}
	mc.add(key, v)

	// 新增后缓存是否超过最大内存：超过则直接删除刚刚添加的这个 key，并报 panic
	if mc.currMemorySize &amp;amp;gt; mc.maxMemorySize {
		mc.del(key)
		// 这里可以自己完善一下，通过一些内存淘汰策略来选择删除一些 key，来判断是否还会超过最大内存
		log.Println(fmt.Sprintf(&quot;max memory size %s&quot;, mc.maxMemorySizeStr))
	}
	return false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;在开始操作之前，加写锁保护&lt;/li&gt;
&lt;li&gt;根据用户输入，构建对应的 value 值&lt;/li&gt;
&lt;li&gt;如果存在对应键值对，就先删除，然后再添加对应键值&lt;/li&gt;
&lt;li&gt;新增后判断是否超过内存，超过了的话，就直接删除刚刚添加的这个键&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	上述 Set 方法中还用到一个函数 GetValSize ，我们可以先不去实现这个函数具体逻辑，后面再回过头来看：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// cache/util.go
// GetValSize 计算 value 值大小
func GetValSize(val interface{}) int64 {
	return 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;Get&lt;/h5&gt;
&lt;p&gt;​	Get 方法，是根据用户输入的键，来获取对应的 value 值的。实现很简单，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (mc *memCache) Get(key string) (interface{}, bool) {
	mc.locker.RLock()
	defer mc.locker.RUnlock()

	// 拿到对应的值
	mcv, ok := mc.get(key)
	// 判断是否过期
	if ok {
		if mcv.expire != 0 &amp;amp;amp;&amp;amp;amp; mcv.expireTime.Before(time.Now()) { // 过期时间早于当前时间，删除
			mc.del(key)
			return nil, false
		}
		return mcv.val, ok
	}
	return nil, false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;加读锁保护&lt;/li&gt;
&lt;li&gt;先通过 get 方法拿到对应的值&lt;/li&gt;
&lt;li&gt;如果存在该键，且该值没有过期或者没有过期时间，则返回该值&lt;/li&gt;
&lt;li&gt;否则返回 nil，并删除该过期键&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;Del&lt;/h5&gt;
&lt;p&gt;​	Del 方法，是用于删除对应键值对的。直接加写锁操作，并调用先前实现的 del 函数即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (mc *memCache) Del(key string) bool {
	mc.locker.Lock()
	defer mc.locker.Unlock()
	mc.del(key)
	return true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;加写锁保护&lt;/li&gt;
&lt;li&gt;直接调用 del 函数进行删除对应键值对即可&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;Exists&lt;/h5&gt;
&lt;p&gt;​	Exists 方法，用于判断某个键是否存在于我们的缓存系统。实现也非常简单：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (mc *memCache) Exists(key string) bool {
	mc.locker.RLock()
	defer mc.locker.RUnlock()
	_, ok := mc.values[key]
	return ok
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;加读锁保护&lt;/li&gt;
&lt;li&gt;直接获取对应键值对，以此判断是否存在该键&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;Flush&lt;/h5&gt;
&lt;p&gt;​	Flush 方法，是在整个缓存系统的缓存数据不需要使用之后，用来清空所有的缓存时使用的。这里我们利用 Go 语言的垃圾回收机制，直接将整个 map 置空，Go 语言的垃圾回收机制会直接将没有使用的内存进行回收：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (mc *memCache) Flush() bool {
	mc.locker.Lock()
	defer mc.locker.Unlock()
	// 直接将整个 map 置空，go 的垃圾回收机制会自行将没有使用的内存进行回收
	mc.values = make(map[string]*memCacheValue, 0)
	mc.currMemorySize = 0

	return true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;加写锁保护&lt;/li&gt;
&lt;li&gt;将整个 map 置空，并将当前使用内存大小清空&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;Keys&lt;/h5&gt;
&lt;p&gt;​	Keys 方法，用于获取缓存中 key 的数量。直接用 len() 函数获取即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (mc *memCache) Keys() int64 {
	mc.locker.RLock()
	defer mc.locker.RUnlock()
	return int64(len(mc.values))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;加读锁保护&lt;/li&gt;
&lt;li&gt;利用 len() 函数直接获取&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​	现在我们再来看看这个 GetValSize 函数，这里有两种思路实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用反射包 &lt;code&gt;unsafe.Sizeof(val)&lt;/code&gt; 来获取对应的值的大小&lt;/li&gt;
&lt;li&gt;野路子：利用 json 包，将 val 序列化为字节数组，然后求字节数组的长度，就知道该值占用了多少字节了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	通过测试，可以发现第一种方法是不可靠的，因为&lt;code&gt;unsafe.Sizeof()&lt;/code&gt; 方法只是算出对应类型的字节大小，而不是你所存储的内容的具体大小。于是我们这里采用第二种方法来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// cache/util.go
// GetValSize 计算 value 值大小
func GetValSize(val interface{}) int64 {
	// 野路子：利用 json 包，将 val 序列化为字节数组，然后求字节数组的长度，就知道占用了多少字节了
	bytes, _ := json.Marshal(val)
	size := int64(len(bytes))
	return size
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	至此，我们的基础功能，就差不多实现了。大家可以通过在 main 函数打印对应的信息来检查。在这里，我就不再带着大家检查了。&lt;/p&gt;
&lt;h4&gt;实现代理层&lt;/h4&gt;
&lt;p&gt;​	首先我们得明白，为什么要再加一层代理层？在这里，题目给的接口是包含过期时间的，但是我们的使用示例却没有使用过期时间，这就是说明需要加一层代理层来进行封装。&lt;/p&gt;
&lt;p&gt;​	添加代理层还有一些好处，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全性：它可以过滤和阻止对系统的未经授权的访问，通过身份验证和授权机制确保只有合法的用户或服务可以访问底层的资源。这有助于防范潜在的安全威胁。&lt;/li&gt;
&lt;li&gt;性能优化：代理层可以缓存某些请求的结果，以避免重复计算或数据库查询。此外，代理层还可以对请求进行负载均衡，确保各个后端服务得到合理的分配，以提高整体性能。&lt;/li&gt;
&lt;li&gt;抽象底层实现： 代理层可以用于隐藏底层实现的复杂性，提供简化的接口给上层系统。这有助于实现系统的模块化和降低耦合度，使得系统更容易维护和扩展。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	下面我们来看看怎么实现代理层：&lt;/p&gt;
&lt;p&gt;​	首先，在项目根目录创建一个文件夹 cache-server ，并在该目录下创建一个 cache.go 文件，完整代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package cache_server

import (
	&quot;main/cache&quot;
	&quot;time&quot;
)

// 代理层/适配层
type cacheServer struct {
	memCache cache.Cache
}

func NewMemCache() *cacheServer {
	return &amp;amp;amp;cacheServer{
		memCache: cache.NewMemCache(),
	}
}

// SetMaxMemory size : 1KB 100KB 1MB 2MB 1GB
func (cs *cacheServer) SetMaxMemory(size string) bool {
	return cs.memCache.SetMaxMemory(size)
}

// Set 将 value 写入缓存
// 代理层：将 有效时长参数设置为可有可无
func (cs *cacheServer) Set(key string, val interface{}, expire ...time.Duration) bool {
	// 默认值为 0 秒
	expireTs := time.Second * 0
	if len(expire) &amp;amp;gt; 0 {
		expireTs = expire[0]
	}
	return cs.memCache.Set(key, val, expireTs)
}

// Get 根据 key 值获取 value
func (cs *cacheServer) Get(key string) (interface{}, bool) {
	return cs.memCache.Get(key)
}

// Del 删除 key 值
func (cs *cacheServer) Del(key string) bool {
	return cs.memCache.Del(key)
}

// Exists 判断 key 是否存在
func (cs *cacheServer) Exists(key string) bool {
	return cs.memCache.Exists(key)
}

// Flush 清空所有 key
func (cs *cacheServer) Flush() bool {
	return cs.memCache.Flush()
}

// Keys 获取缓存中所有 key 的数量
func (cs *cacheServer) Keys() int64 {
	return cs.memCache.Keys()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;首先我们仍然需要先将 cache 接口封装起来，并写一个构造函数返回一个实例&lt;/li&gt;
&lt;li&gt;除了 Set 方法外，其他方法直接调用实现即可&lt;/li&gt;
&lt;li&gt;在 Set 方法中，将过期时间参数设置为可选参数，即 &lt;code&gt;expire ...time.Duration&lt;/code&gt;，然后通过判断是否传入该参数来构建新的参数 &lt;code&gt;expireTs&lt;/code&gt; 去调用实现好的方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	实现完成后，我们就可以将 main 函数的代码修改一下，调用代理层提供的方法来进行使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
	cache_server &quot;main/cache-server&quot;
)

func main() {
	cache := cache_server.NewMemCache()
	cache.SetMaxMemory(&quot;100MB&quot;)
	cache.Set(&quot;int&quot;, 1)
	cache.Set(&quot;bool&quot;, false)
	cache.Set(&quot;data&quot;, map[string]interface{}{&quot;a&quot;: 1})
	cache.Get(&quot;int&quot;)
	cache.Del(&quot;int&quot;)
	cache.Flush()
	cache.Keys()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这样，即使我们不使用带过期时间的 Set 方法，也不会报错了。&lt;/p&gt;
&lt;h4&gt;加分项&lt;/h4&gt;
&lt;p&gt;​	最后我们再来看看我们的加分项：&lt;/p&gt;
&lt;h5&gt;轮询检查删除过期键&lt;/h5&gt;
&lt;p&gt;​	我们可以在创建缓存系统实例的时候，同时开启我们的 ” 轮询检查删除过期键 “ 功能。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func NewMemCache() Cache {
	mc := &amp;amp;amp;memCache{
		values:                       make(map[string]*memCacheValue),
		cleanExpiredItemTimeInterval: time.Second, // 定期清理缓存
	}
	// 轮询检查删除过期键
	go mc.cleanExpiredItem()
	return mc
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这里需要新添加一个字段 &lt;code&gt;cleanExpiredItemTimeInterval&lt;/code&gt; 表示清理周期，还需要写一个轮询的函数，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type memCache struct {
	...
	// 清楚过期缓存时间间隔
	cleanExpiredItemTimeInterval time.Duration
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	下面是轮询的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 轮询清空过期 key
func (mc *memCache) cleanExpiredItem() {
	// 设置一个定时触发器：定时向 Ticker.C 中发送一个消息，即触发了一次
	timeTicker := time.NewTicker(mc.cleanExpiredItemTimeInterval)
	defer timeTicker.Stop()
	for {
		select {
		case &amp;amp;lt;-timeTicker.C: // 每个周期做一个缓存清理
			// 遍历所有缓存的键值对，将有过期时间且过期的键删除掉
			for key, item := range mc.values {
				if item.expire != 0 &amp;amp;amp;&amp;amp;amp; time.Now().After(item.expireTime) {
					mc.locker.Lock()
					mc.del(key)
					mc.locker.Unlock()
				}
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;采用 &lt;code&gt;time.NewTicker&lt;/code&gt;，定义一个制定周期的定时器&lt;/li&gt;
&lt;li&gt;由于需要不断轮询，故需要放在 for 循环中&lt;/li&gt;
&lt;li&gt;配合 select 实现一个阻塞式的轮询检查并删除过期键的操作操作&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;单元测试&lt;/h5&gt;
&lt;p&gt;​	单元测试是一种用于验证程序各个独立单元是否能按照预期工作的测试方法。Go语言的测试工具内置于语言本身，通过 &lt;code&gt;testing&lt;/code&gt; 包提供了一套简单而有效的测试框架。平时不论是学习、还是工作，都应该养成写单元测试的习惯。&lt;/p&gt;
&lt;p&gt;​	我们在 cache 包下，创建一个 memCache_test.go 文件，并在里面写我们测试内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package cache

import (
	&quot;testing&quot;
	&quot;time&quot;
)

func TestCacheOP(t *testing.T) {
	testData := []struct {
		key    string
		val    interface{}
		expire time.Duration
	}{
		{&quot;baer&quot;, 678, time.Second * 10},
		{&quot;hrws&quot;, false, time.Second * 11},
		{&quot;gddfas&quot;, true, time.Second * 12},
		{&quot;rwe&quot;, map[string]interface{}{&quot;a&quot;: 3, &quot;b&quot;: false}, time.Second * 13},
		{&quot;rqew&quot;, &quot;fsdfas&quot;, time.Second * 14},
		{&quot;fsdew&quot;, &quot;这里是字符串这里是字符串这里是字符串&quot;, time.Second * 15},
	}

	c := NewMemCache()
	c.SetMaxMemory(&quot;10MB&quot;)
	// 测试 set 和 get
	for _, item := range testData {
		c.Set(item.key, item.val, item.expire)
		val, ok := c.Get(item.key)
		if !ok {
			t.Error(&quot;缓存取值失败&quot;)
		}
		if item.key != &quot;rwe&quot; &amp;amp;amp;&amp;amp;amp; val != item.val {
			t.Error(&quot;缓存取值数据与预期不一致&quot;)
		}
		_, ok1 := val.(map[string]interface{})
		if item.key == &quot;rwe&quot; &amp;amp;amp;&amp;amp;amp; !ok1 {
			t.Error(&quot;缓存取值数据与预期不一致&quot;)
		}
	}
	// 测试 Keys()
	if int64(len(testData)) != c.Keys() {
		t.Error(&quot;缓存数量不一致&quot;)
	}
	// 测试 Del()
	c.Del(testData[0].key)
	c.Del(testData[1].key)

	if int64(len(testData)) != c.Keys()+2 {
		t.Error(&quot;缓存数量不一致&quot;)
	}

	// 测试过期时间
	time.Sleep(time.Second * 16)

	if c.Keys() != 0 {
		t.Error(&quot;缓存清空失败&quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先用匿名结构体，构建需要用到的各类测试数据&lt;/p&gt;
&lt;p&gt;然后对 Set、Get、Del 等方法进行调用，然后对比结果&lt;/p&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;​	这篇文章，通过一个面试题，从题目到各种坑点的分析，带大家了解并实现了一个简易版的 内存缓存系统  。相信大家在看完后肯定会收货满满。&lt;/p&gt;
&lt;h1&gt;完整代码&lt;/h1&gt;
&lt;p&gt;这是项目的目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/memCache.png&quot; alt=&quot;memCache&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面会给出各个文件的内容：&lt;/p&gt;
&lt;h5&gt;main.go&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
	&quot;fmt&quot;
	cacheserver &quot;main/cache-server&quot;
	&quot;time&quot;
)

func main() {
	cache := cache_server.NewMemCache()
	cache.SetMaxMemory(&quot;100MB&quot;)
	cache.Set(&quot;int&quot;, 1)
	cache.Set(&quot;bool&quot;, false)
	cache.Set(&quot;data&quot;, map[string]interface{}{&quot;a&quot;: 1})
	cache.Get(&quot;int&quot;)
	cache.Del(&quot;int&quot;)
	cache.Flush()
	cache.Keys()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;cache/cache.go&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package cache

import &quot;time&quot;

type Cache interface {
	SetMaxMemory(size string) bool
	Set(key string, val interface{}, expire time.Duration) bool
	Get(key string) (interface{}, bool)
	Del(key string) bool
	Exists(key string) bool
	Flush() bool
	Keys() int64
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;cache/memCache.go&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package cache

import (
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

type memCache struct {
	maxMemorySize int64
	maxMemorySizeStr string
	currMemorySize int64
	values map[string]*memCacheValue
	locker sync.RWMutex
	cleanExpiredItemTimeInterval time.Duration
}

type memCacheValue struct {
	val interface{}
	expireTime time.Time
	expire time.Duration
	size int64
}

func NewMemCache() Cache {
	mc := &amp;amp;amp;memCache{
		values:                       make(map[string]*memCacheValue),
		cleanExpiredItemTimeInterval: time.Second, 
	}
	go mc.cleanExpiredItem()
	return mc
}

func (mc *memCache) SetMaxMemory(size string) bool {
	mc.maxMemorySize, mc.maxMemorySizeStr = ParseSize(size)
	return true
}

func (mc *memCache) Set(key string, val interface{}, expire time.Duration) bool {
	mc.locker.Lock()
	defer mc.locker.Unlock()
	v := &amp;amp;amp;memCacheValue{
		val:        val,
		expireTime: time.Now().Add(expire),
		expire:     expire,
		size:       GetValSize(val),
	}
	if _, ok := mc.get(key); ok {
		mc.del(key)
	}
	mc.add(key, v)

	if mc.currMemorySize &amp;amp;gt; mc.maxMemorySize {
		mc.del(key)
		log.Println(fmt.Sprintf(&quot;max memory size %s&quot;, mc.maxMemorySizeStr))
	}
	return false
}

func (mc *memCache) get(key string) (*memCacheValue, bool) {
	val, ok := mc.values[key]
	return val, ok
}

func (mc *memCache) del(key string) {
	tmp, ok := mc.get(key)
	if ok &amp;amp;amp;&amp;amp;amp; tmp != nil {
		mc.currMemorySize -= tmp.size
		delete(mc.values, key)
	}
}

func (mc *memCache) add(key string, val *memCacheValue) {
	mc.values[key] = val
	mc.currMemorySize += val.size
}

func (mc *memCache) Get(key string) (interface{}, bool) {
	mc.locker.RLock()
	defer mc.locker.RUnlock()

	mcv, ok := mc.get(key)
	if ok {
		if mcv.expire != 0 &amp;amp;amp;&amp;amp;amp; mcv.expireTime.Before(time.Now()) {
			mc.del(key)
			return nil, false
		}
		return mcv.val, ok
	}
	return nil, false
}

func (mc *memCache) Del(key string) bool {
	mc.locker.Lock()
	defer mc.locker.Unlock()
	mc.del(key)
	return true
}

func (mc *memCache) Exists(key string) bool {
	mc.locker.RLock()
	defer mc.locker.RUnlock()
	_, ok := mc.values[key]
	return ok
}

func (mc *memCache) Flush() bool {
	mc.locker.Lock()
	defer mc.locker.Unlock()
	mc.values = make(map[string]*memCacheValue, 0)
	mc.currMemorySize = 0

	return true
}

func (mc *memCache) Keys() int64 {
	mc.locker.RLock()
	defer mc.locker.RUnlock()
	return int64(len(mc.values))
}

func (mc *memCache) cleanExpiredItem() {
	timeTicker := time.NewTicker(mc.cleanExpiredItemTimeInterval)
	defer timeTicker.Stop()
	for {
		select {
		case &amp;amp;lt;-timeTicker.C: 
			for key, item := range mc.values {
				if item.expire != 0 &amp;amp;amp;&amp;amp;amp; time.Now().After(item.expireTime) {
					mc.locker.Lock()
					mc.del(key)
					mc.locker.Unlock()
				}
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;cache/memCache_test.go&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package cache

import (
	&quot;testing&quot;
	&quot;time&quot;
)

func TestCacheOP(t *testing.T) {
	testData := []struct {
		key    string
		val    interface{}
		expire time.Duration
	}{
		{&quot;baer&quot;, 678, time.Second * 10},
		{&quot;hrws&quot;, false, time.Second * 11},
		{&quot;gddfas&quot;, true, time.Second * 12},
		{&quot;rwe&quot;, map[string]interface{}{&quot;a&quot;: 3, &quot;b&quot;: false}, time.Second * 13},
		{&quot;rqew&quot;, &quot;fsdfas&quot;, time.Second * 14},
		{&quot;fsdew&quot;, &quot;这里是字符串这里是字符串这里是字符串&quot;, time.Second * 15},
	}

	c := NewMemCache()
	c.SetMaxMemory(&quot;10MB&quot;)
    
	for _, item := range testData {
		c.Set(item.key, item.val, item.expire)
		val, ok := c.Get(item.key)
		if !ok {
			t.Error(&quot;缓存取值失败&quot;)
		}
		if item.key != &quot;rwe&quot; &amp;amp;amp;&amp;amp;amp; val != item.val {
			t.Error(&quot;缓存取值数据与预期不一致&quot;)
		}
		_, ok1 := val.(map[string]interface{})
		if item.key == &quot;rwe&quot; &amp;amp;amp;&amp;amp;amp; !ok1 {
			t.Error(&quot;缓存取值数据与预期不一致&quot;)
		}
	}
    
	if int64(len(testData)) != c.Keys() {
		t.Error(&quot;缓存数量不一致&quot;)
	}
    
	c.Del(testData[0].key)
	c.Del(testData[1].key)

	if int64(len(testData)) != c.Keys()+2 {
		t.Error(&quot;缓存数量不一致&quot;)
	}

	time.Sleep(time.Second * 16)

	if c.Keys() != 0 {
		t.Error(&quot;缓存清空失败&quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;cache/util.go&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package cache

import (
	&quot;encoding/json&quot;
	&quot;log&quot;
	&quot;regexp&quot;
	&quot;strconv&quot;
	&quot;strings&quot;
)

const (
	B = 1 &amp;amp;lt;&amp;amp;lt; (iota * 10)
	KB
	MB
	GB
	TB
	PB
)

func ParseSize(size string) (int64, string) {
	re, _ := regexp.Compile(&quot;[0-9]+&quot;)
    
	unit := string(re.ReplaceAll([]byte(size), []byte(&quot;&quot;)))
    
	unit = strings.ToUpper(unit)

	num, _ := strconv.ParseInt(strings.Replace(size, unit, &quot;&quot;, 1), 10, 64)

	var byteNum int64 = 0
	switch unit {
	case &quot;B&quot;:
		byteNum = num
	case &quot;KB&quot;:
		byteNum = num * KB
	case &quot;MB&quot;:
		byteNum = num * MB
	case &quot;GB&quot;:
		byteNum = num * GB
	case &quot;TB&quot;:
		byteNum = num * TB
	case &quot;PB&quot;:
		byteNum = num * PB
	default: 
		num = 0
	}

	if num == 0 {
		log.Println(&quot;ParseSize 仅支持 B、KB、MB、GB、TB、PB&quot;)
		num = 100
		byteNum = num * MB
		unit = &quot;MB&quot;
	}

	sizeStr := strconv.FormatInt(num, 10) + unit
	return byteNum, sizeStr
}

func GetValSize(val interface{}) int64 {
	bytes, _ := json.Marshal(val)
	size := int64(len(bytes))
	return size
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;cache-server/cache.go&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package cache_server

import (
	&quot;main/cache&quot;
	&quot;time&quot;
)

type cacheServer struct {
	memCache cache.Cache
}

func NewMemCache() *cacheServer {
	return &amp;amp;amp;cacheServer{
		memCache: cache.NewMemCache(),
	}
}

func (cs *cacheServer) SetMaxMemory(size string) bool {
	return cs.memCache.SetMaxMemory(size)
}

func (cs *cacheServer) Set(key string, val interface{}, expire ...time.Duration) bool {
	expireTs := time.Second * 0
	if len(expire) &amp;amp;gt; 0 {
		expireTs = expire[0]
	}
	return cs.memCache.Set(key, val, expireTs)
}

func (cs *cacheServer) Get(key string) (interface{}, bool) {
	return cs.memCache.Get(key)
}

func (cs *cacheServer) Del(key string) bool {
	return cs.memCache.Del(key)
}

func (cs *cacheServer) Exists(key string) bool {
	return cs.memCache.Exists(key)
}

func (cs *cacheServer) Flush() bool {
	return cs.memCache.Flush()
}

func (cs *cacheServer) Keys() int64 {
	return cs.memCache.Keys()
}
&lt;/code&gt;&lt;/pre&gt;
</description><link>https://studygolang.com/topics/16993</link><guid isPermaLink="false">https://studygolang.com/topics/16993</guid><pubDate>Tue, 05 Dec 2023 02:56:47 GMT</pubDate><author>oYtoLIGUANGYAO</author><category>每日一学</category></item><item><title>你知道 MySQL 的三大范式吗？</title><description>&lt;p&gt;&amp;gt; 欢迎大家到我的博客浏览 &amp;lt;a color=&quot;red&quot; href=&quot;&lt;a href=&quot;https://www.yinkai.cc/post/6209a41d0c1bdc89b8242b6c5a89a469&quot;&gt;https://www.yinkai.cc/post/6209a41d0c1bdc89b8242b6c5a89a469&lt;/a&gt;&quot;&amp;gt;YinKai &#39;s Blog | MySQL 三大范式&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h4&gt;简介&amp;lt;!--more--&amp;gt;&lt;/h4&gt;
&lt;p&gt;​	三大范式是 MySQL 数据库设计表结构所遵循的规范和指导方法，目的是为了减少冗余，建立结构合理的数据库，从而提高数据存储和使用的性能。&lt;/p&gt;
&lt;p&gt;​	三大范式之间是有依赖关系的，比如第二范式是在第一范式的基础上建设的，第三范式是在第二范式的基础上建设的。&lt;/p&gt;
&lt;p&gt;​	简单来说，就是原子性、唯一性、无传递性。&lt;/p&gt;
&lt;h4&gt;第一范式 - 1NF&lt;/h4&gt;
&lt;p&gt;​	遵循原子性。即，&lt;strong&gt;表中字段的数据，不可再分&lt;/strong&gt;。例如下述表结构：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;员工编号&lt;/th&gt;
&lt;th&gt;姓名&lt;/th&gt;
&lt;th&gt;年龄&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;td&gt;运营部小明&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;002&lt;/td&gt;
&lt;td&gt;技术部小美&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;003&lt;/td&gt;
&lt;td&gt;销售部小张&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;​	上述表结构中，姓名字段是可以进行再拆分的，因此它不符合第一范式。符合第一范式的表结构如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;员工编号&lt;/th&gt;
&lt;th&gt;部门&lt;/th&gt;
&lt;th&gt;姓名&lt;/th&gt;
&lt;th&gt;年龄&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;td&gt;运营部&lt;/td&gt;
&lt;td&gt;小明&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;002&lt;/td&gt;
&lt;td&gt;技术部&lt;/td&gt;
&lt;td&gt;小美&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;003&lt;/td&gt;
&lt;td&gt;销售部&lt;/td&gt;
&lt;td&gt;小张&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;​	但也并不是所有情况，都需要符合第一范式，例如：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;员工编码&lt;/th&gt;
&lt;th&gt;姓名&lt;/th&gt;
&lt;th&gt;省&lt;/th&gt;
&lt;th&gt;市&lt;/th&gt;
&lt;th&gt;区&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;td&gt;小张&lt;/td&gt;
&lt;td&gt;江西省&lt;/td&gt;
&lt;td&gt;南昌市&lt;/td&gt;
&lt;td&gt;东湖区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;002&lt;/td&gt;
&lt;td&gt;小黄&lt;/td&gt;
&lt;td&gt;广东省&lt;/td&gt;
&lt;td&gt;佛山市&lt;/td&gt;
&lt;td&gt;禅城区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;003&lt;/td&gt;
&lt;td&gt;小高&lt;/td&gt;
&lt;td&gt;湖北省&lt;/td&gt;
&lt;td&gt;武汉市&lt;/td&gt;
&lt;td&gt;新洲区&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;​	所以，范式只是一个参考，更多的是需要根据实际情况设计表结构。&lt;/p&gt;
&lt;h4&gt;第二范式 - 2NF&lt;/h4&gt;
&lt;p&gt;​	在满足第一范式的情况下，&lt;strong&gt;遵循唯一性&lt;/strong&gt;，消除部分依赖。即 &lt;strong&gt;表中任意一个主键或任意一组联合主键，可以确定除该主键外的所有的非主键值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	通俗一点讲就是，&lt;strong&gt;一个表只能描述一件事情，且由该表的主键确定&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​	例如，主键为学号，则可以确定姓名、年龄等学生信息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;学号&lt;/th&gt;
&lt;th&gt;姓名&lt;/th&gt;
&lt;th&gt;年龄&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;td&gt;小美&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;002&lt;/td&gt;
&lt;td&gt;小张&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;003&lt;/td&gt;
&lt;td&gt;小明&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;​	主键为课程名称，就可以确定该课程学分、成绩等信息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;课程名称&lt;/th&gt;
&lt;th&gt;成绩&lt;/th&gt;
&lt;th&gt;学分&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;语文&lt;/td&gt;
&lt;td&gt;90&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数学&lt;/td&gt;
&lt;td&gt;90&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;英语&lt;/td&gt;
&lt;td&gt;90&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;​	不遵循第二范式，可能会造成下述后果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据冗余：将不同类型的信息存储在同一张表中可能导致数据冗余。例如，在学生表中，如果每个学生都有多个课程，将学生和课程信息合并存储可能导致数据复制。如果有两名学生，每人选修三门课程，表中会包含6条记录，其中的学生信息将重复。&lt;/li&gt;
&lt;li&gt;更新数据不方便：当需要更新特定信息时，如果数据存储在同一张表中，更新可能变得不太方便。举例来说，如果需要更改某门课程的学分，必须在整个表中搜索相关记录并更新，这可能是一个繁琐的过程。但如果将数据拆分到不同的表中，只需在包含相关信息的表中进行更新，更加便捷。&lt;/li&gt;
&lt;li&gt;插入数据不方便或可能导致异常情况：在某些情况下，插入数据可能变得复杂或引发异常。举例如下：
&lt;ul&gt;
&lt;li&gt;假设主键是学号或课程名称，当需要插入新的课程信息时，必须精心规划哪些学生将选择该课程。这可能需要指定为哪些学生插入对应的课程信息。此外，如果还没有相关成绩信息，可能需要将成绩字段置为空，以后再进行更新。&lt;/li&gt;
&lt;li&gt;假设主键是学号和课程名称的联合主键，插入课程信息时，如果没有学生选择该课程，可能会导致学号主键字段缺失，从而无法插入相关信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;第三范式 - 3NF&lt;/h4&gt;
&lt;p&gt;​	在满足第二范式的情况下， 消除传递依赖。即，&lt;strong&gt;在任一主键都可以确定所有非主键字段的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	举个例子，如下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;学号&lt;/th&gt;
&lt;th&gt;姓名&lt;/th&gt;
&lt;th&gt;班级&lt;/th&gt;
&lt;th&gt;班主任&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;td&gt;小美&lt;/td&gt;
&lt;td&gt;一年级（3）班&lt;/td&gt;
&lt;td&gt;陈老师&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;​	这个表中，学号是主键，它可以唯一确定姓名、班级、班主任，符合第二范式，但是在非主键字段中，我们可以可以通过班级推导出该班级的班主任，所以他不符合第三范式。&lt;/p&gt;
&lt;p&gt;​	上述的表要满足第三范式，可以像下面这样设计：&lt;/p&gt;
&lt;p&gt;1.学生表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;学号&lt;/th&gt;
&lt;th&gt;姓名&lt;/th&gt;
&lt;th&gt;班级&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;td&gt;小美&lt;/td&gt;
&lt;td&gt;一年级（3）班&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;2.班级表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;班级&lt;/th&gt;
&lt;th&gt;班主任&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;一年级（3）&lt;/td&gt;
&lt;td&gt;陈老师&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;通过把班主任和班级的映射关系做成另一张表，就可以消除表中的传递依赖。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;总结&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;第一范式（1 NF）：字段不可再拆分&lt;/li&gt;
&lt;li&gt;第二范式（2 NF）：表中任意一个主键或者任意一组联合主键，可以唯一确定除该主键外的所有非主键值。&lt;/li&gt;
&lt;li&gt;第三范式（3 NF）：在任一主键都可以确定所有非主键字段值的情况下，不能存在某非主键字段 A 可以获取 某非主键字段 B。&lt;/li&gt;
&lt;/ul&gt;
</description><link>https://studygolang.com/topics/16989</link><guid isPermaLink="false">https://studygolang.com/topics/16989</guid><pubDate>Mon, 04 Dec 2023 09:16:00 GMT</pubDate><author>oYto</author><category>每日一学</category></item><item><title>你知道 MySQL 中的 order by 是怎么工作的吗？</title><description>&lt;p&gt;​	今天我们来看一下 MySQL 中 “ order by ” 是怎么工作的。
更好的阅读体验，&amp;lt;a href=&quot;&lt;a href=&quot;https://www.yinkai.cc/post/3050ed4309a12c35515cfa2b317aea3c&quot;&gt;https://www.yinkai.cc/post/3050ed4309a12c35515cfa2b317aea3c&lt;/a&gt;&quot;&amp;gt;order by 是怎么工作的&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;​	我们以一个实际的例子，来探讨这个问题：&lt;/p&gt;
&lt;p&gt;​	假设我们的表是这样定义的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `city` varchar(16) NOT NULL,
  `name` varchar(16) NOT NULL,
  `age` int(11) NOT NULL,
  `addr` varchar(128) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `city` (`city`)
) ENGINE=InnoDB;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	我们的 SQL 语句是这样写的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;select city,name,age from t where city=&#39;杭州&#39; order by name limit 1000  ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这个语句看上去逻辑很清楚，但你了解它的执行流程吗？下面我们就一起来聊聊这个语句是怎么执行的。&lt;/p&gt;
&lt;h1&gt;全字段排序&lt;/h1&gt;
&lt;p&gt;​	我们都知道，如果一个查询语句不走索引，就会全表扫描，为了避免全表扫描，我们在创建表的时候为 city 字段建立索引了，也可以使用下面的命令重新建立：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;CREATE INDEX idx_city ON t (city);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	建立完索引后，我们使用 explain 命令来看看这个语句的执行情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/explain.png&quot; alt=&quot;explain&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	下面我们对输出的字段进行解释：&lt;/p&gt;
&lt;p&gt;:::details 感兴趣的可以点开查看&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;**id：**每个 &lt;code&gt;SELECT&lt;/code&gt; 语句都会 分配一个唯一的标识符，在复杂查询中，可以通过这个字段来区分各个子查询。&lt;/li&gt;
&lt;li&gt;**select_type：**描述了查询的类型，常见的有：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SIMPLE&lt;/code&gt;：简单查询，不包含子查询或联合查询&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PRIMARY&lt;/code&gt;：复杂查询中的最外层查询&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUBQUERY&lt;/code&gt;：子查询。&lt;/li&gt;
&lt;li&gt;其他值表示更复杂的查询类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;table&lt;/strong&gt;：表示查询涉及的表名。&lt;/li&gt;
&lt;li&gt;**partitions：**表示查询涉及的分区信息&lt;/li&gt;
&lt;li&gt;**type：**表示链接类型，有：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;system&lt;/code&gt;：表只有一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;：使用主键或唯一索引进行等值查询，最多返回一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eq_ref&lt;/code&gt;：类似于 &lt;code&gt;const&lt;/code&gt;，但用于连接的是唯一索引&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ref&lt;/code&gt;：非唯一索引的等值查询&lt;/li&gt;
&lt;li&gt;&lt;code&gt;range&lt;/code&gt;：用于范围查询&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index&lt;/code&gt;：完全扫描索引来匹配查询&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ALL&lt;/code&gt;：完全表扫描。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;**possible_keys：**列出可能用于查询的索引，但并不一定会被选择&lt;/li&gt;
&lt;li&gt;**key：**实际被查询优化器选择的索引&lt;/li&gt;
&lt;li&gt;**key_len：**表示索引中使用的字节数&lt;/li&gt;
&lt;li&gt;**ref：**显示索引的哪一列被用于查找
&lt;ul&gt;
&lt;li&gt;当值为 const 时，表示查询是通过常量条件来使用索引进行查找的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;**rows：**表示估计需要检查的行数&lt;/li&gt;
&lt;li&gt;**filtered：**表示在表中满足条件的行所占的百分比&lt;/li&gt;
&lt;li&gt;**Extra：**提供关于查询执行的额外信息，如使用索引的条件，是否使用文件排序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;​	我们需要强调是就是 Extra 字段中的 “Using filesort”，表示需要排序，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/city_index.png&quot; alt=&quot;city_index.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	通常情况下，这个语句的执行流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化 sort_buffer，确定放入 name、city、age 这三个字段；&lt;/li&gt;
&lt;li&gt;从索引 city 找到第一个满足 city = &#39;杭州&#39; 条件的主键 id，也就是途中的 ID.x&lt;/li&gt;
&lt;li&gt;到主键 id 索引取出整行，取出 name、city、age 三个字段的值，存入 sort_buffer 中；&lt;/li&gt;
&lt;li&gt;从索引 city 取出下一个记录的主键 id；&lt;/li&gt;
&lt;li&gt;重复 3、4 步骤直到 city 的值不满足查询条件为止，对应的主键 id 也就是途中的 ID.Y&lt;/li&gt;
&lt;li&gt;对 sort_buffer 中的数据按照字段 name 做快速排序&lt;/li&gt;
&lt;li&gt;按照排序结果取前 1000 行返回给客户端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	我们暂且把这个排序过程，称为全字段排序，执行流程的示意图如下所示，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/%E5%85%A8%E5%AD%97%E6%AE%B5%E6%8E%92%E5%BA%8F.png&quot; alt=&quot;全字段排序.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	上图中，按 “name” 排序这个动作，可能在内存中完成，也有可能需要使用外部排序，这取决于所需的内存和参数 sort_buffer_size。&lt;/p&gt;
&lt;p&gt;​	sort_buffer_size 是 MySQL 为排序开辟的内存（sort_buffer）的大小，如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则需要利用磁盘临时文件辅助排序。&lt;/p&gt;
&lt;p&gt;​	你可以使用下面的方法，来确定要给排序语句是否使用了临时文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;/* 打开了 optimizer_trace 功能，这样会生成有关查询优化过程的详细信息。只对本线程有效 */
SET optimizer_trace=&#39;enabled=on&#39;; 
 
/* @a 保存查询前的 Innodb_rows_read 值，用于后续计算差值。 */
select VARIABLE_VALUE into @a from  performance_schema.session_status where variable_name = &#39;Innodb_rows_read&#39;;
 
/* 执行语句 */
select city, name,age from t where city=&#39;杭州&#39; order by name limit 1000; 
 
/* 查看了 OPTIMIZER_TRACE 表的输出，以查看查询优化器的决策过程。 */
SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\G
 
/* @b 保存查询后的 Innodb_rows_read 值，用于计算差值。 */
select VARIABLE_VALUE into @b from performance_schema.session_status where variable_name = &#39;Innodb_rows_read&#39;;
 
/* 计算 Innodb_rows_read 差值,该差值表示在执行查询期间从 InnoDB 表中读取的行数。 */
select @b-@a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，我们可以从 num_initial_chunks_spilled_to_disk 可以得知，排序可以完全在内存中完成，不需要使用临时文件；如果大于零，表示可能使用了临时文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/%E6%8E%92%E5%BA%8F%E7%9A%84%E9%83%A8%E5%88%86%E7%BB%93%E6%9E%9C.png&quot; alt=&quot;排序的部分结果.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	如果看到了 number_of_tmp_files 字段，并且后面的数字不为 0，则表示排序过程中使用的临时文件数。由于内存放不下，就需要使用外部排序，通常外部排序使用归并排序算法。可以理解为，MySQL 将需要排序的数据分为 12 份，每一份单独排序后存在这些临时文件中，然后把这 12 个有序文件再合并成一个有序的大文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/%E6%8E%92%E5%BA%8F%E7%9A%84%E9%83%A8%E5%88%86%E7%BB%93%E6%9E%9C2.png&quot; alt=&quot;排序的部分结果2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	我们再挑两个比较重要的记录来介绍一下。&lt;/p&gt;
&lt;p&gt;​	一个是 num_examined_rows = 187，表示&lt;strong&gt;参与排序&lt;/strong&gt;的行数是 187 行。&lt;/p&gt;
&lt;p&gt;​	sort_mode 里面的 packed_additional_fields 的意思是，排序过程对字符串做了“紧凑”处理。即使 name 字段的定义是 varchar(16)，在排序过程中还是要按照实际长度来分配空间的。&lt;/p&gt;
&lt;p&gt;​	最后一个查询语句 select @b-@a 的返回结果应该是 187，表示整个过程中在表中读取的行数。&lt;/p&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;根据 internal_tmp_disk_storage_engine 这个系统变量的不同，可能会对最后的结果造成影响。&lt;/p&gt;
&lt;p&gt;​	internal_tmp_disk_storage_engine  用于指定在执行排序和临时表创建时使用的存储引擎。这个变量决定了 MySQL 在执行排序等操作时，是否将临时数据存储在磁盘上。&lt;/p&gt;
&lt;p&gt;​	因为查询 OPTIMIZER_TRACE 这个表时，需要用到临时表，如果使用 InnoDB 引擎的话，把数据从临时表里取出来的时候，会让 Innodb_rows_read 的值 + 1。&lt;/p&gt;
&lt;p&gt;​	为了避免影响，我们可以把 internal_tmp_disk_storage_engine 修改为 MyISAM。&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h1&gt;rowid 排序&lt;/h1&gt;
&lt;p&gt;​	在上面这个算法过程里面，只会对原表的数据读一遍，剩下的操作都是在 sort_buffer 和临时文件中执行的。这样就会存在一个问题：如果查询要返回的字段很多，就会导致 sort_buffer 里面要存放的字段数很多，这样内存中能存放的行数就会变少，因此就需要分成很多个临时文件，排序的性能就会很差。&lt;/p&gt;
&lt;p&gt;​	所以，单行很大，这个算法的效率就稍差一些。&lt;/p&gt;
&lt;p&gt;​	那 MySQL 在面对这种排序的单行长度太大的情况会怎么做呢？&lt;/p&gt;
&lt;p&gt;​	我们可以人为地修改 max_length_for_sort_data 这个参数，让 MySQL 采用另外一种算法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SET max_length_for_sort_data = 16;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​	max_length_for_sort_data，是 MySQL 控制用于排序的行数据的长度的一个参数，我们可以理解为：如果单行的长度超过这个值，MySQL 就认为单行太大了，要换另外一个算法。&lt;/p&gt;
&lt;p&gt;​	city、name、age 这三个字段的定义总长度是 36，我把 max_length_for_sort_data 设置为 16，我们再来看看计算过程有什么改变。&lt;/p&gt;
&lt;p&gt;​	新的算法放入 sort_buffer 的字段，只有需要排序的字段（name）和主键 id。&lt;/p&gt;
&lt;p&gt;​	由于排序的结果少了我们需要的 city 和 age 字段的值，不能直接返回了，故整个执行流程就变成了下面的样子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化 sort_buffer，确定放入两个字段，即 name 和 id；&lt;/li&gt;
&lt;li&gt;从索引 city 找到第一个满足 city= &#39;杭州&#39; 条件的主键 id，即图中的 ID.x；&lt;/li&gt;
&lt;li&gt;到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；&lt;/li&gt;
&lt;li&gt;从索引 city 取下一个记录的主键 id；&lt;/li&gt;
&lt;li&gt;重复步骤 3、4 直到不满足 city= &#39;杭州&#39; 条件为止，即图中的 ID.Y；&lt;/li&gt;
&lt;li&gt;对 sort_buffer 中的数据按照字段 name 进行排序；&lt;/li&gt;
&lt;li&gt;遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	这个执行的流程示意图如下，我们可以称它为 rowid 排序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/rowid%E8%BF%87%E7%A8%8B.png&quot; alt=&quot;rowid过程.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	我们对比全字段排序的流程图就会发现，rowid 排序多访问了一次表 t 的主键索引，即步骤 7。&lt;/p&gt;
&lt;p&gt;:::danger&lt;/p&gt;
&lt;p&gt;最后的“结果集”是一个逻辑概念，实际上 MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到 city、name 和 age 这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;​	我们使用同样的方法，对 rowid 排序执行一下 select @b-@a，看看结果是有什么不同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://studygolang.com/images/rowid%E8%BF%87%E7%A8%8B2.png&quot; alt=&quot;rowid过程2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;​	可以看到 num_examined_rows 的值还是 187，但是 @b-@a 的结果却变成了 375，这是因为对于 sort_buffer 中排序后的 187 条数据，还需要回到原表中去获取我们需要的其他记录值，所以最终在表中读取的行数为 187 + 1 + 187 = 375.&lt;/p&gt;
&lt;h1&gt;小结&lt;/h1&gt;
&lt;p&gt;​	对于学习的内容，我们可以总结一下：&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;全字段排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先初始化 sort_buffer，确定放入我们需要查询的字段&lt;/li&gt;
&lt;li&gt;根据索引，查询满足过滤条件的主键 ID&lt;/li&gt;
&lt;li&gt;到主键 id 索引取出整行，取出我们需要查询的字段，存入 sort_buffer 中；&lt;/li&gt;
&lt;li&gt;从索引取下一个记录的主键 id；&lt;/li&gt;
&lt;li&gt;重复步骤 3、4 直到下一条记录的值不满足查询条件为止&lt;/li&gt;
&lt;li&gt;对 sort_buffer 中那点数据按照排序字段进行排序；
&lt;ul&gt;
&lt;li&gt;内存中一般使用快速排序&lt;/li&gt;
&lt;li&gt;外部排序一般使用归并排序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按照排序结果取出对应的记录返回给客户端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	&lt;strong&gt;rowid 排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化 sort_buffer，确定放入的字段，即主键 id 和排序字段&lt;/li&gt;
&lt;li&gt;根据索引，查询满足过滤条件的主键 ID&lt;/li&gt;
&lt;li&gt;到主键 id 索引取出整行，取出我们需要查询的字段，存入 sort_buffer 中；&lt;/li&gt;
&lt;li&gt;从索引取下一个记录的主键 id；&lt;/li&gt;
&lt;li&gt;重复步骤 3、4 直到下一条记录的值不满足查询条件为止&lt;/li&gt;
&lt;li&gt;对 sort_buffer 中那点数据按照排序字段进行排序；
&lt;ul&gt;
&lt;li&gt;内存中一般使用快速排序&lt;/li&gt;
&lt;li&gt;外部排序一般使用归并排序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;遍历排序结果，取出对应的记录，并按照 id 的值回到原表中取出我们需要查询的所有字段返回给客户端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	&lt;strong&gt;全字段排序和 rowid 排序的差异：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。&lt;/li&gt;
&lt;li&gt;如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	&lt;strong&gt;前者需要考虑的是排序效率的影响，后者需要考虑的是磁盘访问效率的影响。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	全字段排序也体现了 MySQL 的一个设计思想：&lt;strong&gt;如果内存够，就要多利用内存，尽量减少磁盘访问。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。&lt;/p&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;​	我们要明确一点：并不是所有的 order by 语句都需要排序操作。从上面的分析过程，我们可以看到，MySQL 之所以生成临时表，并且在临时表上做排序操作，&lt;strong&gt;其原因是原来的数据是无序的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	如果能够保证从 city 这个索引取出来的行，天然就是按照 name 递增排序的话，就可以不用再排序了。&lt;/p&gt;
&lt;p&gt;​	感兴趣的友友，可以通过给 name 和 city 字段建立联合索引，再走一遍上面的分析过程，就会非常清晰了，这里由于篇幅有限，就不作过多赘述了。&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;p&gt;&amp;gt; 问：MySQL 中 order by 是怎么工作的？
&amp;gt;
&amp;gt; 答：首先 MySQL 会根据排序的行数据的长度，来选择不同的排序算法。这个长度是由 max_length_for_sort_data 控制的，如果单行的长度超过这个值，MySQL 就认为单行太大了，将采用 rowid 排序，反之采用全字段排序。
&amp;gt;
&amp;gt; 说，“这里需要展开介绍一下这两种算法吗？”。
&amp;gt;
&amp;gt; 全字段排序，首先会初始化 sort_buffer，确定需要放入的字段，即我们查询的需要返回的字段。然后根据查询条件，找出符合的主键 id，根据主键 id 到主键索引取出整行记录，然后拿出我们查询的字段放入 sort_buffer 中，查询到不满足查询条件为止。最后对 sort_buffer 中的数据按照排序字段进行排序，将结果返回客户端。
&amp;gt;
&amp;gt; rowid 排序 与 全字段排序大致过程差不多，不同的点是：它只会将排序字段和主键 id 放入 sort_buffer 中，在对 sort_buffer 中的数据排序后，再按照主键 id 的值返回到原表中取出我们需要的其他字段的值返回给客户端。
&amp;gt;
&amp;gt; rowid 排序会要求回表次数较多，造成磁盘读，因此不会被优先选择。
&amp;gt;
&amp;gt; 全字段排序，也会存在一些问题，就是在单行记录过大时，会导致 sort_buffer 存不下几行记录，因此需要更多的文件进行存储，文件数量越多，排序的效率就会越差。
&amp;gt;
&amp;gt; 为了避免上述的麻烦，我们在使用查询语句时，尽量走索引去查询，以减少不必要的排序开销和内存开销。&lt;/p&gt;
</description><link>https://studygolang.com/topics/16985</link><guid isPermaLink="false">https://studygolang.com/topics/16985</guid><pubDate>Sun, 03 Dec 2023 03:46:03 GMT</pubDate><author>oYtomengmeng</author><category>每日一学</category></item><item><title>MoveFunsDAO 星航计划</title><description>&lt;p&gt;💁‍♂️朋友，这是你‬的iphone15么？📱&lt;/p&gt;
&lt;p&gt;📢🚀 欢来迎到 Move 开训发‬练营！🎉&lt;/p&gt;
&lt;p&gt;🎁 免费入‬门 Web3 开发，还有机‬会赢超炫得‬酷的 iPhone15 一部！📱💥&lt;/p&gt;
&lt;p&gt;🌟 星航计‬划是力于致‬引导更开发多‬者门入了和‬解 Web3 的益公活动，本期 Move 主题的‬开发课程，让你迈‬出成区为‬链块开咖发‬大的第一步！🚀&lt;/p&gt;
&lt;p&gt;🗓️ 训练营‬将于11月12日火热‬启动！别等了，快来点‬击推文/海报了‬解详情报名并‬吧！👉💻💪&lt;/p&gt;
&lt;p&gt;✨ 加入我们，发现区‬块链世的魅界‬力！参训练与‬营，学习最前‬沿的 Web3 开发技‬能！🌐📚&lt;/p&gt;
&lt;p&gt;#Move开训练发‬营 #Web3 #星航计‬划 #区块开链‬发 #iPhone15
点击下方链接报名:
&lt;a href=&quot;https://mp.weixin.qq.com/s/3sBeCS0zeeEOnS4z0lZ0DQ&quot;&gt;https://mp.weixin.qq.com/s/3sBeCS0zeeEOnS4z0lZ0DQ&lt;/a&gt;&lt;/p&gt;
</description><link>https://studygolang.com/topics/16913</link><guid isPermaLink="false">https://studygolang.com/topics/16913</guid><pubDate>Sun, 12 Nov 2023 07:45:40 GMT</pubDate><author>act76</author><category>每日一学</category></item><item><title>Vue3+Vite+Vant-UI 开发双端招聘APP-内附资料</title><description>&lt;h2&gt;download：&lt;a href=&quot;https://www.sisuoit.com/4243.html&quot;&gt;Vue3+Vite+Vant-UI 开发双端招聘APP&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;vue3+Vite+Vant-ui 开发双端招聘APP
商用级项目+业务能力+设计思维3重提升，打造差异化竞争力
这是非常有价值的一门项目开发课程，对于初入职场的开发者，将助力面试时极大提升个人竞争力，展露能力价值。课程以业务驱动技术栈，将真正的商用级项目复原在课程中，使用Vite、Vue3、Vant3UI、Pinia和VueUse等前沿技术，从构建、研发、测试，完成整个全流程的学习。让你在掌握技术的同时，也能提升作为开发者的综合素养。项目功能相对完善，界面美观，手把手带你做出亮眼的作品。
适合人群
前端实习生
初级/中级前端开发
有vue相关经验的人员
技术储备
html5\css3
javaScript(ES6)
Vue基础
Flex布局技术
TypeScript基础
环境参数
node 16.12.0
Pinia ^2.0.22
Vite ^3.1.0
VueUse ^8.2.0
Vue ^3.2.37
Vant-UI ^3.6.2
TypeScript ^4.6.4&lt;/p&gt;
&lt;p&gt;试看链接: &lt;a href=&quot;https://pan.baidu.com/s/16UivpWm5SKl0d6ffcqQT5g?pwd=zfyv&quot;&gt;https://pan.baidu.com/s/16UivpWm5SKl0d6ffcqQT5g?pwd=zfyv&lt;/a&gt;&lt;/p&gt;
</description><link>https://studygolang.com/topics/16604</link><guid isPermaLink="false">https://studygolang.com/topics/16604</guid><pubDate>Sat, 12 Aug 2023 22:26:03 GMT</pubDate><author>cainiao56</author><category>每日一学</category></item><item><title>程序员上乘内功修炼</title><description>&lt;p&gt;&lt;a href=&quot;https://blog.51cto.com/u_14944648/6400489&quot;&gt;https://blog.51cto.com/u_14944648/6400489&lt;/a&gt;&lt;/p&gt;
</description><link>https://studygolang.com/topics/16459</link><guid isPermaLink="false">https://studygolang.com/topics/16459</guid><pubDate>Wed, 05 Jul 2023 05:52:29 GMT</pubDate><author>xiaoxiaohuaertwz915</author><category>每日一学</category></item><item><title>程序员内功修炼</title><description>&lt;p&gt;转自刘德北的原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/0uATcNh2VvLLwNQNHVKdHw&quot;&gt;https://mp.weixin.qq.com/s/0uATcNh2VvLLwNQNHVKdHw&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内功修炼视频的目的：&lt;/p&gt;
&lt;p&gt;简短回答：&lt;a href=&quot;https://edu.51cto.com/course/33199.html&quot;&gt;https://edu.51cto.com/course/33199.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;长时间回答：&lt;a href=&quot;https://www.bilibili.com/video/BV1fj411g7yp/?spm_id_from=333.999.0.0&quot;&gt;https://www.bilibili.com/video/BV1fj411g7yp/?spm_id_from=333.999.0.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内功修炼旨在提升程序员构建起完整的【以Linux系统为基】计算机知识体系，掌握几十年不变的核心技术驾驭今天千变万化的应用层达到底层和应用层的融会贯通，对于计算机技术有追求有热情的朋友还是强烈推荐学习的，是窥探计算机所有编程语言的核心。&lt;/p&gt;
&lt;p&gt;应用层：各种软件 ，各种编译器，各种工具，各种WEB 应用软件等都称为应用层。 作者：北风之神xk &lt;a href=&quot;https://www.bilibili.com/read/cv24777404&quot;&gt;https://www.bilibili.com/read/cv24777404&lt;/a&gt; 出处：bilibili&lt;/p&gt;
</description><link>https://studygolang.com/topics/16456</link><guid isPermaLink="false">https://studygolang.com/topics/16456</guid><pubDate>Tue, 04 Jul 2023 08:52:16 GMT</pubDate><author>xiaoxiaohuaer</author><category>每日一学</category></item><item><title>一文带你了解IP被封，如何进行解封</title><description>&lt;p&gt;当你的IP地址被封锁时，可能会导致无法正常访问特定网站或服务。本文将为你提供一些有用的步骤和建议，帮助你解封被封锁的IP地址，恢复正常的网络访问。&lt;/p&gt;
&lt;p&gt;第一步：确认IP被封的原因
1.检查错误信息：当你尝试访问被封锁的网站或服务时，注意是否出现特定的错误信息。这些信息可能提供有关IP被封的线索。
2.检查黑名单或封禁记录：有些服务提供商或网站会维护黑名单或封禁记录，记录了恶意IP地址或违规行为。查找是否你的IP地址出现在这些列表中。
3.联系服务提供商：如果你无法确定IP被封的原因，或者怀疑是由于误封，请联系相关的服务提供商或网站的技术支持，寻求进一步的帮助和解释。&lt;/p&gt;
&lt;p&gt;第二步：采取解封措施
1.确认并纠正违规行为：如果你的IP被封是由于违反了服务提供商的使用政策或规定，确保立即停止相关违规行为，并纠正任何错误。这可以包括停止发送垃圾信息、滥用账户或进行其他违规活动。
2.更新安全软件和清理恶意软件：确保你的设备上安装了最新的安全软件和防病毒程序，并进行全面的系统扫描，清除任何可能存在的恶意软件。
3.更换IP地址：如果你的IP地址被恶意攻击或遭受了持续的封禁，联系你的互联网服务提供商（ISP），请求更换IP地址。
4.请求解封：如果你确认IP被封的原因是误封或你已经采取了纠正措施，可以向服务提供商或网站的技术支持提交解封请求。&lt;/p&gt;
&lt;p&gt;第三步：预防未来封锁
1.遵守使用规则和政策：遵守服务提供商的使用规则和政策，避免从事任何违规活动。阅读并理解相关的使用条款和条件，确保你的行为合法合规。
2.加强网络安全：保持你的设备和网络的安全性，定期更新安全软件和操作系统补丁，使用强密码并避免。&lt;/p&gt;
</description><link>https://studygolang.com/topics/16419</link><guid isPermaLink="false">https://studygolang.com/topics/16419</guid><pubDate>Fri, 16 Jun 2023 05:52:37 GMT</pubDate><author>xiaobei77xiaoyudian</author><category>每日一学</category></item><item><title>国内用 Dubbo 多还是 grpc 的多</title><description>&lt;h2&gt;&lt;strong&gt;国内用 Dubbo 多还是 gRPC 的多？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;gRPC 和 Dubbo 是近几年来，比较火的两款 RPC 的框架，很多人就在问了：在国内，是 Dubbo 用的多还是 gRPC 用的多呢？&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;gRPC&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://apifox.com/apiskills/introduction-to-grpc/&quot;&gt;&lt;strong&gt;gRPC&lt;/strong&gt;&lt;/a&gt; 是一个现代的开源高性能远程过程调用（RPC）框架，可以在任何环境中运行。它可以通过对负载平衡、跟踪、健康检查和身份验证的可插拔支持，有效地连接数据中心内和数据中心之间的服务。它也适用于分布式计算的最后一英里，将设备、移动应用程序和浏览器连接到后端服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61a1e22a974d41f985bc9e491775ffff~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以先去到 github 克隆一个 gRPC 的项目下来并运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https: //github.com/grpc/grpc-java
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着我们使用 maven 去启动项目，且循环 1000000 次。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mvn exec:java -Dexec.mainClass=io.grpc.examples.helloworld.HelloWorldServer
mvn exec:java -Dexec.mainClass=io.grpc.examples.helloworld.HelloWorldClient
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测出来的时间大概为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spend time: 126 can handle 7936 per second
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;strong&gt;Dubbo&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://apifox.com/apiskills/dubbo-protocol-book/&quot;&gt;&lt;strong&gt;Dubbo&lt;/strong&gt;&lt;/a&gt; 是阿里巴巴出品的，是使用 Java 这种编程语言编写的，Dubbo 跟 RPC 的关系就是：Dubbo 是一种 RPC 的框架，一种分布式服务框架，体现在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高性能&lt;/li&gt;
&lt;li&gt;透明化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dubbo 也是一种 SOA 服务的治理方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/440d01db9ea44f88bba76f5eea014cc9~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;而我们对 Dubbo 进行编码，并测试性能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Service(version = &quot;1.0.0&quot;)
public class HelloServiceImpl implements HelloService {

    @Override
    public String SayHello(String name) {
        return &quot;Hello , &quot;+name;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;@RestController

public class HelloController {

    private final Long testScale = 1000000L;

    @Reference(version = &quot;1.0.0&quot;)
    HelloService helloService;

    @GetMapping(&quot;sayHello&quot;)
    public String sayHello( String name){
        name = &quot; world&quot;;
        Long now = Instant.now().getEpochSecond();
        for(int idx = 0; idx &amp;amp;lt; testScale; idx++){
           System.out.println( helloService.SayHello(String.format(&quot;%s:%d&quot;,name,idx)));
        }

        Long duration = Instant.now().getEpochSecond() - now;
        System.out.println(String.format(&quot;can handle %d per second&quot;, testScale/duration));
        return String.format(&quot;can handle %d per second&quot;, testScale/duration);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们进行运行，并查看耗时结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;can handle 12987 per second
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;Dubbo 性能更好，更受欢迎！&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们可以看出，Dubbo 的性能更加的好，且 Dubbo 是阿里巴巴出品，属于国产 RPC 框架，对于国内的开发肯定是更加友好的。&lt;/p&gt;
&lt;h2&gt;知识扩展：&lt;/h2&gt;
&lt;p&gt;了解更多关于 RPC 协议相关知识。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://apifox.com/apiskills/comparison-of-rpc-frameworks/&quot;&gt;分布式 RPC 框架比较：dubbo、dubbox、motan、thrift、grpc&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://apifox.com/apiskills/rpc-remote-interface-call/&quot;&gt;RPC 远程接口调用：详解实现和优化&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><link>https://studygolang.com/topics/16322</link><guid isPermaLink="false">https://studygolang.com/topics/16322</guid><pubDate>Fri, 21 Apr 2023 03:56:25 GMT</pubDate><author>LiamHLIGUANGYAO</author><category>每日一学</category></item><item><title>怎么写一份好的接口文档？</title><description>&lt;p&gt;编写一份优秀的接口文档会让软件开发中变得更加轻松，更有效率。这可是关键任务，写得好不仅可以帮助开发人员更好地理解和使用 API 接口，还可以提高整个团队的协作效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e60064b799c4b0cb50640b0651b625e~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;p&gt;大家可以在线感受一下优秀的接口文档是怎样的：&lt;a href=&quot;https://petstore.apifox.cn/&quot;&gt;https://petstore.apifox.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么我们该如何写好一份优秀的接口文档呢？&lt;/p&gt;
&lt;h2&gt;接口文档结构&lt;/h2&gt;
&lt;p&gt;首先我们要知道文档结构是什么样子的。接口文档应该有清晰明确的结构，以便开发人员能快速定位自己需要的 API 接口信息，同时帮助快速理解。&lt;/p&gt;
&lt;p&gt;一般来说，接口文档应该包括以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口概述&lt;/li&gt;
&lt;li&gt;接口参数&lt;/li&gt;
&lt;li&gt;接口请求和响应示例&lt;/li&gt;
&lt;li&gt;接口返回码&lt;/li&gt;
&lt;li&gt;接口调用方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些内容都包括的话，起码在结构完整性上就已经做得很好了。接下来要将每个细节完善一下。&lt;/p&gt;
&lt;h2&gt;参数说明&lt;/h2&gt;
&lt;p&gt;接口文档应该包括详细的参数说明，以便开发人员更清晰的了解如何正确地使用该 API 接口。每个参数都应该有详细的描述，包括参数名参数的类型、长度限制、默认值、可选值、是否必填和说明等信息。如果参数之间有依赖关系，也需要在文档中进行详细说明。&lt;/p&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;p&gt;示例是接口文档中非常重要的一部分，它可以帮助开发人员快速掌握该 API 接口的数据结构。在接口文档中，应该提供清晰明了的示例，包括接口请求和响应示例，还要包含对应的数据，让 API 接口的使用方法能直观展现 。&lt;/p&gt;
&lt;h2&gt;错误码说明&lt;/h2&gt;
&lt;p&gt;在接口文档中，应该包括详细的错误码说明，以便开发人员能明确知道 API 接口返回的错误码及其含义是什么。每个错误码都应该有详细的描述，包括错误码的含义、出现的原因以及如何解决问题等信息。&lt;/p&gt;
&lt;h2&gt;语言基调通俗易懂&lt;/h2&gt;
&lt;p&gt;接口文档应该使用易于理解的语言编写，以便开发人员能够更好地理解和使用 API 接口。在编写文档时，应该避免使用过于专业化的术语和缩写，如果必须有也可以配合注解，以便读者能够更好地理解。当然，结合团队实际情况来，如果团队里都是大佬，那当我没说。&lt;/p&gt;
&lt;h2&gt;及时更新与维护&lt;/h2&gt;
&lt;p&gt;接口文档应该及时更新和维护，以反映 API 接口的最新变化。开发人员应该定期检查接口文档，确保它们仍然准确并且能够正确地反映 API 接口的最新状态。当然也可以借助工具，比如 Apifox 这种改代码就可以做自动同步到文档的软件来帮助维护更新。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;编写一份优秀的接口文档需要考虑多个方面，包括清晰的结构、详细的参数说明、清晰明了的示例、详细的错误码说明、易于理解的语言以及及时的更新和维护。如果能遵循这些条件，那写出来的接口文档一定非常完美。但同时也要耗费更多的精力，但其实我们完全可以借助工具帮我们解决，比如我上文提到的 Apifox，虽然我最初使用这个软件是因为免费而且界面好看，但是用下来发现功能也是很能打的，而且它有一款 IDEA 插件，能自动解析代码注解生成接口文档，不要太方便好吗哈哈哈哈！文档真的很省心了！接口调试还能 Mock 数据，而且自动化测试做的很好，对于我这种小团队来说协作方便多了，如果你也想解放双手不想写接口文档，可以和我一样用用这个工具！&lt;/p&gt;
&lt;p&gt;希望这个文章对大家有帮助，希望大家都能拥有好的接口文档！&lt;/p&gt;
</description><link>https://studygolang.com/topics/16163</link><guid isPermaLink="false">https://studygolang.com/topics/16163</guid><pubDate>Wed, 22 Feb 2023 08:54:34 GMT</pubDate><author>LiamH</author><category>每日一学</category></item><item><title>一款golang编写的开源的分布式锁 支持redis/zookeeper/etcd 实现</title><description>&lt;h2&gt;distributed-lock&lt;/h2&gt;
&lt;h3&gt;介绍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可以指定redis/etcd/zookeeper实现&lt;/li&gt;
&lt;li&gt;redis的实现使用了lua脚本加解锁、watch机制续约锁、并且参考了redission用频道通知获取锁失败的客户端，减轻了redis的压力&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chuckchann/distributed-lock&quot;&gt;github连接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description><link>https://studygolang.com/topics/16119</link><guid isPermaLink="false">https://studygolang.com/topics/16119</guid><pubDate>Thu, 02 Feb 2023 03:11:52 GMT</pubDate><author>chuckchenAlexAnyang</author><category>每日一学</category></item><item><title>使用ComPDFKit以编程方式编辑PDF文件</title><description>&lt;h2&gt;&lt;strong&gt;导入 PDF 文件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&amp;lt;br&amp;gt;一旦完成集成 ComPDFKit PDF SDK，就可以通过 CPDFDocument 对象打开和显示 PDF 文档。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Get the path of a PDF
string filePath =&quot;&quot;;
var dlg = new OpenFileDialog();
dlg.Filter = &quot;PDF Files (*.pdf)|*.pdf&quot;;
if (dlg.ShowDialog() == true)
{
filePath = dlg.FileName;
}
else
{
return;
}
// Initialize a CPDFDocument object with the path to the PDF file

CPDFDocument document = CPDFDocument.InitWithFilePath(filePath);
if(document==null)
{
return;
}
if(document.ErrorType != CPDFDocumentError.CPDFDocumentErrorSuccess
&amp;amp;amp;&amp;amp;amp; document.ErrorType != CPDFDocumentError.CPDFDocumentPasswordError)
{
return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;编辑PDF&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&amp;lt;br&amp;gt;ComPDFKit包含了成熟完整的PDF功能，包括查看、编辑、注释、填表、转换、安全、编辑、OCR、导航等。在下一节中，我们将介绍如何实现这些功能。如果您对其他功能感兴趣，请阅读相关文档或博客。&lt;/p&gt;
&lt;p&gt;&amp;lt;br&amp;gt;1. 插入 PDF 页面：&lt;/p&gt;
&lt;p&gt;假设您要添加另一个 PDF 文件中的第一个 PDF 页面。并且您想在第一个 PDF 页面之前添加页面。按照此处的代码示例并尝试执行此操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CPDFDocument otherDocument = CPDFDocument.InitWithFilePath(&quot;***&quot;);
document.ImportPagesAtIndex(otherDocument, &quot;0&quot;, 0);
otherDocument.Release();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;br&amp;gt;2. Annotation：添加文字说明&lt;/p&gt;
&lt;p&gt;插入 PDF 页面后，还需要进行其他处理。例如，当一行字可能需要更多细节来解释时，您可以使用文本注释。在这里，您可以找到有关如何添加文本注释的方法。&lt;/p&gt;
&lt;p&gt;&amp;lt;br&amp;gt;3. 注释：突出 PDF 的内容&lt;/p&gt;
&lt;p&gt;现在，您需要突出一些关键字。ComPDFKit 支持执行此操作的常规方法，例如突出显示、下划线、墨水等。以下代码显示了在第 5 页高亮显示所有关键字“Step”的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CPDFPage page = document.PageAtIndex(4);
if (page == null)
    return;

List rects = new List();
CPDFTextPage textPage = page.GetTextPage();
CPDFTextSearcher searcher = new CPDFTextSearcher();
int findIndex = 0;

if (searcher.FindStart(textPage, &quot;Step&quot;, C_Search_Options.Search_Case_Sensitive, findIndex))
{
    CRect textRect = new CRect();
    string textContent = &quot;&quot;;
    while (searcher.FindNext(page, textPage, ref textRect, ref textContent, ref findIndex))
    {
        rects.Add(textRect);
    }
}
searcher.FindClose();

CPDFHighlightAnnotation highlight = page.CreateAnnot(C_ANNOTATION_TYPE.C_ANNOTATION_HIGHLIGHT) as CPDFHighlightAnnotation;
byte[] color = { 0, 255, 0 };
highlight.SetColor(color);
highlight.SetTransparency(120);
highlight.SetQuardRects(rects);
highlight.UpdateAp();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;br&amp;gt;4. 保存所做的更改&lt;/p&gt;
&lt;p&gt;完成所有更改后，我们可以保存它并完成我们的使用。这是将您所做的所有更改保存在新 PDF 文件中的代码方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.WriteToFilePath(&quot;newFilePath&quot;);
document.Release();
&lt;/code&gt;&lt;/pre&gt;
</description><link>https://studygolang.com/topics/15986</link><guid isPermaLink="false">https://studygolang.com/topics/15986</guid><pubDate>Wed, 23 Nov 2022 03:32:36 GMT</pubDate><author>ComPDFKit</author><category>每日一学</category></item><item><title>WGCLOUD监控的服务端和被监控的服务器可以不在一个网段吗</title><description>&lt;p&gt;&lt;strong&gt;可以的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只要被监控主机能ping通服务端server主机的网络就行，
服务端server不需要ping通被监控主机的网络&lt;/p&gt;
&lt;p&gt;因为WGCLOUD架构是agent单向给server上报数据
server不会访问agent&lt;/p&gt;
</description><link>https://studygolang.com/topics/15766</link><guid isPermaLink="false">https://studygolang.com/topics/15766</guid><pubDate>Sat, 20 Aug 2022 13:07:50 GMT</pubDate><author>tianshiyeben</author><category>每日一学</category></item><item><title>安卓快速集成即时通聊天APP，只需几行代码轻松实现</title><description>&lt;p&gt;信贸通即时通讯系统，一款跨平台可定制的Go语言开发的即时通信系统，为电子商务网站及各行业门户网站和企事业单位提供“一站式”定制解决方案，打造一个稳定，安全，高效，可扩展的即时通信系统，支持在线聊天、视频/语音对话、点对点断点续传文件、自定义皮肤等。软件能真正无缝与电子商务网站整合，有效提高工作效率，节约成本。同时可根据用户的需求进行二次开发,并提供与其他软件整合或嵌入方案。 本文主要介绍如何在自己的已有安卓项目中，快速的集成即时通讯聊天功能，轻松的实现好友聊天，群组聊天，朋友圈等等社交软件的功能。 当然，您的项目刚开始，那更方便直接可以找官方定制开发，可以节省更多的开发时间和开发成本。&lt;/p&gt;
&lt;p&gt;安卓客户端快速集成即时通聊天如下&lt;/p&gt;
&lt;p&gt;第一步：将jar包复制到项目的libs目录中&lt;/p&gt;
&lt;p&gt;第二步：添加类库依赖&lt;/p&gt;
&lt;p&gt;dependencies { implementation project(path: &#39;:wpimapp&#39;) }&lt;/p&gt;
&lt;p&gt;第三步：添加代码（用户登录和获取用户资料）
//一行代码登录并获取当前用户资料
WpimEmbedded.getInstance(this) .setHost(&quot;服务器地址&quot;) .login(&quot;账号&quot;,Security.md5(&quot;密码&quot;)) .getUserInfo(user-&amp;gt;{
//登录成功,user为获取到的用户资料
});&lt;/p&gt;
&lt;p&gt;第四步：使用其他功能 开始私聊/群聊
//跳转到私聊界面
WpimEmbedded.getInstance(this).gotoBuddyChat(私聊号码,this);&lt;/p&gt;
&lt;p&gt;//开始群聊：
WpimEmbedded.getInstance(this).gotoCommunityChat(群组ID,this);&lt;/p&gt;
&lt;p&gt;只需几行代码，可以实现丰富多样的功能，更多可以自行官网了解。​&lt;/p&gt;
</description><link>https://studygolang.com/topics/15577</link><guid isPermaLink="false">https://studygolang.com/topics/15577</guid><pubDate>Tue, 07 Jun 2022 06:54:28 GMT</pubDate><author>semot926</author><category>每日一学</category></item><item><title>「WGCLOUD」的agent可以设置开机自动启动吗</title><description>&lt;p&gt;我想你应该问的是windows下的agent如何设置开机自动启动吧&lt;/p&gt;
&lt;p&gt;查看如下agent注册windows服务说明&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wgstart.com/help/docs32.html&quot;&gt;https://wgstart.com/help/docs32.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果是server想设置开机自动启动也可以，如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wgstart.com/help/docs49.html&quot;&gt;https://wgstart.com/help/docs49.html&lt;/a&gt;&lt;/p&gt;
</description><link>https://studygolang.com/topics/15525</link><guid isPermaLink="false">https://studygolang.com/topics/15525</guid><pubDate>Wed, 25 May 2022 01:16:57 GMT</pubDate><author>tianshiyeben</author><category>每日一学</category></item><item><title>goweb 框架选择</title><description>&lt;p&gt;接触到的go web框架如下 gin、 beego、goframe、echo四种。
个人感受如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;beego 功能齐全，但是在orm和route上限制比较大。 规模比较小的站点足够使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gin   过于灵活，go orm功能不够强，没有特别方便的辅助开发的脚手架功能。个人开发api的首选&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;echo 简单接触，未深入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;goframe 功能齐全，针对传统web开发的orm和路由功能足够使用。对团队来说不需要额外限制组件使用等。直接用gf的组件即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;学习难度比较：&lt;/p&gt;
&lt;p&gt;四个相差并不大。&lt;/p&gt;
</description><link>https://studygolang.com/topics/15437</link><guid isPermaLink="false">https://studygolang.com/topics/15437</guid><pubDate>Tue, 26 Apr 2022 07:30:01 GMT</pubDate><author>morimokiEddyLee1010</author><category>每日一学</category></item><item><title>如何优雅的做单元测试</title><description>&lt;h1&gt;单元测试&lt;/h1&gt;
&lt;p&gt;单测中最多的还是函数级别的测试，用于验证功能逻辑的正确性。但是很多时候我们需要走一些完整的流程测试，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口测试
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;client side&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server side&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据库测试&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;接口测试&lt;/h2&gt;
&lt;h3&gt;client side&lt;/h3&gt;
&lt;p&gt;作为客户端，基本都需要与后端服务进行交互，这时候需要关注两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;后台服务返回正常数据，客户端本身是否存在逻辑问题&lt;/li&gt;
&lt;li&gt;后台服务异常返回，客户端本身能否处理各种异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结一下，核心点在于在单测中具有修改&lt;code&gt;server&lt;/code&gt;的能力！！！这个问题有两个解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本地构造&lt;code&gt;fake server&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据异常场景构建多个后端测试&lt;code&gt;server&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;构建多个用于测试的&lt;code&gt;server&lt;/code&gt;，成本较高，资源不容易管理。幸运的是&lt;code&gt;go&lt;/code&gt;本身具有构造&lt;a href=&quot;https://golang.org/pkg/net/http/httptest/#example_Server&quot;&gt;&lt;code&gt;fake server&lt;/code&gt;&lt;/a&gt;的能力。&lt;/p&gt;
&lt;p&gt;注意接口设计！！！传送门中的例子仅仅是为了演示用法，在项目开发中，请时刻将依赖注入刻在心中。下面是一个构造的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package thttp

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
)

func BaiduRPC(url string, header http.Header) error {
    req, err := http.NewRequest(http.MethodGet, url, nil)
    if err != nil {
        return err
    }
    req.Header = header

    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return err
    }

    if resp.StatusCode != 200 {
        return fmt.Errorf(&quot;request failed&quot;)
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package thttp

import (
    &quot;net/http&quot;
    &quot;net/http/httptest&quot;
    &quot;strings&quot;
    &quot;testing&quot;

    &quot;github.com/stretchr/testify/assert&quot;
)

func TestBaiduRPC(t *testing.T) {

    users := map[string]struct{}{
        &quot;litianxiang01&quot;: struct{}{},
    }
    fs := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        if r.Header == nil {
            r.Header = http.Header{}
        }
        uid := strings.ToLower(r.Header.Get(&quot;uid&quot;))
        if len(uid) == 0 {
            w.WriteHeader(http.StatusBadRequest)
            return
        }

        _, exist := users[uid]
        if exist {
            w.WriteHeader(http.StatusOK)
        } else {
            w.WriteHeader(http.StatusNotFound)
        }
    }))

    cases := []struct {
        in   string
        want bool
    }{
        {&quot;litianxiang01&quot;, true},
        {&quot;default&quot;, false},
        {&quot;&quot;, false},
    }

    backend := fs.URL
    for _, item := range cases {
        header := make(http.Header)
        header.Add(&quot;uid&quot;, item.in)

        out := BaiduRPC(backend, header)
        assert.Equalf(t, item.want, out == nil, &quot;%s is unexpected&quot;, item.in)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述例子中的输入和输出都是预期的，因此三个case都会通过测试，显示如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;=== RUN   TestBaiduRPC
--- PASS: TestBaiduRPC (0.00s)
PASS
ok      testify/demo/test/thttp    0.005s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果把&lt;code&gt;test&lt;/code&gt;文件中&lt;code&gt;cases&lt;/code&gt;里的&lt;code&gt;default&lt;/code&gt;的第二个参数修改为true，这时候后端的处理就不符合预期了（后端有bug了），这时&lt;code&gt;testify&lt;/code&gt;框架也会提供友好的输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;=== RUN   TestBaiduRPC
    client_test.go:50:
            Error Trace:    client_test.go:50
            Error:          Not equal:
                            expected: true
                            actual  : false
            Test:           TestBaiduRPC
            Messages:       default is unexpected
--- FAIL: TestBaiduRPC (0.00s)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;server side&lt;/h3&gt;
&lt;p&gt;作为服务端，无论如何都需要处理客户端发送的请求，这时候需要关注两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端按要求发送数据，服务端本身是否存在逻辑问题&lt;/li&gt;
&lt;li&gt;客户端发送非法数据，服务端本身能否处理各种异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结一下，核心点在于构造输入，而与是否存在真实的客户端没有关系！&lt;/p&gt;
&lt;p&gt;问题的解决方案就是构造各种异常输入，但是手动构造存在几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对标准库了解不足，构造请求参数存在遗漏&lt;/li&gt;
&lt;li&gt;熟悉标准库，但是构造麻烦&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何避免上述问题的发生？那么用&lt;a href=&quot;https://golang.org/pkg/net/http/httptest/#example_ResponseRecorder&quot;&gt;它&lt;/a&gt;吧！用&lt;a href=&quot;https://golang.org/pkg/net/http/httptest/#example_ResponseRecorder&quot;&gt;它&lt;/a&gt;吧！用&lt;a href=&quot;https://golang.org/pkg/net/http/httptest/#example_ResponseRecorder&quot;&gt;它&lt;/a&gt;吧！&lt;/p&gt;
&lt;p&gt;下面是对&lt;code&gt;client side&lt;/code&gt;章节提供的例子的一次改写，改写为&lt;code&gt;server side&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package thttp

import (
    &quot;net/http&quot;
    &quot;strings&quot;
)

var (
    users = map[string]struct{}{
        &quot;litianxiang01&quot;: struct{}{},
    }
)

func API(w http.ResponseWriter, r *http.Request) {
    if r.Header == nil {
        r.Header = http.Header{}
    }
    uid := strings.ToLower(r.Header.Get(&quot;uid&quot;))
    if len(uid) == 0 {
        w.WriteHeader(http.StatusBadRequest)
        return
    }

    _, exist := users[uid]
    if exist {
        w.WriteHeader(http.StatusOK)
    } else {
        w.WriteHeader(http.StatusNotFound)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package thttp

import (
    &quot;net/http&quot;
    &quot;net/http/httptest&quot;
    &quot;testing&quot;

    &quot;github.com/stretchr/testify/assert&quot;
)

func TestAPI(t *testing.T) {
    cases := []struct {
        in   string
        want bool
    }{
        {&quot;litianxiang01&quot;, true},
        {&quot;default&quot;, false},
        {&quot;&quot;, false},
    }

    for _, item := range cases {
        header := make(http.Header)
        header.Add(&quot;uid&quot;, item.in)

        r := httptest.NewRequest(http.MethodGet, &quot;/&quot;, nil)
        r.Header = header
        w := httptest.NewRecorder()

        API(w, r)

        assert.Equalf(t, item.want, w.Code == http.StatusOK, &quot;%s is unexpected&quot;, item.in)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;数据库测试&lt;/h2&gt;
&lt;p&gt;&amp;gt; 本章节内容不仅仅是面向数据库，而仅仅是借助数据库来说明如何mock一些依赖的第三方中间组件。&lt;/p&gt;
&lt;p&gt;在软件的生命周期中有一些原则需要遵守：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向接口编程&lt;/li&gt;
&lt;li&gt;依赖注入&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;面向接口编程&lt;/h3&gt;
&lt;p&gt;在学习的过程你可能会经常看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向过程&lt;/li&gt;
&lt;li&gt;面向对象&lt;/li&gt;
&lt;li&gt;面向接口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面向对象和面向过程属于同一个维度，两者的本质在于如何分析问题。而面向接口属于更上层的概念，它是指导如何应对变化的一种思想。&lt;/p&gt;
&lt;p&gt;对于单元测试来说，变化指的就是替换，而替换恰恰是&lt;code&gt;mock&lt;/code&gt;的本质，所以面向接口编程是为了将来可以使用一个假的替换一个真的来达到同样的功能效果。&lt;/p&gt;
&lt;p&gt;既然需要使用假的替代真的，那么就需要有一个假的。你可以使用硬编码一个实现了接口的实例来达到效果，不过这样做有点“过于简单”，社区常见的一种方式是使用代码生成工具，推荐一个官方的&lt;code&gt;mock&lt;/code&gt;工具&lt;a href=&quot;https://github.com/golang/mock&quot;&gt;&lt;code&gt;mockgen&lt;/code&gt;&lt;/a&gt;，配合&lt;a href=&quot;https://github.com/golang/mock&quot;&gt;&lt;code&gt;golang/mock&lt;/code&gt;&lt;/a&gt;，配合&lt;a href=&quot;https://github.com/golang/mock&quot;&gt;&lt;code&gt;golang/mock&lt;/code&gt;&lt;/a&gt;使用。&lt;/p&gt;
&lt;p&gt;通过一个简单的例子来大概的介绍一下使用方式，源文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package db

type DB interface {
    Get(string) ([]byte, error)
    Put(string, []byte) error
    Del(string) error
}

func GetFromDB(db DB, key string) ([]byte, error) {
    return db.Get(key)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;mockgen&lt;/code&gt;生成代码（&lt;code&gt;mockgen -source=db.go -destination=mock_db_test.go -package=db_test&lt;/code&gt;）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Code generated by MockGen. DO NOT EDIT.
// Source: db.go

// Package db_test is a generated GoMock package.
package db_test

import (
    reflect &quot;reflect&quot;

    gomock &quot;github.com/golang/mock/gomock&quot;
)

// MockDB is a mock of DB interface.
type MockDB struct {
    ctrl     *gomock.Controller
    recorder *MockDBMockRecorder
}

// MockDBMockRecorder is the mock recorder for MockDB.
type MockDBMockRecorder struct {
    mock *MockDB
}

// NewMockDB creates a new mock instance.
func NewMockDB(ctrl *gomock.Controller) *MockDB {
    mock := &amp;amp;amp;MockDB{ctrl: ctrl}
    mock.recorder = &amp;amp;amp;MockDBMockRecorder{mock}
    return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDB) EXPECT() *MockDBMockRecorder {
    return m.recorder
}

// Del mocks base method.
func (m *MockDB) Del(arg0 string) error {
    m.ctrl.T.Helper()
    ret := m.ctrl.Call(m, &quot;Del&quot;, arg0)
    ret0, _ := ret[0].(error)
    return ret0
}

// Del indicates an expected call of Del.
func (mr *MockDBMockRecorder) Del(arg0 interface{}) *gomock.Call {
    mr.mock.ctrl.T.Helper()
    return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, &quot;Del&quot;, reflect.TypeOf((*MockDB)(nil).Del), arg0)
}

// Get mocks base method.
func (m *MockDB) Get(arg0 string) ([]byte, error) {
    m.ctrl.T.Helper()
    ret := m.ctrl.Call(m, &quot;Get&quot;, arg0)
    ret0, _ := ret[0].([]byte)
    ret1, _ := ret[1].(error)
    return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockDBMockRecorder) Get(arg0 interface{}) *gomock.Call {
    mr.mock.ctrl.T.Helper()
    return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, &quot;Get&quot;, reflect.TypeOf((*MockDB)(nil).Get), arg0)
}

// Put mocks base method.
func (m *MockDB) Put(arg0 string, arg1 []byte) error {
    m.ctrl.T.Helper()
    ret := m.ctrl.Call(m, &quot;Put&quot;, arg0, arg1)
    ret0, _ := ret[0].(error)
    return ret0
}

// Put indicates an expected call of Put.
func (mr *MockDBMockRecorder) Put(arg0, arg1 interface{}) *gomock.Call {
    mr.mock.ctrl.T.Helper()
    return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, &quot;Put&quot;, reflect.TypeOf((*MockDB)(nil).Put), arg0, arg1)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写单元测试：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package db_test

import (
    &quot;demo/db&quot;
    &quot;fmt&quot;
    &quot;testing&quot;

    &quot;github.com/golang/mock/gomock&quot;
)

func TestGet(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()

    dbi := NewMockDB(ctrl)
    opt1 := dbi.EXPECT().Get(gomock.Eq(&quot;key1&quot;)).Return(nil, fmt.Errorf(&quot;not found&quot;))
    opt2 := dbi.EXPECT().Get(gomock.Eq(&quot;key2&quot;)).Return([]byte(&quot;vales&quot;), nil)
    gomock.InOrder(opt1, opt2)

    db.GetFromDB(dbi, &quot;key1&quot;)
    db.GetFromDB(dbi, &quot;key2&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;依赖注入&lt;/h3&gt;
&lt;p&gt;依赖注入，控制反转...这些词你可能经常听到，但是可能对它只是有所耳闻，没关系，下面通过例子来阐述为什么会有这玩意，然后你就知道这玩意是做什么的了。&lt;/p&gt;
&lt;p&gt;回到之前数据库&lt;code&gt;mock&lt;/code&gt;的章节中，当时通过接口抽象一个简单的&lt;code&gt;kv&lt;/code&gt;模型，真正的读取方法是&lt;code&gt;func Get(db DB, key string) (value []byte, err error)&lt;/code&gt;，乍一看这个函数原型，设计的真恶心，我读取数据居然还需要穿一个&lt;code&gt;db&lt;/code&gt;实例进去，设计成&lt;code&gt;func Get(key string) (value []byte, err error)&lt;/code&gt;不是对上层更友好吗？是的！确实是对上层友好。但是：&lt;/p&gt;
&lt;p&gt;&amp;gt; 被mock通常是一些infra structure，对它们进行单测毫无意义，单测的对象应该是依赖infra structure的对象。&lt;/p&gt;
&lt;p&gt;比如作为一个&lt;code&gt;api server&lt;/code&gt;，可以将业务分层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;controller：接口层&lt;/li&gt;
&lt;li&gt;service：业务层&lt;/li&gt;
&lt;li&gt;db：数据层&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;controller&lt;/code&gt;属于&lt;code&gt;server side&lt;/code&gt;的范畴，在最开始就进行了阐述。&lt;code&gt;db&lt;/code&gt;是组件，不掺杂逻辑，正常情况下&lt;code&gt;crud&lt;/code&gt;语句是对的就没有错误。因此侧重点在于测试&lt;code&gt;service&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于一些简单的业务逻辑，人们很容易采用面向过程的方式，直接将需求按步骤翻译成代码，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// controller
func Exist(w http.ResponseWriter, r *http.Request) {
    // 获取输入
  // 验证参数的合理性
  // 访问service
  // 处理返回的结果
}

// service
func Exist(w http.ResponseWriter, r *http.Request) {
  // 获取输入
  // 访问db
  // 处理返回结果
}

// db
var db *sql.DB
func init() {
  // 初始化，获取实例
  d, err := dial()
  if err != nil {
    panic(err)
  }
  // 赋值db
  db = d
}

func Get(key string) ([]byte, error) {
  row, err := db.QueryRow(&quot;select name from users where id = ?&quot;, key)
  if err != nil {
    return nil, err
  }

  var name string
  err = row.Scan(&amp;amp;amp;name)
  if err != nil {
    return nil, err
  }
  if err := row.Err(); err != nil {
    return nil, err
  }
  return []byte(name), nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写代码的时候很迅速，不需要考虑，但是它存在两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;service&lt;/code&gt;无法对&lt;code&gt;db&lt;/code&gt;层&lt;code&gt;mock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;业务与&lt;code&gt;db&lt;/code&gt;强耦合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决以上两个问题，推荐方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package service

import &quot;demo/db&quot;

type UserService struct {
    db db.DB
}

// 这就是控制反转，实现控制反转的方案是依赖注入
func NewUserService(databse db.DB) *UserService {
    return &amp;amp;amp;UserService{
        db: databse,
    }
}

func (us *UserService) Exist(id string) (ok bool, err error) {
    v, err := us.db.Get(id)
    if err != nil {
        return
    }
    if len(v) == 0 {
        return false, nil
    }
    return true, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;为什么叫控制反转：
&lt;ul&gt;
&lt;li&gt;before：&lt;code&gt;service&lt;/code&gt;层没有&lt;code&gt;db&lt;/code&gt;初始化的控制权&lt;/li&gt;
&lt;li&gt;after：&lt;code&gt;service&lt;/code&gt;层拥有&lt;code&gt;db&lt;/code&gt;初始化的控制权&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;依赖注入如何实现：
&lt;ul&gt;
&lt;li&gt;before：在&lt;code&gt;db&lt;/code&gt;层硬编码依赖的实现&lt;/li&gt;
&lt;li&gt;after：在&lt;code&gt;service&lt;/code&gt;层初始化依赖的抽象，在需要的地方注入依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样既能很大程度的保证切换底层存储引擎时代码的兼容性，也方便了对业务逻辑进行单测。&lt;/p&gt;
&lt;h2&gt;集成测试&lt;/h2&gt;
&lt;p&gt;很多时候你无法&lt;code&gt;mock&lt;/code&gt;中间件，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;老旧代码，重构成本高&lt;/li&gt;
&lt;li&gt;验证使用中间件的方式（命令是否正确）&lt;/li&gt;
&lt;li&gt;端到端的测试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有没有什么比较好的解决方案呢？当然是有的！使用容器来搭建搭建你需要的测试环境。&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/multi-container-microservice-net-applications/multi-container-applications-docker-compose&quot;&gt;使用 docker-compose.yml 定义多容器应用程序&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;go test&lt;/h2&gt;
&lt;h3&gt;mode&lt;/h3&gt;
&lt;p&gt;&amp;gt; Go test runs in two different modes:
&amp;gt;
&amp;gt; The first, called local directory mode, occurs when go test is invoked with no package arguments (for example, &#39;go test&#39; or &#39;go test -v&#39;). In this mode, go test compiles the package sources and tests found in the current directory and then runs the resulting test binary. In this mode, caching (discussed below) is disabled. After the package test finishes, go test prints a summary line showing the test status (&#39;ok&#39; or &#39;FAIL&#39;), package name, and elapsed time.
&amp;gt;
&amp;gt; The second, called package list mode, occurs when go test is invoked with explicit package arguments (for example &#39;go test math&#39;, &#39;go test ./...&#39;, and even &#39;go test .&#39;). In this mode, go test compiles and tests each of the packages listed on the command line. If a package test passes, go test prints only the final &#39;ok&#39; summary line. If a package test fails, go test prints the full test output. If invoked with the -bench or -v flag, go test prints the full output even for passing package tests, in order to display the requested benchmark results or verbose logging. After the package tests for all of the listed packages finish, and their output is printed, go test prints a final &#39;FAIL&#39; status if any package test has failed.
&amp;gt;
&amp;gt; In package list mode only, go test caches successful package test results to avoid unnecessary repeated running of tests. When the result of a test can be recovered from the cache, go test will redisplay the previous output instead of running the test binary again. When this happens, go test prints &#39;(cached)&#39; in place of the elapsed time in the summary line.
&amp;gt;
&amp;gt; The rule for a match in the cache is that the run involves the same test binary and the flags on the command line come entirely from a restricted set of &#39;cacheable&#39; test flags, defined as -cpu, -list, -parallel, -run, -short, and -v. If a run of go test has any test or non-test flags outside this set, the result is not cached. To disable test caching, use any test flag or argument other than the cacheable flags. The idiomatic way to disable test caching explicitly is to use -count=1. Tests that open files within the package&#39;s source root (usually $GOPATH) or that consult environment variables only match future runs in which the files and environment variables are unchanged. A cached test result is treated as executing in no time at all, so a successful package test result will be cached and reused regardless of -timeout setting.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;go test&lt;/code&gt;有两种运行模式：&lt;/p&gt;
&lt;p&gt;第一种叫做&lt;code&gt;local directory mode&lt;/code&gt;，它指的是当你没有传递任何&lt;code&gt;package&lt;/code&gt;的参数给到&lt;code&gt;go test&lt;/code&gt;命令时，比如&lt;code&gt;go test&lt;/code&gt;或者&lt;code&gt;go test -v&lt;/code&gt;。在这种模式下，&lt;code&gt;go test&lt;/code&gt;编译当前目录下的源文件和单测文件生成用于测试的二进制程序并运行它。此时是没有任何缓存能力的，在所有的单测结束后，&lt;code&gt;go test&lt;/code&gt;打印一行总结性的内容，比如测试状态，包名和花费的时间。&lt;/p&gt;
&lt;p&gt;第二种叫做&lt;code&gt;package list mode&lt;/code&gt;，它指的是当你传递一个明确的&lt;code&gt;package&lt;/code&gt;参数给到&lt;code&gt;go test&lt;/code&gt;命令时，比如&lt;code&gt;go test math&lt;/code&gt;，&lt;code&gt;go test ./...&lt;/code&gt;甚至是&lt;code&gt;go test .&lt;/code&gt;。在这种模式下，&lt;code&gt;go test&lt;/code&gt;编译并且测试命令行中指定的每一个包。如果一个包测试通过，只会在最后打印&lt;code&gt;ok&lt;/code&gt;之类总结性的内容。如果一个包测试失败，那么会答应所有测试的输出。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;package list mode&lt;/code&gt;下，会出现&lt;code&gt;cache&lt;/code&gt;，保存测试成功的&lt;code&gt;TestCase&lt;/code&gt;，再次测试时，如果是之前成功的&lt;code&gt;TestCase&lt;/code&gt;，那么将不会再次执行，而是会返回&lt;code&gt;cache&lt;/code&gt;的结果！！！&lt;/p&gt;
&lt;p&gt;有些时候，&lt;code&gt;cache&lt;/code&gt;并不符合预期，比如你对之前成功的&lt;code&gt;TestCase&lt;/code&gt;做了修改，但是重新运行时没有重新执行，而是直接根据&lt;code&gt;cache&lt;/code&gt;结果返回了成功，这种场景有很大的风险，因为你可能是修改的逻辑，又或者会引发运行时异常，因此需要掌握避免&lt;code&gt;cache&lt;/code&gt;的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在执行&lt;code&gt;go test&lt;/code&gt;时添加&lt;code&gt;--count=1&lt;/code&gt;的参数来显示的禁用缓存&lt;/li&gt;
&lt;li&gt;在测试前执行&lt;code&gt;go clean testcache&lt;/code&gt;用于删除缓存&lt;/li&gt;
&lt;li&gt;设置&lt;code&gt;GOCACHE&lt;/code&gt;环境变量的值，这个值的含义是缓存的路径，当设置为&lt;code&gt;off&lt;/code&gt;时表示禁用缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最推荐的是方式一，配合运行指定的测试集可以将发挥最好的性能得到最好的结果。&lt;/p&gt;
&lt;h3&gt;TestMain&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TestMain&lt;/code&gt;是单元测试中的主函数，有了主函数就相当于有了控制权，可以决定单测的整个流程。&lt;/p&gt;
&lt;p&gt;为什么提供这样的能力？因为很多时候会对单测有一些特殊的要求，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源初始化&lt;/li&gt;
&lt;li&gt;资源回收&lt;/li&gt;
&lt;li&gt;指定测试的顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;setup&lt;/h4&gt;
&lt;p&gt;在单测开始前做一些初始化操作。&lt;/p&gt;
&lt;h4&gt;teardown&lt;/h4&gt;
&lt;p&gt;在单测结束后做一些清理的操作。&lt;/p&gt;
&lt;h4&gt;example&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package service_test

import (
    &quot;os&quot;
    &quot;testing&quot;
)

func TestUserExist(t *testing.T) {
    // setup code
    t.Run(&quot;exist_1&quot;, func(t *testing.T) {})
    t.Run(&quot;exist_2&quot;, func(t *testing.T) {})
    t.Run(&quot;exist_3&quot;, func(t *testing.T) {})
    // teardown code
}

func TestMain(m *testing.M) {
    // setup code
    code := m.Run()
    // teardown code
    os.Exit(code)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;表驱动测试&lt;/h3&gt;
&lt;p&gt;其实就是某个场景下所有的&lt;code&gt;case&lt;/code&gt;的“输入输出”写入到一个表中，然后迭代表，对每个输入进行处理，对比是否符合输出。&lt;/p&gt;
&lt;h3&gt;指定测试集&lt;/h3&gt;
&lt;p&gt;很多时候不需要测试全部的&lt;code&gt;TestCase&lt;/code&gt;，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试新加的一个功能接口&lt;/li&gt;
&lt;li&gt;验证某一个函数级别的&lt;code&gt;bugfix&lt;/code&gt;是否生效&lt;/li&gt;
&lt;li&gt;运行某一类单元测试（比如不同的类命名有规则）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总而言之就是不需要全部测试，针对于这样的需求，可以在运行单元测试的同时使用特定的&lt;code&gt;flag&lt;/code&gt;来完成，&lt;code&gt;go test -run regexp pkg&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;附录&lt;/h2&gt;
&lt;h3&gt;依赖注入&lt;/h3&gt;
&lt;p&gt;由于单元测试需要依赖依赖注入的能力，而在一个复杂的项目中，可能一个实例有很多的依赖，这时候写初始化代码也会成为开发者的负担，为此&lt;code&gt;go&lt;/code&gt;官方也提供了响应的依赖注入框架解决，通过代码生成的方式去省去写初始化代码的成本。这里推荐&lt;a href=&quot;https://github.com/google/wire&quot;&gt;wire&lt;/a&gt;。&lt;/p&gt;
</description><link>https://studygolang.com/topics/14286</link><guid isPermaLink="false">https://studygolang.com/topics/14286</guid><pubDate>Thu, 09 Sep 2021 08:20:11 GMT</pubDate><author>Saner-Lee</author><category>每日一学</category></item><item><title>关于context这里一定有你不知道的细节</title><description>&lt;h1&gt;context最佳实践&lt;/h1&gt;
&lt;p&gt;本内容来源于作者的学习笔记，&lt;a href=&quot;https://github.com/Saner-Lee/note&quot;&gt;地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Saner-Lee/redigosrv&quot;&gt;redis server很好用，不是redis client&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Saner-Lee/backup-request&quot;&gt;长尾真的很好解决&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我记得当时大学时学习谭浩强老师的&lt;code&gt;C&lt;/code&gt;语言时有一句话，&lt;code&gt;C&lt;/code&gt;语言程序的最小组成单位是函数。而在&lt;code&gt;golang&lt;/code&gt;中提到函数第一反应就是&lt;code&gt;error&lt;/code&gt;，其次就是&lt;code&gt;context&lt;/code&gt;。为什么这么说呢？无论&lt;code&gt;BS&lt;/code&gt;还是&lt;code&gt;CS&lt;/code&gt;都需要网络交互，而且在&lt;code&gt;golang&lt;/code&gt;中有着天然的并发性，因此如何去管控链路上的每个节点，以及子节点如何感知链路上的事件尤为重要。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;golang&lt;/code&gt;采用树结构来描述链路，在树上传递事件，该事件用来表述父节点已经终止对任务的处理了，子节点的存在是为了辅助父节点完成任务，因此当子节点接收到事件后应当终止任务的执行。&lt;/p&gt;
&lt;h2&gt;你了解context树的动作吗&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;context.Context&lt;/code&gt;是一个接口，而且它的实现类型都有一个匿名的&lt;code&gt;context.Context&lt;/code&gt;成员，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type cancelCtx struct {
	Context

	mu       sync.Mutex            // protects following fields
	done     chan struct{}         // created lazily, closed by first cancel call
	children map[canceler]struct{} // set to nil by the first cancel call
	err      error                 // set to non-nil by the first cancel call
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于匿名成员的特性，因此就算&lt;code&gt;cancelCtx&lt;/code&gt;没有定义任何方法，那么它也已经实现了&lt;code&gt;context.Contetx&lt;/code&gt;接口。其实&lt;code&gt;cancelCtx&lt;/code&gt;（&lt;code&gt;WithCancel&lt;/code&gt;，&lt;code&gt;WithTimeout&lt;/code&gt;和&lt;code&gt;WithDeadline&lt;/code&gt;的底层依赖，至于为什么后面会提到），&lt;code&gt;timerCtx&lt;/code&gt;（&lt;code&gt;WithTimeout&lt;/code&gt;和&lt;code&gt;WithDeadline&lt;/code&gt;的底层实现），&lt;code&gt;valueCtx&lt;/code&gt;（&lt;code&gt;WithValue&lt;/code&gt;的底层实现）都没有全部自己实现&lt;code&gt;context.Context&lt;/code&gt;中的全部方法，都使用到了上面说到的匿名成员的特性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://studygolang.com/topics/%22https://github.com/Saner-Lee/note/blob/master/go/standard%20library/context.md%22&quot;&gt;here&lt;/a&gt;是一篇源码分析，里面给出了每个成员的实现，这里给出结果。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Deadline&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;th&gt;Done&lt;/th&gt;
&lt;th&gt;Err&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;根节点&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cancelCtx&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;timerCtx&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;valueCtx&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;除了上面这个表格，你还需要知道关于每个节点的一些细节：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根节点的所有方法返回值都是返回参数的零值&lt;/li&gt;
&lt;li&gt;当对节点&lt;code&gt;X&lt;/code&gt;执行&lt;code&gt;cancel&lt;/code&gt;方法时
&lt;ol&gt;
&lt;li&gt;以&lt;code&gt;X&lt;/code&gt;节点为根的整棵树脱离&lt;code&gt;context&lt;/code&gt;树&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;X&lt;/code&gt;节点为根的整棵树上所有的&lt;code&gt;&quot;cancelCtx&quot;&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;通道都会被关闭&lt;/li&gt;
&lt;li&gt;&lt;code&gt;err&lt;/code&gt;都会被赋值&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;X&lt;/code&gt;节点为根的整棵树上所有的节点&lt;code&gt;Done&lt;/code&gt;方法会立即接受到事件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timerCtx&lt;/code&gt;本质上个还是&lt;code&gt;cancelCtx&lt;/code&gt;，通过&lt;code&gt;goroutine&lt;/code&gt;自动调用&lt;code&gt;cancel&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在创建&lt;code&gt;timerCtx&lt;/code&gt;的时候，如果指定的时间小于等于当前父节点&lt;code&gt;Deadline&lt;/code&gt;结果则会转变为&lt;code&gt;cancelCtx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;只要调用&lt;code&gt;WithValue&lt;/code&gt;就会生成一个&lt;code&gt;valueCtx&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在知道了这些细节和上述表格后你就能解决使用&lt;code&gt;context&lt;/code&gt;的所有疑问。&lt;/p&gt;
&lt;h2&gt;最佳实践&lt;/h2&gt;
&lt;h3&gt;nil context&lt;/h3&gt;
&lt;p&gt;要求：不要将&lt;code&gt;nil&lt;/code&gt;赋值给&lt;code&gt;context.Context&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;原因：有些标准库和第三方库内部在识别&lt;code&gt;context&lt;/code&gt;为&lt;code&gt;nil&lt;/code&gt;的时候会直接&lt;code&gt;panic&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;key的选择&lt;/h3&gt;
&lt;p&gt;要求：不要使用内置类型，使用自定义私有类型。&lt;/p&gt;
&lt;p&gt;推荐：&lt;code&gt;type $key struct{}&lt;/code&gt;，节省内存，方便扩展。&lt;/p&gt;
&lt;p&gt;原因：细节5可能会导致树中的&lt;code&gt;valueCtx&lt;/code&gt;可能有相同的&lt;code&gt;key&lt;/code&gt;，&lt;code&gt;context&lt;/code&gt;可能都是使用者传入的，开发者无法保证&lt;code&gt;key&lt;/code&gt;的唯一性，因此可能会有非预期行为，因此使用定制的私有类型，保证程序的可控性。&lt;/p&gt;
&lt;h3&gt;value的类型&lt;/h3&gt;
&lt;p&gt;要求：传递多个信息到下游时，使用map类型，而不是创建多个节点。&lt;/p&gt;
&lt;p&gt;原因：通常跨进程传输数据时，会传输大量的信息，如果每个值都使用一个&lt;code&gt;context&lt;/code&gt;节点，会使得&lt;code&gt;context&lt;/code&gt;树很臃肿，而且信息分散在各个&lt;code&gt;context&lt;/code&gt;节点，因此通常将要传输的信息打包到一个&lt;code&gt;map&lt;/code&gt;然后放在一个&lt;code&gt;context&lt;/code&gt;节点中。&lt;/p&gt;
&lt;h3&gt;value的并发安全&lt;/h3&gt;
&lt;p&gt;要求：value的内容是只读的。&lt;/p&gt;
&lt;p&gt;原因：context 是并发安全的，但是当通过 value 获取到的数据可能存在并发安全的问题，如果值的类型是指针或者引用类型，就会面临并发安全的问题。上下文用于描述历史，历史中已经存在的内容不可变更，历史只会不断的增长。&lt;/p&gt;
&lt;h3&gt;超时控制&lt;/h3&gt;
&lt;p&gt;要求：使用父节点创建新的节点时，不需要考虑祖先节点的超时时间。&lt;/p&gt;
&lt;p&gt;原因：细节4确保内部会通过节点类型变换保证父节点的&lt;code&gt;Deadline&lt;/code&gt;大于子节点。&lt;/p&gt;
</description><link>https://studygolang.com/topics/14203</link><guid isPermaLink="false">https://studygolang.com/topics/14203</guid><pubDate>Thu, 26 Aug 2021 09:32:20 GMT</pubDate><author>Saner-Lee</author><category>每日一学</category></item><item><title>第一次运行GO,求大佬指点</title><description>&lt;p&gt;&lt;img src=&quot;https://static.studygolang.com/210806/43e2f16a14d887757fd2a2223aadaede.png&quot; alt=&quot;1628240578(1).png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
</description><link>https://studygolang.com/topics/14084</link><guid isPermaLink="false">https://studygolang.com/topics/14084</guid><pubDate>Fri, 06 Aug 2021 09:05:17 GMT</pubDate><author>Xie_123dreamfish</author><category>每日一学</category></item><item><title>付费用户「每日一学」2020-08-20：函数是一等公民，这到底在说什么？</title><description></description><link>https://studygolang.com/topics/12157</link><guid isPermaLink="false">https://studygolang.com/topics/12157</guid><pubDate>Thu, 20 Aug 2020 12:03:28 GMT</pubDate><author>polaris</author><category>每日一学</category></item><item><title>Golang 优雅地生成随机字符串</title><description>&lt;h1&gt;Golang 优雅地生成随机字符串&lt;/h1&gt;
&lt;p&gt;随机字符串都不保证唯一性，服务启动时需要对全局随机种子进行初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func init() {
	rand.Seed(time.Now().UnixNano())
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;方法一 （常见，但不&lt;code&gt;优雅&lt;/code&gt;）&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func GetRandomString(n int) string {
	str := &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;
	bytes := []byte(str)
	var result []byte
	for i := 0; i &amp;amp;lt; n; i++ {
		result = append(result, bytes[rand.Intn(len(bytes))])
	}
	return string(result)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Benchmark压力测试 &lt;code&gt;8018 ns/op&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.studygolang.com/200808/760f0b0704e2a005b7d2e4778ce4f846.png&quot; alt=&quot;image-7iOYcGn.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
&lt;h2&gt;方法二（&lt;code&gt;Docker ContainerID&lt;/code&gt; 生成方法）&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func GetRandomString2(n int) string {
	randBytes := make([]byte, n/2)
	rand.Read(randBytes)
	return fmt.Sprintf(&quot;%x&quot;, randBytes)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Benchmark压力测试 &lt;code&gt;10595 ns/op&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.studygolang.com/200808/cf1bd3be0a0bc905c99a7ea98045ce50.png&quot; alt=&quot;image-2E7hUwM.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
</description><link>https://studygolang.com/topics/12072</link><guid isPermaLink="false">https://studygolang.com/topics/12072</guid><pubDate>Sat, 08 Aug 2020 05:15:54 GMT</pubDate><author>avtionlsill</author><category>每日一学</category></item><item><title>付费用户「每日一学」2020-08-02：这道面试题你会吗？原因又知晓吗？</title><description></description><link>https://studygolang.com/topics/12037</link><guid isPermaLink="false">https://studygolang.com/topics/12037</guid><pubDate>Sun, 02 Aug 2020 08:28:36 GMT</pubDate><author>polaris</author><category>每日一学</category></item><item><title>关于go的协程和go的IDE的问题</title><description>&lt;p&gt;在学习过程中遇到了问题，请教各位大佬&lt;/p&gt;
&lt;p&gt;1)假设在一个单核处理器上运行多个go的协程，我认为go的主线程和所有go的协程都是在同一个核上并发执行的。那如果现在变成了双核处理器，主线程和协程是一定在同一个核上并发执行，还是主线程和协程(s)一定是分别在两个核上并行执行，还是取决于go的调度？&lt;/p&gt;
&lt;p&gt;2)很喜欢goland，尤其喜欢他的自动import和模糊搜索函数(输入open就会弹出一堆函数名跟open有关的函数让用户选择)还有ctrl点击查看函数源码这三个功能，在我的台式机上跑起来是很轻松，但是拿去办公的电脑性能不太够，装了pycharm后不想装goland(一般都是同时开这两个软件，还有pycharm的golang无法安装，按着某度的几乎完全统一的描述去做看到完全不一样的情景，应该是版本问题)，请问有大佬可以推荐一下轻量级一点的满足以上3个功能的IDE或者编辑器或者新版的pycharm安装golang插件的教程吗，万分感谢&lt;/p&gt;
</description><link>https://studygolang.com/topics/11486</link><guid isPermaLink="false">https://studygolang.com/topics/11486</guid><pubDate>Sun, 17 May 2020 13:06:27 GMT</pubDate><author>ClarkChxxNB</author><category>每日一学</category></item><item><title>付费用户「每日一学」2019-12-09：map 的优化小技巧</title><description></description><link>https://studygolang.com/topics/10562</link><guid isPermaLink="false">https://studygolang.com/topics/10562</guid><pubDate>Mon, 09 Dec 2019 13:54:05 GMT</pubDate><author>polaris</author><category>每日一学</category></item><item><title>ssh登录二次验证，让服务器更安全。</title><description>&lt;h1&gt;&lt;a href=&quot;https://gitee.com/janbar/sshdTwoVerification&quot;&gt;码云地址&lt;/a&gt;&lt;/h1&gt;
&lt;h1&gt;sshdTwoVerification&lt;/h1&gt;
&lt;h4&gt;介绍&lt;/h4&gt;
&lt;p&gt;ssh登录二次验证&lt;br&gt;
问题：现在很多人的Linux服务器可能会被攻击，只校验一次后台用户名密码登录变得不再保险。&lt;br&gt;
当然大家首先要做的是修改ssh服务端口，不要用默认22，这样会增加攻击难度，但还是不保险。&lt;/p&gt;
&lt;p&gt;方案1：使用ssh密钥文件登录，好处就是拿不到密钥文件休想登录成功，而且还能对密钥文件再次添加密码，&lt;br&gt;
这样的方案确实比较保险。但也有弊端，就是需要将密钥文件存到网盘或别的地方，不然找不到密钥文件就GG了。&lt;/p&gt;
&lt;p&gt;方案2：隆重推出本项目的方案，替换登录时使用的bash，让替换后的程序再次以自定义的方案验证一次，&lt;br&gt;
这样就做到了登录的二次验证，无疑增加了安全性。注意此时服务器已经不能使用scp等一些工具，安全性极大的提高。&lt;/p&gt;
&lt;h4&gt;安装教程,&lt;a href=&quot;http://janbar.sh/&quot;&gt;janbar.sh&lt;/a&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;echo &#39;/bin/janbar&#39; &amp;gt;&amp;gt; /etc/shells ,确保/etc/shells里面有一行/bin/janbar即可&lt;/li&gt;
&lt;li&gt;cp &lt;a href=&quot;http://janbar.sh/&quot;&gt;janbar.sh&lt;/a&gt; /bin/janbar &amp;amp;&amp;amp; chmod 777 /bin/janbar&lt;/li&gt;
&lt;li&gt;echo &#39;admin:passwd&#39; &amp;gt; /etc/janbar&lt;/li&gt;
&lt;li&gt;vim /etc/passwd , 将[root:x:0:0:root:/root:/bin/bash]改为[root:x:0:0:root:/root:/bin/janbar]&lt;/li&gt;
&lt;li&gt;重新登录后台，需要输入/etc/janbar这个文件中的用户名和密码&lt;br&gt;
&lt;img src=&quot;https://gitee.com/janbar/sshdTwoVerification/raw/master/janbar.sh.gif&quot; alt=&quot;janbar.sh.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/li&gt;
&lt;li&gt;执行ps auxf，可以看到成功进入后台相关进程树&lt;br&gt;
&lt;img src=&quot;https://gitee.com/janbar/sshdTwoVerification/raw/master/janbar.sh.jpg&quot; alt=&quot;janbar.sh.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;安装教程,janbar.c&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;echo &#39;/bin/janbar&#39; &amp;gt;&amp;gt; /etc/shells ,确保/etc/shells里面有一行/bin/janbar即可&lt;/li&gt;
&lt;li&gt;gcc -s janbar.c -o /bin/janbar&lt;/li&gt;
&lt;li&gt;echo &#39;admin:passwd&#39; &amp;gt; /etc/janbar&lt;/li&gt;
&lt;li&gt;vim /etc/passwd , 将[root:x:0:0:root:/root:/bin/bash]改为[root:x:0:0:root:/root:/bin/janbar]&lt;/li&gt;
&lt;li&gt;重新登录后台，需要输入/etc/janbar这个文件中的用户名和密码，登录图片和janbar.sh的类似。&lt;/li&gt;
&lt;li&gt;执行ps auxf，可以看到成功进入后台相关进程树&lt;br&gt;
&lt;img src=&quot;https://gitee.com/janbar/sshdTwoVerification/raw/master/janbar.c.jpg&quot; alt=&quot;janbar.c.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;安装教程,&lt;a href=&quot;http://janbar.qrencode.sh/&quot;&gt;janbar.qrencode.sh&lt;/a&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;a href=&quot;https://fukuchi.org/works/qrencode/&quot;&gt;二维码库&lt;/a&gt;，编译后取出本项目qrencode目录那几个文件即可。&lt;/li&gt;
&lt;li&gt;cp &lt;a href=&quot;http://janbar.qrencode.sh/&quot;&gt;janbar.qrencode.sh&lt;/a&gt; /bin/janbar &amp;amp;&amp;amp; chmod 777 /bin/janbar&lt;/li&gt;
&lt;li&gt;echo &#39;admin&#39; &amp;gt; /etc/janbar&lt;/li&gt;
&lt;li&gt;vim /etc/passwd , 将[root:x:0:0:root:/root:/bin/bash]改为[root:x:0:0:root:/root:/bin/janbar]&lt;/li&gt;
&lt;li&gt;重新登录后台，此时出现一张二维码，用微信扫描一下二维码并计算出结果，例如结果为15，则要输入admin15。&lt;br&gt;
&lt;img src=&quot;https://gitee.com/janbar/sshdTwoVerification/raw/master/janbar.qrencode.sh.gif&quot; alt=&quot;janbar.qrencode.sh.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;安装教程,janbar.qrencode.c&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;a href=&quot;https://fukuchi.org/works/qrencode/&quot;&gt;二维码库&lt;/a&gt;，编译后取出本项目qrencode目录那几个文件即可。&lt;/li&gt;
&lt;li&gt;gcc -s -o /bin/janbar janbar.qrencode.c ./qrencode/libqrencode.so.4&lt;/li&gt;
&lt;li&gt;echo &#39;admin&#39; &amp;gt; /etc/janbar&lt;/li&gt;
&lt;li&gt;vim /etc/passwd , 将[root:x:0:0:root:/root:/bin/bash]改为[root:x:0:0:root:/root:/bin/janbar]&lt;/li&gt;
&lt;li&gt;重新登录后台，此时出现一张二维码，用微信扫描一下二维码并计算出结果，例如结果为15，则要输入admin15。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;结语&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;我的两种方案都有对输入做超时检测，如果超过时间没有输入后台也会自动退出，同样输入错误3次也会自动退出。&lt;/li&gt;
&lt;li&gt;有些小伙伴后台不是root登录，可以找/etc/passwd里面对应用户名那行做同样的修改即可。&lt;/li&gt;
&lt;li&gt;之所以我要做2中方案，是因为janbar.sh方便修改，而janbar.c逼格满满。&lt;/li&gt;
&lt;li&gt;并且已经加入控制台显示一张二维码，带有简单的加和乘计算，输入二次验证时需要计算，逼格和安全全满。&lt;/li&gt;
&lt;li&gt;需要注意的一点，这样的后台是无法使用scp、sftp等直接连接，除非这些工具也能完成二次验证。&lt;/li&gt;
&lt;/ol&gt;
</description><link>https://studygolang.com/topics/10407</link><guid isPermaLink="false">https://studygolang.com/topics/10407</guid><pubDate>Mon, 11 Nov 2019 11:44:37 GMT</pubDate><author>jan-bar</author><category>每日一学</category></item><item><title>记录一下自己对go里面for range的bug 坑 理解，第一次在这个大社区发布</title><description>&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import &quot;fmt&quot;

//for range 经典bug 坑的解释
func main(){
	a := []int{1,2,3,4}

	//遍历切片
	for k,v  := range a{
		fmt.Println(k,v)
		fmt.Println(&amp;amp;amp;k,&quot;==&quot;,&amp;amp;amp;v)  //地址相同
	}

	//遍历切片
	for k,v  := range a{
		kk,vv := k,v   //new一个变量
		fmt.Println(k,v)
		fmt.Println(&amp;amp;amp;kk,&quot;==&quot;,&amp;amp;amp;vv)  //地址不同，达到要求
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结： 因为go的for range循环 里面  k，v都是公用的变量，所以地址都一样，要想不一样，就得再new一个变量并赋值，然后取地址&lt;/p&gt;
&lt;p&gt;golang官方for range 文档: &lt;a href=&quot;https://garbagecollected.org/2017/02/22/go-range-loop-internals/&quot;&gt;https://garbagecollected.org/2017/02/22/go-range-loop-internals/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;理解有不妥之处还请见谅，欢迎指正，一起学习，哈哈&lt;/p&gt;
</description><link>https://studygolang.com/topics/10269</link><guid isPermaLink="false">https://studygolang.com/topics/10269</guid><pubDate>Fri, 18 Oct 2019 06:35:43 GMT</pubDate><author>konglong87EddyLee1010</author><category>每日一学</category></item><item><title>【09】Go 标准库 flag 模块应用</title><description>&lt;h1&gt;Go 标准库 flag 模块应用&lt;/h1&gt;
&lt;p&gt;参考&lt;a href=&quot;https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter13/13.1.html?q=&quot;&gt;Go语言标准库》一书的对应章节：flag – 命令行参数解析&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;作为普通玩家不需要过多的了解 flag 背后是如何实现的，可以直接拿来用。&lt;/p&gt;
&lt;h2&gt;使用流程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义一个命令行参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://flag.xxx/&quot;&gt;flag.Xxx&lt;/a&gt;()：Xxx可以是Int、String等；返回一个相应类型的指针&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ip = flag.Int(&quot;flagname&quot;, 1234, &quot;help message for flagname&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flag.XxxVar()：将flag绑定到一个变量上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var flagvar int
flag.IntVar(&amp;amp;amp;flagvar, &quot;flagname&quot;, 1234, &quot;help message for flagname&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解析参数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;flag.Parse() // 通常会放到 func init() 函数体中，先于 main 函数执行
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程序中使用参数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flag.Xxx()&lt;/code&gt; 方式的定义，返回值是一个指针，需要使用 &lt;code&gt;*&lt;/code&gt; 获取指针指向的值（如上的 *ip）；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flag.XxxVar()&lt;/code&gt; 方式的定义，绑定了一个变量，直接引用该变量即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命令行参数格式&lt;/p&gt;
&lt;p&gt;命令行中需要在我们定义的&lt;em&gt;命令行参数&lt;/em&gt;前加入 &lt;code&gt;-&lt;/code&gt; 来指定参数。命令行参数指定支持下面 3 种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-flag&lt;/code&gt;       // 只支持bool类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-flag=value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-flag value&lt;/code&gt; // 只支持非bool类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ nginx -h
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;示例程序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
    &quot;flag&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

var (
    arg_help bool
    arg_host string
    arg_port int
)

func init() {
    flag.BoolVar(&amp;amp;amp;arg_help, &quot;h&quot;, false, &quot;this help&quot;)
    flag.StringVar(&amp;amp;amp;arg_host, &quot;H&quot;, &quot;127.0.0.1&quot;, &quot;Appoint the host of remote tcp server&quot;)

    // 另一种绑定方式
    var _port = flag.Int(&quot;P&quot;, &quot;8080&quot;, &quot;Appoint the port of remote tcp server&quot;)

    flag.Parse()

    arg_port = *_port
    fmt.Printf(&quot;Input port arg: %d\n&quot;, arg_port)
}

func main() {

    if arg_help {
        fmt.Println(&quot;This is a tcp client demo, command line is as tcp_client [-H 127.0.0.1] [-P 8080]&quot;)
    }

    fmt.Println(&quot;Host:&quot;, arg_host, &quot;Port:&quot;, arg_port)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将上面的代码保存为 tcp_client.go，然后使用命令 &lt;code&gt;go run tcp_client.go -H 192.168.1.100 -P 8081&lt;/code&gt; 运行，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ubuntu@VM-16-11-ubuntu:~/work/GoNote/TrainingCode/flag$ go run tcp_client.go -H 192.168.1.100 -P 8081
Input port arg: 8081
Host: 192.168.1.100 Port: 8081
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相信你看完就知道怎么用了。&lt;/p&gt;
</description><link>https://studygolang.com/topics/10181</link><guid isPermaLink="false">https://studygolang.com/topics/10181</guid><pubDate>Wed, 02 Oct 2019 05:49:27 GMT</pubDate><author>murphyzhaomengmeng</author><category>每日一学</category></item><item><title>go使用exec.Command执行带管道的命令</title><description>&lt;h3&gt;&lt;a href=&quot;https://www.ikaze.cn/article/44&quot;&gt;原文链接&lt;/a&gt; : &lt;a href=&quot;https://www.ikaze.cn/article/44&quot;&gt;https://www.ikaze.cn/article/44&lt;/a&gt;&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;在go中我们想执行带管道的命令时（如：&lt;code&gt;ps aux|grep go&lt;/code&gt;），不能直接像下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;exec.Command(&quot;ps&quot;, &quot;aux&quot;, &quot;|&quot;, &quot;grep&quot;, &quot;go&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样做不会有任何输出。&lt;/p&gt;
&lt;p&gt;有两种方法可以做到：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;sh -c &quot;&quot;&lt;/code&gt;命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;exec.Command(&quot;bash&quot;, &quot;-c&quot;, &quot;ps aux|grep go&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是推荐的做法。&lt;br&gt;
如果输出不是很多，推荐使用&lt;code&gt;github.com/go-cmd/cmd&lt;/code&gt;库来执行系统命令，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;import &quot;github.com/go-cmd/cmd&quot;

c := cmd.NewCmd(&quot;bash&quot;, &quot;-c&quot;, &quot;ps aux|grep go&quot;)
&amp;amp;lt;-c.Start()
fmt.Println(c.Status().Stdout)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;io.Pipe()&lt;/code&gt;连接两个命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;ps := exec.Command(&quot;ps&quot;, &quot;aux&quot;)
grep := exec.Command(&quot;grep&quot;, &quot;go&quot;)

r, w := io.Pipe() // 创建一个管道
defer r.Close()
defer w.Close()
ps.Stdout = w  // ps向管道的一端写
grep.Stdin = r // grep从管道的一端读

var buffer bytes.Buffer
grep.Stdout = &amp;amp;amp;buffer

ps.Start()
grep.Start()

ps.Wait()
w.Close()
grep.Wait()

io.Copy(os.Stdout, &amp;amp;amp;buffer)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种方法非常不方便，而且无法使用&lt;code&gt;grep.Stdout()&lt;/code&gt;，&lt;code&gt;grep.StdoutPipe()&lt;/code&gt;获取输出&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description><link>https://studygolang.com/topics/10056</link><guid isPermaLink="false">https://studygolang.com/topics/10056</guid><pubDate>Thu, 12 Sep 2019 07:52:25 GMT</pubDate><author>gojuukazemengmeng</author><category>每日一学</category></item><item><title>关于if data != nil &amp;&amp; len(data) != n { }的思考</title><description>&lt;p&gt;1.我经常看到在项目里面使用了下面这些代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if data != nil &amp;amp;amp;&amp;amp;amp; len(data) != 0 {  
	do  xxx
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我就在思考，为啥要多写一个判断data != nil&lt;br&gt;
因此我测试了下面的代码,发现完全可以去掉第一个判断&lt;br&gt;
因为len(nil)==0，因此第一个判断去掉没有任何问题的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import &quot;fmt&quot;

func main() {
	var data1 []interface{} = nil
	data2 := []interface{}{}
	data3 := make([]interface{}, 0, 8)
	fmt.Println(len(data1), len(data2), len(data3))
}

result:0 0 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.由此还能想到很多其他场景,下面两个也没必要判断data==nil的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;if len(data) == n {
}
if len(data) != n {
}
&lt;/code&gt;&lt;/pre&gt;
</description><link>https://studygolang.com/topics/9938</link><guid isPermaLink="false">https://studygolang.com/topics/9938</guid><pubDate>Sat, 24 Aug 2019 13:24:56 GMT</pubDate><author>jan-barmengmeng</author><category>每日一学</category></item><item><title>付费用户「每日一学」2019-07-15：Go中的定时任务3：time.Ticker</title><description></description><link>https://studygolang.com/topics/9585</link><guid isPermaLink="false">https://studygolang.com/topics/9585</guid><pubDate>Mon, 15 Jul 2019 15:33:06 GMT</pubDate><author>polariskekemuyu</author><category>每日一学</category></item></channel></rss>